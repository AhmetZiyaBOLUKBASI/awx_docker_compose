{"ast":null,"code":"/**\n * header-row.tsx\n *\n * Forked from reactabular-table version 8.14.0\n * https://github.com/reactabular/reactabular/tree/v8.14.0/packages/reactabular-table/src\n */\nimport * as React from 'react';\nimport { evaluateFormatters } from './evaluate-formatters';\nimport { evaluateTransforms } from './evaluate-transforms';\nimport { mergeProps } from './merge-props';\nimport { HeaderCellInfoWrapper } from '../HeaderCellInfoWrapper';\nexport var HeaderRow = function HeaderRow(_ref) {\n  var rowData = _ref.rowData,\n      rowIndex = _ref.rowIndex,\n      renderers = _ref.renderers,\n      _ref$onRow = _ref.onRow,\n      onRow = _ref$onRow === void 0 ? function () {\n    return {};\n  } : _ref$onRow;\n  return React.createElement(renderers.row, onRow(rowData, {\n    rowIndex: rowIndex\n  }), rowData.map(function (column, columnIndex) {\n    var property = column.property,\n        _column$header = column.header,\n        header = _column$header === void 0 ? {} : _column$header,\n        _column$props = column.props,\n        props = _column$props === void 0 ? {} : _column$props;\n    var evaluatedProperty = property || header && header.property;\n    var label = header.label,\n        _header$transforms = header.transforms,\n        transforms = _header$transforms === void 0 ? [] : _header$transforms,\n        _header$formatters = header.formatters,\n        formatters = _header$formatters === void 0 ? [] : _header$formatters,\n        _header$info = header.info,\n        info = _header$info === void 0 ? {} : _header$info;\n    var extraParameters = {\n      columnIndex: columnIndex,\n      property: evaluatedProperty,\n      column: column\n    };\n    var transformedProps = evaluateTransforms(transforms, label, extraParameters);\n\n    if (!transformedProps) {\n      // tslint:disable-next-line:no-console\n      console.warn('Table.Header - Failed to receive a transformed result'); // eslint-disable-line max-len, no-console\n    }\n\n    var cellNode;\n    var tooltip = info.tooltip,\n        tooltipProps = info.tooltipProps,\n        popover = info.popover,\n        popoverProps = info.popoverProps,\n        ariaLabel = info.ariaLabel,\n        className = info.className; // consumer can specify header cell tooltip/popover in two ways, but the transforms approach is preferred,\n    // especially for sorting tables that use `transforms: [sortable]`\n    // {\n    //   title: 'Repositories',\n    //   header: {\n    //     info: {\n    //       tooltip: 'More information about repositories',\n    //       className: 'repositories-info-tip',\n    //       tooltipProps: {\n    //         isContentLeftAligned: true\n    //       }\n    //     }\n    //   }\n    // }\n    //\n    // {\n    //   title: 'Repositories',\n    //   transforms: [\n    //     info({\n    //       tooltip: 'More information about repositories',\n    //       className: 'repositories-info-tip',\n    //       tooltipProps: {\n    //         isContentLeftAligned: true\n    //       }\n    //     }),\n    //     sortable\n    //   ]\n    // },\n\n    if (tooltip) {\n      cellNode = React.createElement(HeaderCellInfoWrapper, {\n        variant: \"tooltip\",\n        info: tooltip,\n        tooltipProps: tooltipProps,\n        ariaLabel: ariaLabel,\n        className: className\n      }, transformedProps.children || evaluateFormatters(formatters)(label, extraParameters));\n    } else if (popover) {\n      cellNode = React.createElement(HeaderCellInfoWrapper, {\n        variant: \"popover\",\n        info: popover,\n        popoverProps: popoverProps,\n        ariaLabel: ariaLabel,\n        className: className\n      }, transformedProps.children || evaluateFormatters(formatters)(label, extraParameters));\n    } else {\n      cellNode = transformedProps.children || evaluateFormatters(formatters)(label, extraParameters);\n    }\n\n    return React.createElement(renderers.cell, Object.assign({\n      key: \"\".concat(columnIndex, \"-header\")\n    }, mergeProps(props, header && header.props, transformedProps)), cellNode);\n  }));\n};\nHeaderRow.displayName = 'HeaderRow';","map":{"version":3,"sources":["/awx_devel/awx/ui/node_modules/@patternfly/react-table/src/components/Table/base/header-row.tsx"],"names":[],"mappings":"AAAA;;;;;AAKG;AACH,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AACA,SAAS,kBAAT,QAAmC,uBAAnC;AACA,SAAS,kBAAT,QAAmC,uBAAnC;AACA,SAAS,UAAT,QAA2B,eAA3B;AAEA,SAAS,qBAAT,QAAsC,0BAAtC;AASA,OAAO,IAAM,SAAS,GAA4C,SAArD,SAAqD;AAAA,MAChE,OADgE,QAChE,OADgE;AAAA,MAEhE,QAFgE,QAEhE,QAFgE;AAAA,MAGhE,SAHgE,QAGhE,SAHgE;AAAA,wBAIhE,KAJgE;AAAA,MAIhE,KAJgE,2BAIxD;AAAA,WAAO,EAAP;AAAA,GAJwD;AAAA,SAMhE,KAAK,CAAC,aAAN,CACE,SAAS,CAAC,GADZ,EAEE,KAAK,CAAC,OAAD,EAAU;AAAE,IAAA,QAAQ,EAAR;AAAF,GAAV,CAFP,EAGG,OAAc,CAAC,GAAf,CAAmB,UAAC,MAAD,EAAqB,WAArB,EAA4C;AAC9D,QAAQ,QAAR,GAA4D,MAA5D,CAAQ,QAAR;AAAA,yBAA4D,MAA5D,CAAkB,MAAlB;AAAA,QAAkB,MAAlB,+BAA2B,EAA3B;AAAA,wBAA4D,MAA5D,CAA6C,KAA7C;AAAA,QAA6C,KAA7C,8BAAqD,EAArD;AACA,QAAM,iBAAiB,GAAG,QAAQ,IAAK,MAAM,IAAI,MAAM,CAAC,QAAxD;AACA,QAAQ,KAAR,GAA+D,MAA/D,CAAQ,KAAR;AAAA,6BAA+D,MAA/D,CAAe,UAAf;AAAA,QAAe,UAAf,mCAA4B,EAA5B;AAAA,6BAA+D,MAA/D,CAAgC,UAAhC;AAAA,QAAgC,UAAhC,mCAA6C,EAA7C;AAAA,uBAA+D,MAA/D,CAAiD,IAAjD;AAAA,QAAiD,IAAjD,6BAAwD,EAAxD;AACA,QAAM,eAAe,GAAG;AACtB,MAAA,WAAW,EAAX,WADsB;AAEtB,MAAA,QAAQ,EAAE,iBAFY;AAGtB,MAAA,MAAM,EAAN;AAHsB,KAAxB;AAKA,QAAM,gBAAgB,GAAG,kBAAkB,CAAC,UAAD,EAAa,KAAb,EAAoB,eAApB,CAA3C;;AAEA,QAAI,CAAC,gBAAL,EAAuB;AACrB;AACA,MAAA,OAAO,CAAC,IAAR,CAAa,uDAAb,EAFqB,CAEkD;AACxE;;AAED,QAAI,QAAJ;AACA,QAAQ,OAAR,GAA+E,IAA/E,CAAQ,OAAR;AAAA,QAAiB,YAAjB,GAA+E,IAA/E,CAAiB,YAAjB;AAAA,QAA+B,OAA/B,GAA+E,IAA/E,CAA+B,OAA/B;AAAA,QAAwC,YAAxC,GAA+E,IAA/E,CAAwC,YAAxC;AAAA,QAAsD,SAAtD,GAA+E,IAA/E,CAAsD,SAAtD;AAAA,QAAiE,SAAjE,GAA+E,IAA/E,CAAiE,SAAjE,CAjB8D,CAkB9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAI,OAAJ,EAAa;AACX,MAAA,QAAQ,GACN,KAAA,CAAA,aAAA,CAAC,qBAAD,EAAsB;AACpB,QAAA,OAAO,EAAC,SADY;AAEpB,QAAA,IAAI,EAAE,OAFc;AAGpB,QAAA,YAAY,EAAE,YAHM;AAIpB,QAAA,SAAS,EAAE,SAJS;AAKpB,QAAA,SAAS,EAAE;AALS,OAAtB,EAOG,gBAAgB,CAAC,QAAjB,IAA6B,kBAAkB,CAAC,UAAD,CAAlB,CAA+B,KAA/B,EAAsC,eAAtC,CAPhC,CADF;AAWD,KAZD,MAYO,IAAI,OAAJ,EAAa;AAClB,MAAA,QAAQ,GACN,KAAA,CAAA,aAAA,CAAC,qBAAD,EAAsB;AACpB,QAAA,OAAO,EAAC,SADY;AAEpB,QAAA,IAAI,EAAE,OAFc;AAGpB,QAAA,YAAY,EAAE,YAHM;AAIpB,QAAA,SAAS,EAAE,SAJS;AAKpB,QAAA,SAAS,EAAE;AALS,OAAtB,EAOG,gBAAgB,CAAC,QAAjB,IAA6B,kBAAkB,CAAC,UAAD,CAAlB,CAA+B,KAA/B,EAAsC,eAAtC,CAPhC,CADF;AAWD,KAZM,MAYA;AACL,MAAA,QAAQ,GAAG,gBAAgB,CAAC,QAAjB,IAA6B,kBAAkB,CAAC,UAAD,CAAlB,CAA+B,KAA/B,EAAsC,eAAtC,CAAxC;AACD;;AAED,WAAO,KAAK,CAAC,aAAN,CACL,SAAS,CAAC,IADL,EAC8B,MAAA,CAAA,MAAA,CAAA;AAEjC,MAAA,GAAG,YAAK,WAAL;AAF8B,KAAA,EAG9B,UAAU,CAAC,KAAD,EAAQ,MAAM,IAAI,MAAM,CAAC,KAAzB,EAAgC,gBAAhC,CAHoB,CAD9B,EAML,QANK,CAAP;AAQD,GAlFA,CAHH,CANgE;AAAA,CAA3D;AA6FP,SAAS,CAAC,WAAV,GAAwB,WAAxB","sourcesContent":["/**\n * header-row.tsx\n *\n * Forked from reactabular-table version 8.14.0\n * https://github.com/reactabular/reactabular/tree/v8.14.0/packages/reactabular-table/src\n */\nimport * as React from 'react';\nimport { evaluateFormatters } from './evaluate-formatters';\nimport { evaluateTransforms } from './evaluate-transforms';\nimport { mergeProps } from './merge-props';\nimport { createElementType, ColumnType, HeaderType, RowsType, RendererType } from './types';\nimport { HeaderCellInfoWrapper } from '../HeaderCellInfoWrapper';\n\nexport interface HeaderRowProps {\n  rowData: RowsType;\n  rowIndex: number;\n  renderers: RendererType;\n  onRow?: Function;\n}\n\nexport const HeaderRow: React.FunctionComponent<HeaderRowProps> = ({\n  rowData,\n  rowIndex,\n  renderers,\n  onRow = () => ({})\n}: HeaderRowProps) =>\n  React.createElement(\n    renderers.row as createElementType,\n    onRow(rowData, { rowIndex }),\n    (rowData as []).map((column: ColumnType, columnIndex: number) => {\n      const { property, header = {} as HeaderType, props = {} } = column;\n      const evaluatedProperty = property || (header && header.property);\n      const { label, transforms = [], formatters = [], info = {} } = header;\n      const extraParameters = {\n        columnIndex,\n        property: evaluatedProperty,\n        column\n      };\n      const transformedProps = evaluateTransforms(transforms, label, extraParameters);\n\n      if (!transformedProps) {\n        // tslint:disable-next-line:no-console\n        console.warn('Table.Header - Failed to receive a transformed result'); // eslint-disable-line max-len, no-console\n      }\n\n      let cellNode;\n      const { tooltip, tooltipProps, popover, popoverProps, ariaLabel, className } = info;\n      // consumer can specify header cell tooltip/popover in two ways, but the transforms approach is preferred,\n      // especially for sorting tables that use `transforms: [sortable]`\n      // {\n      //   title: 'Repositories',\n      //   header: {\n      //     info: {\n      //       tooltip: 'More information about repositories',\n      //       className: 'repositories-info-tip',\n      //       tooltipProps: {\n      //         isContentLeftAligned: true\n      //       }\n      //     }\n      //   }\n      // }\n      //\n      // {\n      //   title: 'Repositories',\n      //   transforms: [\n      //     info({\n      //       tooltip: 'More information about repositories',\n      //       className: 'repositories-info-tip',\n      //       tooltipProps: {\n      //         isContentLeftAligned: true\n      //       }\n      //     }),\n      //     sortable\n      //   ]\n      // },\n      if (tooltip) {\n        cellNode = (\n          <HeaderCellInfoWrapper\n            variant=\"tooltip\"\n            info={tooltip}\n            tooltipProps={tooltipProps}\n            ariaLabel={ariaLabel}\n            className={className}\n          >\n            {transformedProps.children || evaluateFormatters(formatters)(label, extraParameters)}\n          </HeaderCellInfoWrapper>\n        );\n      } else if (popover) {\n        cellNode = (\n          <HeaderCellInfoWrapper\n            variant=\"popover\"\n            info={popover}\n            popoverProps={popoverProps}\n            ariaLabel={ariaLabel}\n            className={className}\n          >\n            {transformedProps.children || evaluateFormatters(formatters)(label, extraParameters)}\n          </HeaderCellInfoWrapper>\n        );\n      } else {\n        cellNode = transformedProps.children || evaluateFormatters(formatters)(label, extraParameters);\n      }\n\n      return React.createElement(\n        renderers.cell as createElementType,\n        {\n          key: `${columnIndex}-header`,\n          ...mergeProps(props, header && header.props, transformedProps)\n        },\n        cellNode\n      );\n    })\n  );\nHeaderRow.displayName = 'HeaderRow';\n"]},"metadata":{},"sourceType":"module"}