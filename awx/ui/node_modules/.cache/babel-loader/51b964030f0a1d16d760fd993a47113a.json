{"ast":null,"code":"import _defineProperty from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport * as ReactDOM from 'react-dom';\nimport { SIDE } from './constants';\n/**\n * @param {string} input - String to capitalize first letter\n */\n\nexport function capitalize(input) {\n  return input[0].toUpperCase() + input.substring(1);\n}\n/**\n * @param {string} prefix - String to prefix ID with\n */\n\nexport function getUniqueId() {\n  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'pf';\n  var uid = new Date().getTime() + Math.random().toString(36).slice(2);\n  return \"\".concat(prefix, \"-\").concat(uid);\n}\n/**\n * @param { any } this - \"This\" reference\n * @param { Function } func - Function to debounce\n * @param { number } wait - Debounce amount\n */\n\nexport function debounce(func, wait) {\n  var _this = this;\n\n  var timeout;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      return func.apply(_this, args);\n    }, wait);\n  };\n}\n/** This function returns whether or not an element is within the viewable area of a container. If partial is true,\n * then this function will return true even if only part of the element is in view.\n *\n * @param {HTMLElement} container  The container to check if the element is in view of.\n * @param {HTMLElement} element    The element to check if it is view\n * @param {boolean} partial   true if partial view is allowed\n * @param {boolean} strict    true if strict mode is set, never consider the container width and element width\n *\n * @returns { boolean } True if the component is in View.\n */\n\nexport function isElementInView(container, element, partial) {\n  var strict = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (!container || !element) {\n    return false;\n  }\n\n  var containerBounds = container.getBoundingClientRect();\n  var elementBounds = element.getBoundingClientRect();\n  var containerBoundsLeft = Math.ceil(containerBounds.left);\n  var containerBoundsRight = Math.floor(containerBounds.right);\n  var elementBoundsLeft = Math.ceil(elementBounds.left);\n  var elementBoundsRight = Math.floor(elementBounds.right); // Check if in view\n\n  var isTotallyInView = elementBoundsLeft >= containerBoundsLeft && elementBoundsRight <= containerBoundsRight;\n  var isPartiallyInView = (partial || !strict && containerBounds.width < elementBounds.width) && (elementBoundsLeft < containerBoundsLeft && elementBoundsRight > containerBoundsLeft || elementBoundsRight > containerBoundsRight && elementBoundsLeft < containerBoundsRight); // Return outcome\n\n  return isTotallyInView || isPartiallyInView;\n}\n/** This function returns the side the element is out of view on (right, left or both)\n *\n * @param {HTMLElement} container    The container to check if the element is in view of.\n * @param {HTMLElement} element      The element to check if it is view\n *\n * @returns {string} right if the element is of the right, left if element is off the left or both if it is off on both sides.\n */\n\nexport function sideElementIsOutOfView(container, element) {\n  var containerBounds = container.getBoundingClientRect();\n  var elementBounds = element.getBoundingClientRect();\n  var containerBoundsLeft = Math.floor(containerBounds.left);\n  var containerBoundsRight = Math.floor(containerBounds.right);\n  var elementBoundsLeft = Math.floor(elementBounds.left);\n  var elementBoundsRight = Math.floor(elementBounds.right); // Check if in view\n\n  var isOffLeft = elementBoundsLeft < containerBoundsLeft;\n  var isOffRight = elementBoundsRight > containerBoundsRight;\n  var side = SIDE.NONE;\n\n  if (isOffRight && isOffLeft) {\n    side = SIDE.BOTH;\n  } else if (isOffRight) {\n    side = SIDE.RIGHT;\n  } else if (isOffLeft) {\n    side = SIDE.LEFT;\n  } // Return outcome\n\n\n  return side;\n}\n/** Interpolates a parameterized templateString using values from a templateVars object.\n * The templateVars object should have keys and values which match the templateString's parameters.\n * Example:\n *    const templateString: 'My name is ${firstName} ${lastName}';\n *    const templateVars: {\n *      firstName: 'Jon'\n *      lastName: 'Dough'\n *    };\n *    const result = fillTemplate(templateString, templateVars);\n *    // \"My name is Jon Dough\"\n *\n * @param {string} templateString  The string passed by the consumer\n * @param {object} templateVars The variables passed to the string\n *\n * @returns {string} The template string literal result\n */\n\nexport function fillTemplate(templateString, templateVars) {\n  return templateString.replace(/\\${(.*?)}/g, function (_, match) {\n    return templateVars[match] || '';\n  });\n}\n/**\n * This function allows for keyboard navigation through dropdowns. The custom argument is optional.\n *\n * @param {number} index The index of the element you're on\n * @param {number} innerIndex Inner index number\n * @param {string} position The orientation of the dropdown\n * @param {string[]} refsCollection Array of refs to the items in the dropdown\n * @param {object[]} kids Array of items in the dropdown\n * @param {boolean} [custom] Allows for handling of flexible content\n */\n\nexport function keyHandler(index, innerIndex, position, refsCollection, kids) {\n  var custom = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n  if (!Array.isArray(kids)) {\n    return;\n  }\n\n  var isMultiDimensional = refsCollection.filter(function (ref) {\n    return ref;\n  })[0].constructor === Array;\n  var nextIndex = index;\n  var nextInnerIndex = innerIndex;\n\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = kids.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (position === 'down') {\n    if (index === kids.length - 1) {\n      // loop back to beginning\n      nextIndex = 0;\n    } else {\n      nextIndex = index + 1;\n    }\n  } else if (position === 'left') {\n    if (innerIndex === 0) {\n      nextInnerIndex = refsCollection[index].length - 1;\n    } else {\n      nextInnerIndex = innerIndex - 1;\n    }\n  } else if (position === 'right') {\n    if (innerIndex === refsCollection[index].length - 1) {\n      nextInnerIndex = 0;\n    } else {\n      nextInnerIndex = innerIndex + 1;\n    }\n  }\n\n  if (refsCollection[nextIndex] === null || refsCollection[nextIndex] === undefined || isMultiDimensional && (refsCollection[nextIndex][nextInnerIndex] === null || refsCollection[nextIndex][nextInnerIndex] === undefined)) {\n    keyHandler(nextIndex, nextInnerIndex, position, refsCollection, kids, custom);\n  } else if (custom) {\n    if (refsCollection[nextIndex].focus) {\n      refsCollection[nextIndex].focus();\n    } // eslint-disable-next-line react/no-find-dom-node\n\n\n    var element = ReactDOM.findDOMNode(refsCollection[nextIndex]);\n    element.focus();\n  } else if (position !== 'tab') {\n    if (isMultiDimensional) {\n      refsCollection[nextIndex][nextInnerIndex].focus();\n    } else {\n      refsCollection[nextIndex].focus();\n    }\n  }\n}\n/** This function returns a list of tabbable items in a container\n *\n *  @param {any} containerRef to the container\n *  @param {string} tababbleSelectors CSS selector string of tabbable items\n */\n\nexport function findTabbableElements(containerRef, tababbleSelectors) {\n  var tabbable = containerRef.current.querySelectorAll(tababbleSelectors);\n  var list = Array.prototype.filter.call(tabbable, function (item) {\n    return item.tabIndex >= '0';\n  });\n  return list;\n}\n/** This function is a helper for keyboard navigation through dropdowns.\n *\n * @param {number} index The index of the element you're on\n * @param {string} position The orientation of the dropdown\n * @param {string[]} collection Array of refs to the items in the dropdown\n */\n\nexport function getNextIndex(index, position, collection) {\n  var nextIndex;\n\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = collection.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (index === collection.length - 1) {\n    // loop back to beginning\n    nextIndex = 0;\n  } else {\n    nextIndex = index + 1;\n  }\n\n  if (collection[nextIndex] === undefined || collection[nextIndex][0] === null) {\n    return getNextIndex(nextIndex, position, collection);\n  } else {\n    return nextIndex;\n  }\n}\n/** This function is a helper for pluralizing strings.\n *\n * @param {number} i The quantity of the string you want to pluralize\n * @param {string} singular The singular version of the string\n * @param {string} plural The change to the string that should occur if the quantity is not equal to 1.\n *                 Defaults to adding an 's'.\n */\n\nexport function pluralize(i, singular, plural) {\n  if (!plural) {\n    plural = \"\".concat(singular, \"s\");\n  }\n\n  return \"\".concat(i || 0, \" \").concat(i === 1 ? singular : plural);\n}\n/**\n * This function is a helper for turning arrays of breakpointMod objects for flex and grid into style object\n *\n * @param {object} mods The modifiers object\n * @param {string} css-variable The appropriate css variable for the component\n */\n\nexport var setBreakpointCssVars = function setBreakpointCssVars(mods, cssVar) {\n  return Object.entries(mods || {}).reduce(function (acc, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        breakpoint = _ref2[0],\n        value = _ref2[1];\n\n    return breakpoint === 'default' ? Object.assign(Object.assign({}, acc), _defineProperty({}, cssVar, value)) : Object.assign(Object.assign({}, acc), _defineProperty({}, \"\".concat(cssVar, \"-on-\").concat(breakpoint), value));\n  }, {});\n};\n/**\n * This function is a helper for turning arrays of breakpointMod objects for data toolbar and flex into classes\n *\n * @param {object} mods The modifiers object\n * @param {any} styles The appropriate styles object for the component\n */\n\nexport var formatBreakpointMods = function formatBreakpointMods(mods, styles) {\n  var stylePrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var breakpoint = arguments.length > 3 ? arguments[3] : undefined;\n\n  if (!mods) {\n    return '';\n  }\n\n  if (breakpoint) {\n    if (breakpoint in mods) {\n      return styles.modifiers[toCamel(\"\".concat(stylePrefix).concat(mods[breakpoint]))];\n    } // the current breakpoint is not specified in mods, so we try to find the next nearest\n\n\n    var breakpointsOrder = ['2xl', 'xl', 'lg', 'md', 'sm', 'default'];\n    var breakpointsIndex = breakpointsOrder.indexOf(breakpoint);\n\n    for (var i = breakpointsIndex; i < breakpointsOrder.length; i++) {\n      if (breakpointsOrder[i] in mods) {\n        return styles.modifiers[toCamel(\"\".concat(stylePrefix).concat(mods[breakpointsOrder[i]]))];\n      }\n    }\n\n    return '';\n  }\n\n  return Object.entries(mods || {}).map(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        breakpoint = _ref4[0],\n        mod = _ref4[1];\n\n    return \"\".concat(stylePrefix).concat(mod).concat(breakpoint !== 'default' ? \"-on-\".concat(breakpoint) : '');\n  }).map(toCamel).map(function (mod) {\n    return mod.replace(/-?(\\dxl)/gi, function (_res, group) {\n      return \"_\".concat(group);\n    });\n  }).map(function (modifierKey) {\n    return styles.modifiers[modifierKey];\n  }).filter(Boolean).join(' ');\n};\n/**\n * Return the breakpoint for the given width\n *\n * @param {number | null} width The width to check\n * @returns {'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl'} The breakpoint\n */\n\nexport var getBreakpoint = function getBreakpoint(width) {\n  if (width === null) {\n    return null;\n  }\n\n  if (width >= 1450) {\n    return '2xl';\n  }\n\n  if (width >= 1200) {\n    return 'xl';\n  }\n\n  if (width >= 992) {\n    return 'lg';\n  }\n\n  if (width >= 768) {\n    return 'md';\n  }\n\n  if (width >= 576) {\n    return 'sm';\n  }\n\n  return 'default';\n};\n\nvar camelize = function camelize(s) {\n  return s.toUpperCase().replace('-', '').replace('_', '');\n};\n/**\n *\n * @param {string} s string to make camelCased\n */\n\n\nexport var toCamel = function toCamel(s) {\n  return s.replace(/([-_][a-z])/gi, camelize);\n};\n/**\n * Copied from exenv\n */\n\nexport var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n/**\n * Calculate the width of the text\n * Example:\n * getTextWidth('my text', node)\n *\n * @param {string} text The text to calculate the width for\n * @param {HTMLElement} node The HTML element\n */\n\nexport var getTextWidth = function getTextWidth(text, node) {\n  var computedStyle = getComputedStyle(node); // Firefox returns the empty string for .font, so this function creates the .font property manually\n\n  var getFontFromComputedStyle = function getFontFromComputedStyle() {\n    var computedFont = ''; // Firefox uses percentages for font-stretch, but Canvas does not accept percentages\n    // so convert to keywords, as listed at:\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/font-stretch\n\n    var fontStretchLookupTable = {\n      '50%': 'ultra-condensed',\n      '62.5%': 'extra-condensed',\n      '75%': 'condensed',\n      '87.5%': 'semi-condensed',\n      '100%': 'normal',\n      '112.5%': 'semi-expanded',\n      '125%': 'expanded',\n      '150%': 'extra-expanded',\n      '200%': 'ultra-expanded'\n    }; // If the retrieved font-stretch percentage isn't found in the lookup table, use\n    // 'normal' as a last resort.\n\n    var fontStretch;\n\n    if (computedStyle.fontStretch in fontStretchLookupTable) {\n      fontStretch = fontStretchLookupTable[computedStyle.fontStretch];\n    } else {\n      fontStretch = 'normal';\n    }\n\n    computedFont = computedStyle.fontStyle + ' ' + computedStyle.fontVariant + ' ' + computedStyle.fontWeight + ' ' + fontStretch + ' ' + computedStyle.fontSize + '/' + computedStyle.lineHeight + ' ' + computedStyle.fontFamily;\n    return computedFont;\n  };\n\n  var canvas = document.createElement('canvas');\n  var context = canvas.getContext('2d');\n  context.font = computedStyle.font || getFontFromComputedStyle();\n  return context.measureText(text).width;\n};\n/**\n * Get the inner dimensions of an element\n *\n * @param {HTMLElement} node HTML element to calculate the inner dimensions for\n */\n\nexport var innerDimensions = function innerDimensions(node) {\n  var computedStyle = getComputedStyle(node);\n  var width = node.clientWidth; // width with padding\n\n  var height = node.clientHeight; // height with padding\n\n  height -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);\n  width -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  return {\n    height: height,\n    width: width\n  };\n};\n/**\n * This function is a helper for truncating text content on the left, leaving the right side of the content in view\n *\n * @param {HTMLElement} node HTML element\n * @param {string} value The original text value\n */\n\nexport var trimLeft = function trimLeft(node, value) {\n  var availableWidth = innerDimensions(node).width;\n  var newValue = value;\n\n  if (getTextWidth(value, node) > availableWidth) {\n    // we have text overflow, trim the text to the left and add ... in the front until it fits\n    while (getTextWidth(\"...\".concat(newValue), node) > availableWidth) {\n      newValue = newValue.substring(1);\n    } // replace text with our truncated text\n\n\n    if (node.value) {\n      node.value = \"...\".concat(newValue);\n    } else {\n      node.innerText = \"...\".concat(newValue);\n    }\n  } else {\n    if (node.value) {\n      node.value = value;\n    } else {\n      node.innerText = value;\n    }\n  }\n};\n/**\n * @param {string[]} events - Operations to prevent when disabled\n */\n\nexport var preventedEvents = function preventedEvents(events) {\n  return events.reduce(function (handlers, eventToPrevent) {\n    return Object.assign(Object.assign({}, handlers), _defineProperty({}, eventToPrevent, function (event) {\n      event.preventDefault();\n    }));\n  }, {});\n};","map":{"version":3,"sources":["/awx_devel/awx/ui/node_modules/@patternfly/react-core/src/helpers/util.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ReactDOM from 'react-dom';\nimport { SIDE } from './constants';\n\n/**\n * @param {string} input - String to capitalize first letter\n */\nexport function capitalize(input: string) {\n  return input[0].toUpperCase() + input.substring(1);\n}\n\n/**\n * @param {string} prefix - String to prefix ID with\n */\nexport function getUniqueId(prefix = 'pf') {\n  const uid =\n    new Date().getTime() +\n    Math.random()\n      .toString(36)\n      .slice(2);\n  return `${prefix}-${uid}`;\n}\n\n/**\n * @param { any } this - \"This\" reference\n * @param { Function } func - Function to debounce\n * @param { number } wait - Debounce amount\n */\nexport function debounce(this: any, func: (...args: any[]) => any, wait: number) {\n  let timeout: number;\n  return (...args: any[]) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(this, args), wait) as any;\n  };\n}\n\n/** This function returns whether or not an element is within the viewable area of a container. If partial is true,\n * then this function will return true even if only part of the element is in view.\n *\n * @param {HTMLElement} container  The container to check if the element is in view of.\n * @param {HTMLElement} element    The element to check if it is view\n * @param {boolean} partial   true if partial view is allowed\n * @param {boolean} strict    true if strict mode is set, never consider the container width and element width\n *\n * @returns { boolean } True if the component is in View.\n */\nexport function isElementInView(\n  container: HTMLElement,\n  element: HTMLElement,\n  partial: boolean,\n  strict: boolean = false\n): boolean {\n  if (!container || !element) {\n    return false;\n  }\n  const containerBounds = container.getBoundingClientRect();\n  const elementBounds = element.getBoundingClientRect();\n  const containerBoundsLeft = Math.ceil(containerBounds.left);\n  const containerBoundsRight = Math.floor(containerBounds.right);\n  const elementBoundsLeft = Math.ceil(elementBounds.left);\n  const elementBoundsRight = Math.floor(elementBounds.right);\n\n  // Check if in view\n  const isTotallyInView = elementBoundsLeft >= containerBoundsLeft && elementBoundsRight <= containerBoundsRight;\n  const isPartiallyInView =\n    (partial || (!strict && containerBounds.width < elementBounds.width)) &&\n    ((elementBoundsLeft < containerBoundsLeft && elementBoundsRight > containerBoundsLeft) ||\n      (elementBoundsRight > containerBoundsRight && elementBoundsLeft < containerBoundsRight));\n\n  // Return outcome\n  return isTotallyInView || isPartiallyInView;\n}\n\n/** This function returns the side the element is out of view on (right, left or both)\n *\n * @param {HTMLElement} container    The container to check if the element is in view of.\n * @param {HTMLElement} element      The element to check if it is view\n *\n * @returns {string} right if the element is of the right, left if element is off the left or both if it is off on both sides.\n */\nexport function sideElementIsOutOfView(container: HTMLElement, element: HTMLElement): string {\n  const containerBounds = container.getBoundingClientRect();\n  const elementBounds = element.getBoundingClientRect();\n  const containerBoundsLeft = Math.floor(containerBounds.left);\n  const containerBoundsRight = Math.floor(containerBounds.right);\n  const elementBoundsLeft = Math.floor(elementBounds.left);\n  const elementBoundsRight = Math.floor(elementBounds.right);\n\n  // Check if in view\n  const isOffLeft = elementBoundsLeft < containerBoundsLeft;\n  const isOffRight = elementBoundsRight > containerBoundsRight;\n\n  let side = SIDE.NONE;\n\n  if (isOffRight && isOffLeft) {\n    side = SIDE.BOTH;\n  } else if (isOffRight) {\n    side = SIDE.RIGHT;\n  } else if (isOffLeft) {\n    side = SIDE.LEFT;\n  }\n  // Return outcome\n  return side;\n}\n\n/** Interpolates a parameterized templateString using values from a templateVars object.\n * The templateVars object should have keys and values which match the templateString's parameters.\n * Example:\n *    const templateString: 'My name is ${firstName} ${lastName}';\n *    const templateVars: {\n *      firstName: 'Jon'\n *      lastName: 'Dough'\n *    };\n *    const result = fillTemplate(templateString, templateVars);\n *    // \"My name is Jon Dough\"\n *\n * @param {string} templateString  The string passed by the consumer\n * @param {object} templateVars The variables passed to the string\n *\n * @returns {string} The template string literal result\n */\nexport function fillTemplate(templateString: string, templateVars: any) {\n  return templateString.replace(/\\${(.*?)}/g, (_, match) => templateVars[match] || '');\n}\n\n/**\n * This function allows for keyboard navigation through dropdowns. The custom argument is optional.\n *\n * @param {number} index The index of the element you're on\n * @param {number} innerIndex Inner index number\n * @param {string} position The orientation of the dropdown\n * @param {string[]} refsCollection Array of refs to the items in the dropdown\n * @param {object[]} kids Array of items in the dropdown\n * @param {boolean} [custom] Allows for handling of flexible content\n */\nexport function keyHandler(\n  index: number,\n  innerIndex: number,\n  position: string,\n  refsCollection: any[],\n  kids: any[],\n  custom = false\n) {\n  if (!Array.isArray(kids)) {\n    return;\n  }\n  const isMultiDimensional = refsCollection.filter(ref => ref)[0].constructor === Array;\n  let nextIndex = index;\n  let nextInnerIndex = innerIndex;\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = kids.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (position === 'down') {\n    if (index === kids.length - 1) {\n      // loop back to beginning\n      nextIndex = 0;\n    } else {\n      nextIndex = index + 1;\n    }\n  } else if (position === 'left') {\n    if (innerIndex === 0) {\n      nextInnerIndex = refsCollection[index].length - 1;\n    } else {\n      nextInnerIndex = innerIndex - 1;\n    }\n  } else if (position === 'right') {\n    if (innerIndex === refsCollection[index].length - 1) {\n      nextInnerIndex = 0;\n    } else {\n      nextInnerIndex = innerIndex + 1;\n    }\n  }\n  if (\n    refsCollection[nextIndex] === null ||\n    refsCollection[nextIndex] === undefined ||\n    (isMultiDimensional &&\n      (refsCollection[nextIndex][nextInnerIndex] === null || refsCollection[nextIndex][nextInnerIndex] === undefined))\n  ) {\n    keyHandler(nextIndex, nextInnerIndex, position, refsCollection, kids, custom);\n  } else if (custom) {\n    if (refsCollection[nextIndex].focus) {\n      refsCollection[nextIndex].focus();\n    }\n    // eslint-disable-next-line react/no-find-dom-node\n    const element = ReactDOM.findDOMNode(refsCollection[nextIndex]) as HTMLElement;\n    element.focus();\n  } else if (position !== 'tab') {\n    if (isMultiDimensional) {\n      refsCollection[nextIndex][nextInnerIndex].focus();\n    } else {\n      refsCollection[nextIndex].focus();\n    }\n  }\n}\n\n/** This function returns a list of tabbable items in a container\n *\n *  @param {any} containerRef to the container\n *  @param {string} tababbleSelectors CSS selector string of tabbable items\n */\nexport function findTabbableElements(containerRef: any, tababbleSelectors: string): any[] {\n  const tabbable = containerRef.current.querySelectorAll(tababbleSelectors);\n  const list = Array.prototype.filter.call(tabbable, function(item) {\n    return item.tabIndex >= '0';\n  });\n  return list;\n}\n\n/** This function is a helper for keyboard navigation through dropdowns.\n *\n * @param {number} index The index of the element you're on\n * @param {string} position The orientation of the dropdown\n * @param {string[]} collection Array of refs to the items in the dropdown\n */\nexport function getNextIndex(index: number, position: string, collection: any[]): number {\n  let nextIndex;\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = collection.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (index === collection.length - 1) {\n    // loop back to beginning\n    nextIndex = 0;\n  } else {\n    nextIndex = index + 1;\n  }\n  if (collection[nextIndex] === undefined || collection[nextIndex][0] === null) {\n    return getNextIndex(nextIndex, position, collection);\n  } else {\n    return nextIndex;\n  }\n}\n\n/** This function is a helper for pluralizing strings.\n *\n * @param {number} i The quantity of the string you want to pluralize\n * @param {string} singular The singular version of the string\n * @param {string} plural The change to the string that should occur if the quantity is not equal to 1.\n *                 Defaults to adding an 's'.\n */\nexport function pluralize(i: number, singular: string, plural?: string) {\n  if (!plural) {\n    plural = `${singular}s`;\n  }\n  return `${i || 0} ${i === 1 ? singular : plural}`;\n}\n\n/**\n * This function is a helper for turning arrays of breakpointMod objects for flex and grid into style object\n *\n * @param {object} mods The modifiers object\n * @param {string} css-variable The appropriate css variable for the component\n */\nexport const setBreakpointCssVars = (\n  mods: {\n    default?: string;\n    sm?: string;\n    md?: string;\n    lg?: string;\n    xl?: string;\n    '2xl'?: string;\n    '3xl'?: string;\n  },\n  cssVar: string\n): React.CSSProperties =>\n  Object.entries(mods || {}).reduce(\n    (acc, [breakpoint, value]) =>\n      breakpoint === 'default' ? { ...acc, [cssVar]: value } : { ...acc, [`${cssVar}-on-${breakpoint}`]: value },\n    {}\n  );\n\nexport interface Mods {\n  default?: string;\n  sm?: string;\n  md?: string;\n  lg?: string;\n  xl?: string;\n  '2xl'?: string;\n  '3xl'?: string;\n}\n\n/**\n * This function is a helper for turning arrays of breakpointMod objects for data toolbar and flex into classes\n *\n * @param {object} mods The modifiers object\n * @param {any} styles The appropriate styles object for the component\n */\nexport const formatBreakpointMods = (\n  mods: Mods,\n  styles: any,\n  stylePrefix: string = '',\n  breakpoint?: 'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl'\n) => {\n  if (!mods) {\n    return '';\n  }\n  if (breakpoint) {\n    if (breakpoint in mods) {\n      return styles.modifiers[toCamel(`${stylePrefix}${mods[breakpoint as keyof Mods]}`)];\n    }\n    // the current breakpoint is not specified in mods, so we try to find the next nearest\n    const breakpointsOrder = ['2xl', 'xl', 'lg', 'md', 'sm', 'default'];\n    const breakpointsIndex = breakpointsOrder.indexOf(breakpoint);\n    for (let i = breakpointsIndex; i < breakpointsOrder.length; i++) {\n      if (breakpointsOrder[i] in mods) {\n        return styles.modifiers[toCamel(`${stylePrefix}${mods[breakpointsOrder[i] as keyof Mods]}`)];\n      }\n    }\n    return '';\n  }\n  return Object.entries(mods || {})\n    .map(([breakpoint, mod]) => `${stylePrefix}${mod}${breakpoint !== 'default' ? `-on-${breakpoint}` : ''}`)\n    .map(toCamel)\n    .map(mod => mod.replace(/-?(\\dxl)/gi, (_res, group) => `_${group}`))\n    .map(modifierKey => styles.modifiers[modifierKey])\n    .filter(Boolean)\n    .join(' ');\n};\n\n/**\n * Return the breakpoint for the given width\n *\n * @param {number | null} width The width to check\n * @returns {'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl'} The breakpoint\n */\nexport const getBreakpoint = (width: number): 'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl' => {\n  if (width === null) {\n    return null;\n  }\n  if (width >= 1450) {\n    return '2xl';\n  }\n  if (width >= 1200) {\n    return 'xl';\n  }\n  if (width >= 992) {\n    return 'lg';\n  }\n  if (width >= 768) {\n    return 'md';\n  }\n  if (width >= 576) {\n    return 'sm';\n  }\n  return 'default';\n};\n\nconst camelize = (s: string) =>\n  s\n    .toUpperCase()\n    .replace('-', '')\n    .replace('_', '');\n/**\n *\n * @param {string} s string to make camelCased\n */\nexport const toCamel = (s: string) => s.replace(/([-_][a-z])/gi, camelize);\n\n/**\n * Copied from exenv\n */\nexport const canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n/**\n * Calculate the width of the text\n * Example:\n * getTextWidth('my text', node)\n *\n * @param {string} text The text to calculate the width for\n * @param {HTMLElement} node The HTML element\n */\nexport const getTextWidth = (text: string, node: HTMLElement) => {\n  const computedStyle = getComputedStyle(node);\n  // Firefox returns the empty string for .font, so this function creates the .font property manually\n  const getFontFromComputedStyle = () => {\n    let computedFont = '';\n    // Firefox uses percentages for font-stretch, but Canvas does not accept percentages\n    // so convert to keywords, as listed at:\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/font-stretch\n    const fontStretchLookupTable = {\n      '50%': 'ultra-condensed',\n      '62.5%': 'extra-condensed',\n      '75%': 'condensed',\n      '87.5%': 'semi-condensed',\n      '100%': 'normal',\n      '112.5%': 'semi-expanded',\n      '125%': 'expanded',\n      '150%': 'extra-expanded',\n      '200%': 'ultra-expanded'\n    };\n    // If the retrieved font-stretch percentage isn't found in the lookup table, use\n    // 'normal' as a last resort.\n    let fontStretch;\n    if (computedStyle.fontStretch in fontStretchLookupTable) {\n      fontStretch = (fontStretchLookupTable as any)[computedStyle.fontStretch];\n    } else {\n      fontStretch = 'normal';\n    }\n    computedFont =\n      computedStyle.fontStyle +\n      ' ' +\n      computedStyle.fontVariant +\n      ' ' +\n      computedStyle.fontWeight +\n      ' ' +\n      fontStretch +\n      ' ' +\n      computedStyle.fontSize +\n      '/' +\n      computedStyle.lineHeight +\n      ' ' +\n      computedStyle.fontFamily;\n    return computedFont;\n  };\n\n  const canvas = document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  context.font = computedStyle.font || getFontFromComputedStyle();\n\n  return context.measureText(text).width;\n};\n\n/**\n * Get the inner dimensions of an element\n *\n * @param {HTMLElement} node HTML element to calculate the inner dimensions for\n */\nexport const innerDimensions = (node: HTMLElement) => {\n  const computedStyle = getComputedStyle(node);\n\n  let width = node.clientWidth; // width with padding\n  let height = node.clientHeight; // height with padding\n\n  height -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);\n  width -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  return { height, width };\n};\n\n/**\n * This function is a helper for truncating text content on the left, leaving the right side of the content in view\n *\n * @param {HTMLElement} node HTML element\n * @param {string} value The original text value\n */\nexport const trimLeft = (node: HTMLElement, value: string) => {\n  const availableWidth = innerDimensions(node).width;\n  let newValue = value;\n  if (getTextWidth(value, node) > availableWidth) {\n    // we have text overflow, trim the text to the left and add ... in the front until it fits\n    while (getTextWidth(`...${newValue}`, node) > availableWidth) {\n      newValue = newValue.substring(1);\n    }\n    // replace text with our truncated text\n    if ((node as HTMLInputElement).value) {\n      (node as HTMLInputElement).value = `...${newValue}`;\n    } else {\n      node.innerText = `...${newValue}`;\n    }\n  } else {\n    if ((node as HTMLInputElement).value) {\n      (node as HTMLInputElement).value = value;\n    } else {\n      node.innerText = value;\n    }\n  }\n};\n\n/**\n * @param {string[]} events - Operations to prevent when disabled\n */\nexport const preventedEvents = (events: string[]) =>\n  events.reduce(\n    (handlers, eventToPrevent) => ({\n      ...handlers,\n      [eventToPrevent]: (event: React.SyntheticEvent<HTMLElement>) => {\n        event.preventDefault();\n      }\n    }),\n    {}\n  );\n"]},"metadata":{},"sourceType":"module"}