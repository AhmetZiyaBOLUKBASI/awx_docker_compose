{"ast":null,"code":"import _slicedToArray from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nexport var amSuffix = ' AM';\nexport var pmSuffix = ' PM';\nexport var makeTimeOptions = function makeTimeOptions(stepMinutes, hour12, delimiter, minTime, maxTime, includeSeconds) {\n  var res = [];\n  var iter = new Date(new Date().setHours(0, 0, 0, 0));\n  var iterDay = iter.getDay();\n\n  while (iter.getDay() === iterDay) {\n    var hour = iter.getHours();\n    var suffix = amSuffix;\n\n    if (hour12) {\n      if (hour === 0) {\n        hour = 12; // 12am\n      } else if (hour >= 12) {\n        suffix = pmSuffix;\n      }\n\n      if (hour > 12) {\n        hour %= 12;\n      }\n    }\n\n    hour = hour12 ? hour.toString() : hour.toString().padStart(2, '0');\n    var minutes = iter.getMinutes().toString().padStart(2, '0');\n    var timeOption = \"\".concat(hour).concat(delimiter).concat(minutes).concat(hour12 ? suffix : ''); // time option is valid if within min/max constraints\n\n    if (isWithinMinMax(minTime, maxTime, timeOption, delimiter, includeSeconds)) {\n      res.push(timeOption);\n    }\n\n    iter.setMinutes(iter.getMinutes() + stepMinutes);\n  }\n\n  return res;\n};\nexport var parseTime = function parseTime(time, timeRegex, delimiter, is12Hour, includeSeconds) {\n  var date = new Date(time); // if default time is a ISO 8601 formatted date string, we parse it to hh:mm(am/pm) format\n\n  if (!isNaN(date.getDate()) && (time instanceof Date || time.includes('T'))) {\n    var hours = is12Hour ? \"\".concat(date.getHours() > 12 ? date.getHours() - 12 : date.getHours()) : \"\".concat(date.getHours()).padStart(2, '0');\n    var minutes = \"\".concat(date.getMinutes()).padStart(2, '0');\n    var seconds = includeSeconds ? \"\".concat(date.getSeconds()).padStart(2, '0') : '';\n    var secondsWithDelimiter = seconds ? \"\".concat(delimiter).concat(seconds) : '';\n    var ampm = '';\n\n    if (is12Hour && date.getHours() > 11) {\n      ampm = pmSuffix;\n    } else if (is12Hour) {\n      ampm = amSuffix;\n    }\n\n    return \"\".concat(hours).concat(delimiter).concat(minutes).concat(secondsWithDelimiter).concat(ampm);\n  } else if (typeof time === 'string') {\n    time = time.trim();\n\n    if (time !== '' && validateTime(time, timeRegex, delimiter, is12Hour)) {\n      var _timeRegex$exec = timeRegex.exec(time),\n          _timeRegex$exec2 = _slicedToArray(_timeRegex$exec, 5),\n          _hours = _timeRegex$exec2[1],\n          _minutes = _timeRegex$exec2[2],\n          _seconds = _timeRegex$exec2[3],\n          _timeRegex$exec2$ = _timeRegex$exec2[4],\n          suffix = _timeRegex$exec2$ === void 0 ? '' : _timeRegex$exec2$;\n\n      var _secondsWithDelimiter = includeSeconds ? \"\".concat(delimiter).concat(_seconds !== null && _seconds !== void 0 ? _seconds : '00') : '';\n\n      var _ampm = ''; // Format AM/PM according to design\n\n      if (is12Hour) {\n        var uppercaseSuffix = suffix.toUpperCase();\n\n        if (uppercaseSuffix === amSuffix.toUpperCase().trim()) {\n          _ampm = amSuffix;\n        } else if (uppercaseSuffix === pmSuffix.toUpperCase().trim()) {\n          _ampm = pmSuffix;\n        } else {\n          // if this 12 hour time is missing am/pm but otherwise valid,\n          // append am/pm depending on time of day\n          _ampm = new Date().getHours() > 11 ? pmSuffix : amSuffix;\n        }\n      }\n\n      return \"\".concat(_hours).concat(delimiter).concat(_minutes).concat(_secondsWithDelimiter).concat(_ampm);\n    }\n  }\n\n  return time.toString();\n};\nexport var validateTime = function validateTime(time, timeRegex, delimiter, is12Hour) {\n  // ISO 8601 format is valid\n  var date = new Date(time);\n\n  if (!isNaN(date.getDate()) && time.includes('T')) {\n    return true;\n  } // hours only valid if they are [0-23] or [1-12]\n\n\n  var hours = parseInt(time.split(delimiter)[0]);\n  var validHours = hours >= (is12Hour ? 1 : 0) && hours <= (is12Hour ? 12 : 23); // minutes verified by timeRegex\n  // empty string is valid\n\n  return time === '' || timeRegex.test(time) && validHours;\n};\nexport var getHours = function getHours(time, timeRegex) {\n  var parts = time.match(timeRegex);\n\n  if (parts && parts.length) {\n    if (/pm/i.test(parts[4])) {\n      return parseInt(parts[1]) === 12 ? parseInt(parts[1]) : parseInt(parts[1]) + 12;\n    }\n\n    if (/am/i.test(parts[4])) {\n      return parseInt(parts[1]) === 12 ? 0 : parseInt(parts[1]);\n    }\n\n    return parseInt(parts[1]);\n  }\n\n  return null;\n};\nexport var getMinutes = function getMinutes(time, timeRegex) {\n  var parts = time.match(timeRegex);\n  return parts && parts.length ? parseInt(parts[2]) : null;\n};\nexport var getSeconds = function getSeconds(time, timeRegex) {\n  var _a;\n\n  var seconds = (_a = time.match(timeRegex)) === null || _a === void 0 ? void 0 : _a[3];\n  return seconds ? parseInt(seconds) : null;\n};\nexport var isWithinMinMax = function isWithinMinMax(minTime, maxTime, time, delimiter, includeSeconds) {\n  // do not throw error if empty string\n  if (time.trim() === '') {\n    return true;\n  } // correctly format as 24hr times (12:30AM => 00:30, 1:15 => 01:15)\n\n\n  var min24HourTime = convertTo24Hour(minTime, delimiter, includeSeconds);\n  var selected24HourTime = convertTo24Hour(time, delimiter, includeSeconds);\n  var max24HourTime = convertTo24Hour(maxTime, delimiter, includeSeconds); // simple string comparison for 24hr times\n\n  return min24HourTime <= selected24HourTime && selected24HourTime <= max24HourTime;\n};\n\nvar convertTo24Hour = function convertTo24Hour(time, delimiter, includeSeconds) {\n  var timeReg = new RegExp(\"^\\\\s*(\\\\d\\\\d?)\".concat(delimiter, \"([0-5]\\\\d)\").concat(delimiter, \"?([0-5]\\\\d)?\\\\s*([AaPp][Mm])?\\\\s*$\"));\n  var regMatches = timeReg.exec(time);\n\n  if (!regMatches || !regMatches.length) {\n    return;\n  }\n\n  var hours = regMatches[1].padStart(2, '0');\n  var minutes = regMatches[2];\n  var seconds = regMatches[3] ? \"\".concat(delimiter).concat(regMatches[3]) : ''; // When seconds is empty and 'includeSeconds' is enabled, append 0 seconds.\n\n  if (!seconds && includeSeconds) {\n    seconds = \"\".concat(delimiter, \"00\");\n  }\n\n  var suffix = regMatches[4] || '';\n\n  if (suffix.toUpperCase() === 'PM' && hours !== '12') {\n    hours = \"\".concat(parseInt(hours) + 12);\n  } else if (suffix.toUpperCase() === 'AM' && hours === '12') {\n    hours = '00';\n  }\n\n  return \"\".concat(hours).concat(delimiter).concat(minutes).concat(seconds);\n};","map":{"version":3,"sources":["/awx_devel/awx/ui/node_modules/@patternfly/react-core/src/components/TimePicker/TimePickerUtils.tsx"],"names":[],"mappings":"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","sourcesContent":["export const amSuffix = ' AM';\nexport const pmSuffix = ' PM';\n\nexport const makeTimeOptions = (\n  stepMinutes: number,\n  hour12: boolean,\n  delimiter: string,\n  minTime: string,\n  maxTime: string,\n  includeSeconds: boolean\n) => {\n  const res = [];\n  const iter = new Date(new Date().setHours(0, 0, 0, 0));\n  const iterDay = iter.getDay();\n  while (iter.getDay() === iterDay) {\n    let hour: string | number = iter.getHours();\n    let suffix = amSuffix;\n    if (hour12) {\n      if (hour === 0) {\n        hour = 12; // 12am\n      } else if (hour >= 12) {\n        suffix = pmSuffix;\n      }\n      if (hour > 12) {\n        hour %= 12;\n      }\n    }\n    hour = hour12 ? hour.toString() : hour.toString().padStart(2, '0');\n    const minutes = iter\n      .getMinutes()\n      .toString()\n      .padStart(2, '0');\n    const timeOption = `${hour}${delimiter}${minutes}${hour12 ? suffix : ''}`;\n    // time option is valid if within min/max constraints\n    if (isWithinMinMax(minTime, maxTime, timeOption, delimiter, includeSeconds)) {\n      res.push(timeOption);\n    }\n    iter.setMinutes(iter.getMinutes() + stepMinutes);\n  }\n  return res;\n};\n\nexport const parseTime = (\n  time: string | Date,\n  timeRegex: RegExp,\n  delimiter: string,\n  is12Hour: boolean,\n  includeSeconds: boolean\n): string => {\n  const date = new Date(time);\n\n  // if default time is a ISO 8601 formatted date string, we parse it to hh:mm(am/pm) format\n  if (!isNaN(date.getDate()) && (time instanceof Date || time.includes('T'))) {\n    const hours = is12Hour\n      ? `${date.getHours() > 12 ? date.getHours() - 12 : date.getHours()}`\n      : `${date.getHours()}`.padStart(2, '0');\n    const minutes = `${date.getMinutes()}`.padStart(2, '0');\n    const seconds = includeSeconds ? `${date.getSeconds()}`.padStart(2, '0') : '';\n    const secondsWithDelimiter = seconds ? `${delimiter}${seconds}` : '';\n    let ampm = '';\n\n    if (is12Hour && date.getHours() > 11) {\n      ampm = pmSuffix;\n    } else if (is12Hour) {\n      ampm = amSuffix;\n    }\n\n    return `${hours}${delimiter}${minutes}${secondsWithDelimiter}${ampm}`;\n  } else if (typeof time === 'string') {\n    time = time.trim();\n    if (time !== '' && validateTime(time, timeRegex, delimiter, is12Hour)) {\n      const [, hours, minutes, seconds, suffix = ''] = timeRegex.exec(time);\n      const secondsWithDelimiter = includeSeconds ? `${delimiter}${seconds ?? '00'}` : '';\n      let ampm = '';\n\n      // Format AM/PM according to design\n      if (is12Hour) {\n        const uppercaseSuffix = suffix.toUpperCase();\n\n        if (uppercaseSuffix === amSuffix.toUpperCase().trim()) {\n          ampm = amSuffix;\n        } else if (uppercaseSuffix === pmSuffix.toUpperCase().trim()) {\n          ampm = pmSuffix;\n        } else {\n          // if this 12 hour time is missing am/pm but otherwise valid,\n          // append am/pm depending on time of day\n          ampm = new Date().getHours() > 11 ? pmSuffix : amSuffix;\n        }\n      }\n\n      return `${hours}${delimiter}${minutes}${secondsWithDelimiter}${ampm}`;\n    }\n  }\n  return time.toString();\n};\n\nexport const validateTime = (time: string, timeRegex: RegExp, delimiter: string, is12Hour: boolean) => {\n  // ISO 8601 format is valid\n  const date = new Date(time);\n  if (!isNaN(date.getDate()) && time.includes('T')) {\n    return true;\n  }\n  // hours only valid if they are [0-23] or [1-12]\n  const hours = parseInt(time.split(delimiter)[0]);\n  const validHours = hours >= (is12Hour ? 1 : 0) && hours <= (is12Hour ? 12 : 23);\n  // minutes verified by timeRegex\n\n  // empty string is valid\n  return time === '' || (timeRegex.test(time) && validHours);\n};\n\nexport const getHours = (time: string, timeRegex: RegExp) => {\n  const parts = time.match(timeRegex);\n  if (parts && parts.length) {\n    if (/pm/i.test(parts[4])) {\n      return parseInt(parts[1]) === 12 ? parseInt(parts[1]) : parseInt(parts[1]) + 12;\n    }\n    if (/am/i.test(parts[4])) {\n      return parseInt(parts[1]) === 12 ? 0 : parseInt(parts[1]);\n    }\n    return parseInt(parts[1]);\n  }\n  return null;\n};\n\nexport const getMinutes = (time: string, timeRegex: RegExp) => {\n  const parts = time.match(timeRegex);\n  return parts && parts.length ? parseInt(parts[2]) : null;\n};\n\nexport const getSeconds = (time: string, timeRegex: RegExp) => {\n  const seconds = time.match(timeRegex)?.[3];\n\n  return seconds ? parseInt(seconds) : null;\n};\n\nexport const isWithinMinMax = (\n  minTime: string,\n  maxTime: string,\n  time: string,\n  delimiter: string,\n  includeSeconds?: boolean\n) => {\n  // do not throw error if empty string\n  if (time.trim() === '') {\n    return true;\n  }\n\n  // correctly format as 24hr times (12:30AM => 00:30, 1:15 => 01:15)\n  const min24HourTime = convertTo24Hour(minTime, delimiter, includeSeconds);\n  const selected24HourTime = convertTo24Hour(time, delimiter, includeSeconds);\n  const max24HourTime = convertTo24Hour(maxTime, delimiter, includeSeconds);\n\n  // simple string comparison for 24hr times\n  return min24HourTime <= selected24HourTime && selected24HourTime <= max24HourTime;\n};\n\nconst convertTo24Hour = (time: string, delimiter: string, includeSeconds: boolean): string => {\n  const timeReg = new RegExp(`^\\\\s*(\\\\d\\\\d?)${delimiter}([0-5]\\\\d)${delimiter}?([0-5]\\\\d)?\\\\s*([AaPp][Mm])?\\\\s*$`);\n  const regMatches = timeReg.exec(time);\n  if (!regMatches || !regMatches.length) {\n    return;\n  }\n  let hours = regMatches[1].padStart(2, '0');\n  const minutes = regMatches[2];\n  let seconds = regMatches[3] ? `${delimiter}${regMatches[3]}` : '';\n\n  // When seconds is empty and 'includeSeconds' is enabled, append 0 seconds.\n  if (!seconds && includeSeconds) {\n    seconds = `${delimiter}00`;\n  }\n\n  const suffix = regMatches[4] || '';\n  if (suffix.toUpperCase() === 'PM' && hours !== '12') {\n    hours = `${parseInt(hours) + 12}`;\n  } else if (suffix.toUpperCase() === 'AM' && hours === '12') {\n    hours = '00';\n  }\n\n  return `${hours}${delimiter}${minutes}${seconds}`;\n};\n"]},"metadata":{},"sourceType":"module"}