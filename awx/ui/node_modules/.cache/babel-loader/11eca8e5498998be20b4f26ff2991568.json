{"ast":null,"code":"// @ts-nocheck\nimport { top, left, right, bottom, start } from '../enums';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport getAltAxis from '../utils/getAltAxis';\nimport within from '../utils/within';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport detectOverflow from '../utils/detectOverflow';\nimport getVariation from '../utils/getVariation';\nimport getFreshSideObject from '../utils/getFreshSideObject';\n/**\n *\n */\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign(Object.assign({}, state.rects), {\n    placement: state.placement\n  })) : tetherOffset;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var mainSide = mainAxis === 'y' ? top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = popperOffsets[mainAxis] + overflow[mainSide];\n    var max = popperOffsets[mainAxis] - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _mainSide = mainAxis === 'x' ? top : left;\n\n    var _altSide = mainAxis === 'x' ? bottom : right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var _preventedOffset = within(_min, _offset, _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n}\n\nexport default {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n};","map":{"version":3,"sources":["/awx_devel/awx/ui/node_modules/@patternfly/react-core/src/helpers/Popper/thirdparty/popper-core/modifiers/preventOverflow.ts"],"names":[],"mappings":"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","sourcesContent":["// @ts-nocheck\nimport { top, left, right, bottom, start } from '../enums';\nimport { Placement, Boundary, RootBoundary } from '../enums';\nimport { Rect, ModifierArguments, Modifier, Padding } from '../types';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport getAltAxis from '../utils/getAltAxis';\nimport within from '../utils/within';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport detectOverflow from '../utils/detectOverflow';\nimport getVariation from '../utils/getVariation';\nimport getFreshSideObject from '../utils/getFreshSideObject';\n\ntype TetherOffset = (arg0: { popper: Rect; reference: Rect; placement: Placement }) => number | number;\n\n// eslint-disable-next-line import/no-unused-modules\nexport interface Options {\n  /* Prevents boundaries overflow on the main axis */\n  mainAxis: boolean;\n\n  /* Prevents boundaries overflow on the alternate axis */\n  altAxis: boolean;\n\n  /* The area to check the popper is overflowing in */\n  boundary: Boundary;\n\n  /* If the popper is not overflowing the main area, fallback to this one */\n  rootBoundary: RootBoundary;\n\n  /* Use the reference's \"clippingParents\" boundary context */\n  altBoundary: boolean;\n\n  /**\n   * Allows the popper to overflow from its boundaries to keep it near its\n   * reference element\n   */\n  tether: boolean;\n\n  /* Offsets when the `tether` option should activate */\n  tetherOffset: TetherOffset;\n\n  /* Sets a padding to the provided boundary */\n  padding: Padding;\n}\n\n/**\n *\n */\nfunction preventOverflow({ state, options, name }: ModifierArguments<Options>) {\n  const {\n    mainAxis: checkMainAxis = true,\n    altAxis: checkAltAxis = false,\n    boundary,\n    rootBoundary,\n    altBoundary,\n    padding,\n    tether = true,\n    tetherOffset = 0\n  } = options;\n\n  const overflow = detectOverflow(state, {\n    boundary,\n    rootBoundary,\n    padding,\n    altBoundary\n  });\n  const basePlacement = getBasePlacement(state.placement);\n  const variation = getVariation(state.placement);\n  const isBasePlacement = !variation;\n  const mainAxis = getMainAxisFromPlacement(basePlacement);\n  const altAxis = getAltAxis(mainAxis);\n  const popperOffsets = state.modifiersData.popperOffsets;\n  const referenceRect = state.rects.reference;\n  const popperRect = state.rects.popper;\n  const tetherOffsetValue =\n    typeof tetherOffset === 'function'\n      ? tetherOffset({\n          ...state.rects,\n          placement: state.placement\n        })\n      : tetherOffset;\n\n  const data = { x: 0, y: 0 };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    const mainSide = mainAxis === 'y' ? top : left;\n    const altSide = mainAxis === 'y' ? bottom : right;\n    const len = mainAxis === 'y' ? 'height' : 'width';\n    const offset = popperOffsets[mainAxis];\n\n    const min = popperOffsets[mainAxis] + overflow[mainSide];\n    const max = popperOffsets[mainAxis] - overflow[altSide];\n\n    const additive = tether ? -popperRect[len] / 2 : 0;\n\n    const minLen = variation === start ? referenceRect[len] : popperRect[len];\n    const maxLen = variation === start ? -popperRect[len] : -referenceRect[len];\n\n    // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n    const arrowElement = state.elements.arrow;\n    const arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : { width: 0, height: 0 };\n    const arrowPaddingObject = state.modifiersData['arrow#persistent']\n      ? state.modifiersData['arrow#persistent'].padding\n      : getFreshSideObject();\n    const arrowPaddingMin = arrowPaddingObject[mainSide];\n    const arrowPaddingMax = arrowPaddingObject[altSide];\n\n    // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n    const arrowLen = within(0, referenceRect[len], arrowRect[len]);\n\n    const minOffset = isBasePlacement\n      ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue\n      : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n    const maxOffset = isBasePlacement\n      ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue\n      : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n\n    const arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    const clientOffset = arrowOffsetParent\n      ? mainAxis === 'y'\n        ? arrowOffsetParent.clientTop || 0\n        : arrowOffsetParent.clientLeft || 0\n      : 0;\n\n    const offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n\n    const tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n    const tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n\n    const preventedOffset = within(\n      tether ? Math.min(min, tetherMin) : min,\n      offset,\n      tether ? Math.max(max, tetherMax) : max\n    );\n\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    const mainSide = mainAxis === 'x' ? top : left;\n    const altSide = mainAxis === 'x' ? bottom : right;\n    const offset = popperOffsets[altAxis];\n\n    const min = offset + overflow[mainSide];\n    const max = offset - overflow[altSide];\n\n    const preventedOffset = within(min, offset, max);\n\n    popperOffsets[altAxis] = preventedOffset;\n    data[altAxis] = preventedOffset - offset;\n  }\n\n  state.modifiersData[name] = data;\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport type PreventOverflowModifier = Modifier<'preventOverflow', Options>;\nexport default {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n} as PreventOverflowModifier;\n"]},"metadata":{},"sourceType":"module"}