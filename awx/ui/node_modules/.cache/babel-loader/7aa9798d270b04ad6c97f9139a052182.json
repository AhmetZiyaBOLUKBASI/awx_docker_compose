{"ast":null,"code":"import _slicedToArray from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _objectSpread from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { InvalidArgumentError, InvalidDurationError, InvalidUnitError } from \"./errors.js\";\nimport Formatter from \"./impl/formatter.js\";\nimport Invalid from \"./impl/invalid.js\";\nimport Locale from \"./impl/locale.js\";\nimport { parseISODuration, parseISOTimeOnly } from \"./impl/regexParser.js\";\nimport { asNumber, hasOwnProperty, isNumber, isUndefined, normalizeObject, roundTo } from \"./impl/util.js\";\nimport Settings from \"./settings.js\";\nvar INVALID = \"Invalid Duration\"; // unit conversion constants\n\nexport var lowOrderMatrix = {\n  weeks: {\n    days: 7,\n    hours: 7 * 24,\n    minutes: 7 * 24 * 60,\n    seconds: 7 * 24 * 60 * 60,\n    milliseconds: 7 * 24 * 60 * 60 * 1000\n  },\n  days: {\n    hours: 24,\n    minutes: 24 * 60,\n    seconds: 24 * 60 * 60,\n    milliseconds: 24 * 60 * 60 * 1000\n  },\n  hours: {\n    minutes: 60,\n    seconds: 60 * 60,\n    milliseconds: 60 * 60 * 1000\n  },\n  minutes: {\n    seconds: 60,\n    milliseconds: 60 * 1000\n  },\n  seconds: {\n    milliseconds: 1000\n  }\n},\n    casualMatrix = _objectSpread({\n  years: {\n    quarters: 4,\n    months: 12,\n    weeks: 52,\n    days: 365,\n    hours: 365 * 24,\n    minutes: 365 * 24 * 60,\n    seconds: 365 * 24 * 60 * 60,\n    milliseconds: 365 * 24 * 60 * 60 * 1000\n  },\n  quarters: {\n    months: 3,\n    weeks: 13,\n    days: 91,\n    hours: 91 * 24,\n    minutes: 91 * 24 * 60,\n    seconds: 91 * 24 * 60 * 60,\n    milliseconds: 91 * 24 * 60 * 60 * 1000\n  },\n  months: {\n    weeks: 4,\n    days: 30,\n    hours: 30 * 24,\n    minutes: 30 * 24 * 60,\n    seconds: 30 * 24 * 60 * 60,\n    milliseconds: 30 * 24 * 60 * 60 * 1000\n  }\n}, lowOrderMatrix),\n    daysInYearAccurate = 146097.0 / 400,\n    daysInMonthAccurate = 146097.0 / 4800,\n    accurateMatrix = _objectSpread({\n  years: {\n    quarters: 4,\n    months: 12,\n    weeks: daysInYearAccurate / 7,\n    days: daysInYearAccurate,\n    hours: daysInYearAccurate * 24,\n    minutes: daysInYearAccurate * 24 * 60,\n    seconds: daysInYearAccurate * 24 * 60 * 60,\n    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000\n  },\n  quarters: {\n    months: 3,\n    weeks: daysInYearAccurate / 28,\n    days: daysInYearAccurate / 4,\n    hours: daysInYearAccurate * 24 / 4,\n    minutes: daysInYearAccurate * 24 * 60 / 4,\n    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,\n    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000 / 4\n  },\n  months: {\n    weeks: daysInMonthAccurate / 7,\n    days: daysInMonthAccurate,\n    hours: daysInMonthAccurate * 24,\n    minutes: daysInMonthAccurate * 24 * 60,\n    seconds: daysInMonthAccurate * 24 * 60 * 60,\n    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000\n  }\n}, lowOrderMatrix); // units ordered by size\n\nvar orderedUnits = [\"years\", \"quarters\", \"months\", \"weeks\", \"days\", \"hours\", \"minutes\", \"seconds\", \"milliseconds\"];\nvar reverseUnits = orderedUnits.slice(0).reverse(); // clone really means \"create another instance just like this one, but with these changes\"\n\nfunction clone(dur, alts) {\n  var clear = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // deep merge for vals\n  var conf = {\n    values: clear ? alts.values : _objectSpread(_objectSpread({}, dur.values), alts.values || {}),\n    loc: dur.loc.clone(alts.loc),\n    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy\n  };\n  return new Duration(conf);\n}\n\nfunction antiTrunc(n) {\n  return n < 0 ? Math.floor(n) : Math.ceil(n);\n} // NB: mutates parameters\n\n\nfunction convert(matrix, fromMap, fromUnit, toMap, toUnit) {\n  var conv = matrix[toUnit][fromUnit],\n      raw = fromMap[fromUnit] / conv,\n      sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]),\n      // ok, so this is wild, but see the matrix in the tests\n  added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);\n  toMap[toUnit] += added;\n  fromMap[fromUnit] -= added * conv;\n} // NB: mutates parameters\n\n\nfunction normalizeValues(matrix, vals) {\n  reverseUnits.reduce(function (previous, current) {\n    if (!isUndefined(vals[current])) {\n      if (previous) {\n        convert(matrix, vals, previous, vals, current);\n      }\n\n      return current;\n    } else {\n      return previous;\n    }\n  }, null);\n}\n/**\n * A Duration object represents a period of time, like \"2 months\" or \"1 day, 1 hour\". Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them. They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime#plus} to add a Duration object to a DateTime, producing another DateTime.\n *\n * Here is a brief overview of commonly used methods and getters in Duration:\n *\n * * **Creation** To create a Duration, use {@link Duration#fromMillis}, {@link Duration#fromObject}, or {@link Duration#fromISO}.\n * * **Unit values** See the {@link Duration#years}, {@link Duration#months}, {@link Duration#weeks}, {@link Duration#days}, {@link Duration#hours}, {@link Duration#minutes}, {@link Duration#seconds}, {@link Duration#milliseconds} accessors.\n * * **Configuration** See  {@link Duration#locale} and {@link Duration#numberingSystem} accessors.\n * * **Transformation** To create new Durations out of old ones use {@link Duration#plus}, {@link Duration#minus}, {@link Duration#normalize}, {@link Duration#set}, {@link Duration#reconfigure}, {@link Duration#shiftTo}, and {@link Duration#negate}.\n * * **Output** To convert the Duration into other representations, see {@link Duration#as}, {@link Duration#toISO}, {@link Duration#toFormat}, and {@link Duration#toJSON}\n *\n * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.\n */\n\n\nvar Duration = /*#__PURE__*/function () {\n  /**\n   * @private\n   */\n  function Duration(config) {\n    _classCallCheck(this, Duration);\n\n    var accurate = config.conversionAccuracy === \"longterm\" || false;\n    /**\n     * @access private\n     */\n\n    this.values = config.values;\n    /**\n     * @access private\n     */\n\n    this.loc = config.loc || Locale.create();\n    /**\n     * @access private\n     */\n\n    this.conversionAccuracy = accurate ? \"longterm\" : \"casual\";\n    /**\n     * @access private\n     */\n\n    this.invalid = config.invalid || null;\n    /**\n     * @access private\n     */\n\n    this.matrix = accurate ? accurateMatrix : casualMatrix;\n    /**\n     * @access private\n     */\n\n    this.isLuxonDuration = true;\n  }\n  /**\n   * Create Duration from a number of milliseconds.\n   * @param {number} count of milliseconds\n   * @param {Object} opts - options for parsing\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @return {Duration}\n   */\n\n\n  _createClass(Duration, [{\n    key: \"locale\",\n    get:\n    /**\n     * Get  the locale of a Duration, such 'en-GB'\n     * @type {string}\n     */\n    function get() {\n      return this.isValid ? this.loc.locale : null;\n    }\n    /**\n     * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration\n     *\n     * @type {string}\n     */\n\n  }, {\n    key: \"numberingSystem\",\n    get: function get() {\n      return this.isValid ? this.loc.numberingSystem : null;\n    }\n    /**\n     * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:\n     * * `S` for milliseconds\n     * * `s` for seconds\n     * * `m` for minutes\n     * * `h` for hours\n     * * `d` for days\n     * * `w` for weeks\n     * * `M` for months\n     * * `y` for years\n     * Notes:\n     * * Add padding by repeating the token, e.g. \"yy\" pads the years to two digits, \"hhhh\" pads the hours out to four digits\n     * * Tokens can be escaped by wrapping with single quotes.\n     * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.\n     * @param {string} fmt - the format string\n     * @param {Object} opts - options\n     * @param {boolean} [opts.floor=true] - floor numerical values\n     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"y d s\") //=> \"1 6 2\"\n     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"yy dd sss\") //=> \"01 06 002\"\n     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"M S\") //=> \"12 518402000\"\n     * @return {string}\n     */\n\n  }, {\n    key: \"toFormat\",\n    value: function toFormat(fmt) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      // reverse-compat since 1.2; we always round down now, never up, and we do it by default\n      var fmtOpts = _objectSpread(_objectSpread({}, opts), {}, {\n        floor: opts.round !== false && opts.floor !== false\n      });\n\n      return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;\n    }\n    /**\n     * Returns a string representation of a Duration with all units included.\n     * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat\n     * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.\n     * @example\n     * ```js\n     * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })\n     * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'\n     * dur.toHuman({ listStyle: \"long\" }) //=> '1 day, 5 hours, and 6 minutes'\n     * dur.toHuman({ unitDisplay: \"short\" }) //=> '1 day, 5 hr, 6 min'\n     * ```\n     */\n\n  }, {\n    key: \"toHuman\",\n    value: function toHuman() {\n      var _this = this;\n\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var l = orderedUnits.map(function (unit) {\n        var val = _this.values[unit];\n\n        if (isUndefined(val)) {\n          return null;\n        }\n\n        return _this.loc.numberFormatter(_objectSpread(_objectSpread({\n          style: \"unit\",\n          unitDisplay: \"long\"\n        }, opts), {}, {\n          unit: unit.slice(0, -1)\n        })).format(val);\n      }).filter(function (n) {\n        return n;\n      });\n      return this.loc.listFormatter(_objectSpread({\n        type: \"conjunction\",\n        style: opts.listStyle || \"narrow\"\n      }, opts)).format(l);\n    }\n    /**\n     * Returns a JavaScript object with this Duration's values.\n     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }\n     * @return {Object}\n     */\n\n  }, {\n    key: \"toObject\",\n    value: function toObject() {\n      if (!this.isValid) return {};\n      return _objectSpread({}, this.values);\n    }\n    /**\n     * Returns an ISO 8601-compliant string representation of this Duration.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n     * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'\n     * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'\n     * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'\n     * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'\n     * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'\n     * @return {string}\n     */\n\n  }, {\n    key: \"toISO\",\n    value: function toISO() {\n      // we could use the formatter, but this is an easier way to get the minimum string\n      if (!this.isValid) return null;\n      var s = \"P\";\n      if (this.years !== 0) s += this.years + \"Y\";\n      if (this.months !== 0 || this.quarters !== 0) s += this.months + this.quarters * 3 + \"M\";\n      if (this.weeks !== 0) s += this.weeks + \"W\";\n      if (this.days !== 0) s += this.days + \"D\";\n      if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) s += \"T\";\n      if (this.hours !== 0) s += this.hours + \"H\";\n      if (this.minutes !== 0) s += this.minutes + \"M\";\n      if (this.seconds !== 0 || this.milliseconds !== 0) // this will handle \"floating point madness\" by removing extra decimal places\n        // https://stackoverflow.com/questions/588004/is-floating-point-math-broken\n        s += roundTo(this.seconds + this.milliseconds / 1000, 3) + \"S\";\n      if (s === \"P\") s += \"T0S\";\n      return s;\n    }\n    /**\n     * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.\n     * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Times\n     * @param {Object} opts - options\n     * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0\n     * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0\n     * @param {boolean} [opts.includePrefix=false] - include the `T` prefix\n     * @param {string} [opts.format='extended'] - choose between the basic and extended format\n     * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'\n     * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'\n     * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'\n     * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'\n     * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'\n     * @return {string}\n     */\n\n  }, {\n    key: \"toISOTime\",\n    value: function toISOTime() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (!this.isValid) return null;\n      var millis = this.toMillis();\n      if (millis < 0 || millis >= 86400000) return null;\n      opts = _objectSpread({\n        suppressMilliseconds: false,\n        suppressSeconds: false,\n        includePrefix: false,\n        format: \"extended\"\n      }, opts);\n      var value = this.shiftTo(\"hours\", \"minutes\", \"seconds\", \"milliseconds\");\n      var fmt = opts.format === \"basic\" ? \"hhmm\" : \"hh:mm\";\n\n      if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {\n        fmt += opts.format === \"basic\" ? \"ss\" : \":ss\";\n\n        if (!opts.suppressMilliseconds || value.milliseconds !== 0) {\n          fmt += \".SSS\";\n        }\n      }\n\n      var str = value.toFormat(fmt);\n\n      if (opts.includePrefix) {\n        str = \"T\" + str;\n      }\n\n      return str;\n    }\n    /**\n     * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.\n     * @return {string}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.toISO();\n    }\n    /**\n     * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.\n     * @return {string}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.toISO();\n    }\n    /**\n     * Returns an milliseconds value of this Duration.\n     * @return {number}\n     */\n\n  }, {\n    key: \"toMillis\",\n    value: function toMillis() {\n      return this.as(\"milliseconds\");\n    }\n    /**\n     * Returns an milliseconds value of this Duration. Alias of {@link toMillis}\n     * @return {number}\n     */\n\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.toMillis();\n    }\n    /**\n     * Make this Duration longer by the specified amount. Return a newly-constructed Duration.\n     * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n     * @return {Duration}\n     */\n\n  }, {\n    key: \"plus\",\n    value: function plus(duration) {\n      if (!this.isValid) return this;\n      var dur = Duration.fromDurationLike(duration),\n          result = {};\n\n      var _iterator = _createForOfIteratorHelper(orderedUnits),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var k = _step.value;\n\n          if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {\n            result[k] = dur.get(k) + this.get(k);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return clone(this, {\n        values: result\n      }, true);\n    }\n    /**\n     * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.\n     * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n     * @return {Duration}\n     */\n\n  }, {\n    key: \"minus\",\n    value: function minus(duration) {\n      if (!this.isValid) return this;\n      var dur = Duration.fromDurationLike(duration);\n      return this.plus(dur.negate());\n    }\n    /**\n     * Scale this Duration by the specified amount. Return a newly-constructed Duration.\n     * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.\n     * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }\n     * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === \"hour\" ? x * 2 : x) //=> { hours: 2, minutes: 30 }\n     * @return {Duration}\n     */\n\n  }, {\n    key: \"mapUnits\",\n    value: function mapUnits(fn) {\n      if (!this.isValid) return this;\n      var result = {};\n\n      for (var _i = 0, _Object$keys = Object.keys(this.values); _i < _Object$keys.length; _i++) {\n        var k = _Object$keys[_i];\n        result[k] = asNumber(fn(this.values[k], k));\n      }\n\n      return clone(this, {\n        values: result\n      }, true);\n    }\n    /**\n     * Get the value of unit.\n     * @param {string} unit - a unit such as 'minute' or 'day'\n     * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2\n     * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0\n     * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3\n     * @return {number}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(unit) {\n      return this[Duration.normalizeUnit(unit)];\n    }\n    /**\n     * \"Set\" the values of specified units. Return a newly-constructed Duration.\n     * @param {Object} values - a mapping of units to numbers\n     * @example dur.set({ years: 2017 })\n     * @example dur.set({ hours: 8, minutes: 30 })\n     * @return {Duration}\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(values) {\n      if (!this.isValid) return this;\n\n      var mixed = _objectSpread(_objectSpread({}, this.values), normalizeObject(values, Duration.normalizeUnit));\n\n      return clone(this, {\n        values: mixed\n      });\n    }\n    /**\n     * \"Set\" the locale and/or numberingSystem.  Returns a newly-constructed Duration.\n     * @example dur.reconfigure({ locale: 'en-GB' })\n     * @return {Duration}\n     */\n\n  }, {\n    key: \"reconfigure\",\n    value: function reconfigure() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          locale = _ref.locale,\n          numberingSystem = _ref.numberingSystem,\n          conversionAccuracy = _ref.conversionAccuracy;\n\n      var loc = this.loc.clone({\n        locale: locale,\n        numberingSystem: numberingSystem\n      }),\n          opts = {\n        loc: loc\n      };\n\n      if (conversionAccuracy) {\n        opts.conversionAccuracy = conversionAccuracy;\n      }\n\n      return clone(this, opts);\n    }\n    /**\n     * Return the length of the duration in the specified unit.\n     * @param {string} unit - a unit such as 'minutes' or 'days'\n     * @example Duration.fromObject({years: 1}).as('days') //=> 365\n     * @example Duration.fromObject({years: 1}).as('months') //=> 12\n     * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5\n     * @return {number}\n     */\n\n  }, {\n    key: \"as\",\n    value: function as(unit) {\n      return this.isValid ? this.shiftTo(unit).get(unit) : NaN;\n    }\n    /**\n     * Reduce this Duration to its canonical representation in its current units.\n     * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }\n     * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }\n     * @return {Duration}\n     */\n\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      if (!this.isValid) return this;\n      var vals = this.toObject();\n      normalizeValues(this.matrix, vals);\n      return clone(this, {\n        values: vals\n      }, true);\n    }\n    /**\n     * Convert this Duration into its representation in a different set of units.\n     * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }\n     * @return {Duration}\n     */\n\n  }, {\n    key: \"shiftTo\",\n    value: function shiftTo() {\n      for (var _len = arguments.length, units = new Array(_len), _key = 0; _key < _len; _key++) {\n        units[_key] = arguments[_key];\n      }\n\n      if (!this.isValid) return this;\n\n      if (units.length === 0) {\n        return this;\n      }\n\n      units = units.map(function (u) {\n        return Duration.normalizeUnit(u);\n      });\n      var built = {},\n          accumulated = {},\n          vals = this.toObject();\n      var lastUnit;\n\n      var _iterator2 = _createForOfIteratorHelper(orderedUnits),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var k = _step2.value;\n\n          if (units.indexOf(k) >= 0) {\n            lastUnit = k;\n            var own = 0; // anything we haven't boiled down yet should get boiled to this unit\n\n            for (var ak in accumulated) {\n              own += this.matrix[ak][k] * accumulated[ak];\n              accumulated[ak] = 0;\n            } // plus anything that's already in this unit\n\n\n            if (isNumber(vals[k])) {\n              own += vals[k];\n            }\n\n            var i = Math.trunc(own);\n            built[k] = i;\n            accumulated[k] = (own * 1000 - i * 1000) / 1000; // plus anything further down the chain that should be rolled up in to this\n\n            for (var down in vals) {\n              if (orderedUnits.indexOf(down) > orderedUnits.indexOf(k)) {\n                convert(this.matrix, vals, down, built, k);\n              }\n            } // otherwise, keep it in the wings to boil it later\n\n          } else if (isNumber(vals[k])) {\n            accumulated[k] = vals[k];\n          }\n        } // anything leftover becomes the decimal for the last unit\n        // lastUnit must be defined since units is not empty\n\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      for (var key in accumulated) {\n        if (accumulated[key] !== 0) {\n          built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];\n        }\n      }\n\n      return clone(this, {\n        values: built\n      }, true).normalize();\n    }\n    /**\n     * Return the negative of this Duration.\n     * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }\n     * @return {Duration}\n     */\n\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      if (!this.isValid) return this;\n      var negated = {};\n\n      for (var _i2 = 0, _Object$keys2 = Object.keys(this.values); _i2 < _Object$keys2.length; _i2++) {\n        var k = _Object$keys2[_i2];\n        negated[k] = this.values[k] === 0 ? 0 : -this.values[k];\n      }\n\n      return clone(this, {\n        values: negated\n      }, true);\n    }\n    /**\n     * Get the years.\n     * @type {number}\n     */\n\n  }, {\n    key: \"years\",\n    get: function get() {\n      return this.isValid ? this.values.years || 0 : NaN;\n    }\n    /**\n     * Get the quarters.\n     * @type {number}\n     */\n\n  }, {\n    key: \"quarters\",\n    get: function get() {\n      return this.isValid ? this.values.quarters || 0 : NaN;\n    }\n    /**\n     * Get the months.\n     * @type {number}\n     */\n\n  }, {\n    key: \"months\",\n    get: function get() {\n      return this.isValid ? this.values.months || 0 : NaN;\n    }\n    /**\n     * Get the weeks\n     * @type {number}\n     */\n\n  }, {\n    key: \"weeks\",\n    get: function get() {\n      return this.isValid ? this.values.weeks || 0 : NaN;\n    }\n    /**\n     * Get the days.\n     * @type {number}\n     */\n\n  }, {\n    key: \"days\",\n    get: function get() {\n      return this.isValid ? this.values.days || 0 : NaN;\n    }\n    /**\n     * Get the hours.\n     * @type {number}\n     */\n\n  }, {\n    key: \"hours\",\n    get: function get() {\n      return this.isValid ? this.values.hours || 0 : NaN;\n    }\n    /**\n     * Get the minutes.\n     * @type {number}\n     */\n\n  }, {\n    key: \"minutes\",\n    get: function get() {\n      return this.isValid ? this.values.minutes || 0 : NaN;\n    }\n    /**\n     * Get the seconds.\n     * @return {number}\n     */\n\n  }, {\n    key: \"seconds\",\n    get: function get() {\n      return this.isValid ? this.values.seconds || 0 : NaN;\n    }\n    /**\n     * Get the milliseconds.\n     * @return {number}\n     */\n\n  }, {\n    key: \"milliseconds\",\n    get: function get() {\n      return this.isValid ? this.values.milliseconds || 0 : NaN;\n    }\n    /**\n     * Returns whether the Duration is invalid. Invalid durations are returned by diff operations\n     * on invalid DateTimes or Intervals.\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isValid\",\n    get: function get() {\n      return this.invalid === null;\n    }\n    /**\n     * Returns an error code if this Duration became invalid, or null if the Duration is valid\n     * @return {string}\n     */\n\n  }, {\n    key: \"invalidReason\",\n    get: function get() {\n      return this.invalid ? this.invalid.reason : null;\n    }\n    /**\n     * Returns an explanation of why this Duration became invalid, or null if the Duration is valid\n     * @type {string}\n     */\n\n  }, {\n    key: \"invalidExplanation\",\n    get: function get() {\n      return this.invalid ? this.invalid.explanation : null;\n    }\n    /**\n     * Equality check\n     * Two Durations are equal iff they have the same units and the same values for each unit.\n     * @param {Duration} other\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (!this.isValid || !other.isValid) {\n        return false;\n      }\n\n      if (!this.loc.equals(other.loc)) {\n        return false;\n      }\n\n      function eq(v1, v2) {\n        // Consider 0 and undefined as equal\n        if (v1 === undefined || v1 === 0) return v2 === undefined || v2 === 0;\n        return v1 === v2;\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(orderedUnits),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var u = _step3.value;\n\n          if (!eq(this.values[u], other.values[u])) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return true;\n    }\n  }], [{\n    key: \"fromMillis\",\n    value: function fromMillis(count, opts) {\n      return Duration.fromObject({\n        milliseconds: count\n      }, opts);\n    }\n    /**\n     * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.\n     * If this object is empty then a zero milliseconds duration is returned.\n     * @param {Object} obj - the object to create the DateTime from\n     * @param {number} obj.years\n     * @param {number} obj.quarters\n     * @param {number} obj.months\n     * @param {number} obj.weeks\n     * @param {number} obj.days\n     * @param {number} obj.hours\n     * @param {number} obj.minutes\n     * @param {number} obj.seconds\n     * @param {number} obj.milliseconds\n     * @param {Object} [opts=[]] - options for creating this Duration\n     * @param {string} [opts.locale='en-US'] - the locale to use\n     * @param {string} opts.numberingSystem - the numbering system to use\n     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n     * @return {Duration}\n     */\n\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(obj) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (obj == null || typeof obj !== \"object\") {\n        throw new InvalidArgumentError(\"Duration.fromObject: argument expected to be an object, got \".concat(obj === null ? \"null\" : typeof obj));\n      }\n\n      return new Duration({\n        values: normalizeObject(obj, Duration.normalizeUnit),\n        loc: Locale.fromObject(opts),\n        conversionAccuracy: opts.conversionAccuracy\n      });\n    }\n    /**\n     * Create a Duration from DurationLike.\n     *\n     * @param {Object | number | Duration} durationLike\n     * One of:\n     * - object with keys like 'years' and 'hours'.\n     * - number representing milliseconds\n     * - Duration instance\n     * @return {Duration}\n     */\n\n  }, {\n    key: \"fromDurationLike\",\n    value: function fromDurationLike(durationLike) {\n      if (isNumber(durationLike)) {\n        return Duration.fromMillis(durationLike);\n      } else if (Duration.isDuration(durationLike)) {\n        return durationLike;\n      } else if (typeof durationLike === \"object\") {\n        return Duration.fromObject(durationLike);\n      } else {\n        throw new InvalidArgumentError(\"Unknown duration argument \".concat(durationLike, \" of type \").concat(typeof durationLike));\n      }\n    }\n    /**\n     * Create a Duration from an ISO 8601 duration string.\n     * @param {string} text - text to parse\n     * @param {Object} opts - options for parsing\n     * @param {string} [opts.locale='en-US'] - the locale to use\n     * @param {string} opts.numberingSystem - the numbering system to use\n     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n     * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }\n     * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }\n     * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }\n     * @return {Duration}\n     */\n\n  }, {\n    key: \"fromISO\",\n    value: function fromISO(text, opts) {\n      var _parseISODuration = parseISODuration(text),\n          _parseISODuration2 = _slicedToArray(_parseISODuration, 1),\n          parsed = _parseISODuration2[0];\n\n      if (parsed) {\n        return Duration.fromObject(parsed, opts);\n      } else {\n        return Duration.invalid(\"unparsable\", \"the input \\\"\".concat(text, \"\\\" can't be parsed as ISO 8601\"));\n      }\n    }\n    /**\n     * Create a Duration from an ISO 8601 time string.\n     * @param {string} text - text to parse\n     * @param {Object} opts - options for parsing\n     * @param {string} [opts.locale='en-US'] - the locale to use\n     * @param {string} opts.numberingSystem - the numbering system to use\n     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Times\n     * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }\n     * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n     * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n     * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n     * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n     * @return {Duration}\n     */\n\n  }, {\n    key: \"fromISOTime\",\n    value: function fromISOTime(text, opts) {\n      var _parseISOTimeOnly = parseISOTimeOnly(text),\n          _parseISOTimeOnly2 = _slicedToArray(_parseISOTimeOnly, 1),\n          parsed = _parseISOTimeOnly2[0];\n\n      if (parsed) {\n        return Duration.fromObject(parsed, opts);\n      } else {\n        return Duration.invalid(\"unparsable\", \"the input \\\"\".concat(text, \"\\\" can't be parsed as ISO 8601\"));\n      }\n    }\n    /**\n     * Create an invalid Duration.\n     * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent\n     * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\n     * @return {Duration}\n     */\n\n  }, {\n    key: \"invalid\",\n    value: function invalid(reason) {\n      var explanation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (!reason) {\n        throw new InvalidArgumentError(\"need to specify a reason the Duration is invalid\");\n      }\n\n      var invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);\n\n      if (Settings.throwOnInvalid) {\n        throw new InvalidDurationError(invalid);\n      } else {\n        return new Duration({\n          invalid: invalid\n        });\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"normalizeUnit\",\n    value: function normalizeUnit(unit) {\n      var normalized = {\n        year: \"years\",\n        years: \"years\",\n        quarter: \"quarters\",\n        quarters: \"quarters\",\n        month: \"months\",\n        months: \"months\",\n        week: \"weeks\",\n        weeks: \"weeks\",\n        day: \"days\",\n        days: \"days\",\n        hour: \"hours\",\n        hours: \"hours\",\n        minute: \"minutes\",\n        minutes: \"minutes\",\n        second: \"seconds\",\n        seconds: \"seconds\",\n        millisecond: \"milliseconds\",\n        milliseconds: \"milliseconds\"\n      }[unit ? unit.toLowerCase() : unit];\n      if (!normalized) throw new InvalidUnitError(unit);\n      return normalized;\n    }\n    /**\n     * Check if an object is a Duration. Works across context boundaries\n     * @param {object} o\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isDuration\",\n    value: function isDuration(o) {\n      return o && o.isLuxonDuration || false;\n    }\n  }]);\n\n  return Duration;\n}();\n\nexport { Duration as default };","map":{"version":3,"sources":["/awx_devel/awx/ui/node_modules/luxon/src/duration.js"],"names":["InvalidArgumentError","InvalidDurationError","InvalidUnitError","Formatter","Invalid","Locale","parseISODuration","parseISOTimeOnly","asNumber","hasOwnProperty","isNumber","isUndefined","normalizeObject","roundTo","Settings","INVALID","lowOrderMatrix","weeks","days","hours","minutes","seconds","milliseconds","casualMatrix","years","quarters","months","daysInYearAccurate","daysInMonthAccurate","accurateMatrix","orderedUnits","reverseUnits","slice","reverse","clone","dur","alts","clear","conf","values","loc","conversionAccuracy","Duration","antiTrunc","n","Math","floor","ceil","convert","matrix","fromMap","fromUnit","toMap","toUnit","conv","raw","sameSign","sign","added","abs","trunc","normalizeValues","vals","reduce","previous","current","config","accurate","create","invalid","isLuxonDuration","isValid","locale","numberingSystem","fmt","opts","fmtOpts","round","formatDurationFromString","l","map","unit","val","numberFormatter","style","unitDisplay","format","filter","listFormatter","type","listStyle","s","millis","toMillis","suppressMilliseconds","suppressSeconds","includePrefix","value","shiftTo","str","toFormat","toISO","as","duration","fromDurationLike","result","k","get","plus","negate","fn","Object","keys","normalizeUnit","mixed","NaN","toObject","units","length","u","built","accumulated","lastUnit","indexOf","own","ak","i","down","key","normalize","negated","reason","explanation","other","equals","eq","v1","v2","undefined","count","fromObject","obj","durationLike","fromMillis","isDuration","text","parsed","throwOnInvalid","normalized","year","quarter","month","week","day","hour","minute","second","millisecond","toLowerCase","o"],"mappings":"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","sourcesContent":["import { InvalidArgumentError, InvalidDurationError, InvalidUnitError } from \"./errors.js\";\nimport Formatter from \"./impl/formatter.js\";\nimport Invalid from \"./impl/invalid.js\";\nimport Locale from \"./impl/locale.js\";\nimport { parseISODuration, parseISOTimeOnly } from \"./impl/regexParser.js\";\nimport {\n  asNumber,\n  hasOwnProperty,\n  isNumber,\n  isUndefined,\n  normalizeObject,\n  roundTo,\n} from \"./impl/util.js\";\nimport Settings from \"./settings.js\";\n\nconst INVALID = \"Invalid Duration\";\n\n// unit conversion constants\nexport const lowOrderMatrix = {\n    weeks: {\n      days: 7,\n      hours: 7 * 24,\n      minutes: 7 * 24 * 60,\n      seconds: 7 * 24 * 60 * 60,\n      milliseconds: 7 * 24 * 60 * 60 * 1000,\n    },\n    days: {\n      hours: 24,\n      minutes: 24 * 60,\n      seconds: 24 * 60 * 60,\n      milliseconds: 24 * 60 * 60 * 1000,\n    },\n    hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1000 },\n    minutes: { seconds: 60, milliseconds: 60 * 1000 },\n    seconds: { milliseconds: 1000 },\n  },\n  casualMatrix = {\n    years: {\n      quarters: 4,\n      months: 12,\n      weeks: 52,\n      days: 365,\n      hours: 365 * 24,\n      minutes: 365 * 24 * 60,\n      seconds: 365 * 24 * 60 * 60,\n      milliseconds: 365 * 24 * 60 * 60 * 1000,\n    },\n    quarters: {\n      months: 3,\n      weeks: 13,\n      days: 91,\n      hours: 91 * 24,\n      minutes: 91 * 24 * 60,\n      seconds: 91 * 24 * 60 * 60,\n      milliseconds: 91 * 24 * 60 * 60 * 1000,\n    },\n    months: {\n      weeks: 4,\n      days: 30,\n      hours: 30 * 24,\n      minutes: 30 * 24 * 60,\n      seconds: 30 * 24 * 60 * 60,\n      milliseconds: 30 * 24 * 60 * 60 * 1000,\n    },\n\n    ...lowOrderMatrix,\n  },\n  daysInYearAccurate = 146097.0 / 400,\n  daysInMonthAccurate = 146097.0 / 4800,\n  accurateMatrix = {\n    years: {\n      quarters: 4,\n      months: 12,\n      weeks: daysInYearAccurate / 7,\n      days: daysInYearAccurate,\n      hours: daysInYearAccurate * 24,\n      minutes: daysInYearAccurate * 24 * 60,\n      seconds: daysInYearAccurate * 24 * 60 * 60,\n      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000,\n    },\n    quarters: {\n      months: 3,\n      weeks: daysInYearAccurate / 28,\n      days: daysInYearAccurate / 4,\n      hours: (daysInYearAccurate * 24) / 4,\n      minutes: (daysInYearAccurate * 24 * 60) / 4,\n      seconds: (daysInYearAccurate * 24 * 60 * 60) / 4,\n      milliseconds: (daysInYearAccurate * 24 * 60 * 60 * 1000) / 4,\n    },\n    months: {\n      weeks: daysInMonthAccurate / 7,\n      days: daysInMonthAccurate,\n      hours: daysInMonthAccurate * 24,\n      minutes: daysInMonthAccurate * 24 * 60,\n      seconds: daysInMonthAccurate * 24 * 60 * 60,\n      milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000,\n    },\n    ...lowOrderMatrix,\n  };\n\n// units ordered by size\nconst orderedUnits = [\n  \"years\",\n  \"quarters\",\n  \"months\",\n  \"weeks\",\n  \"days\",\n  \"hours\",\n  \"minutes\",\n  \"seconds\",\n  \"milliseconds\",\n];\n\nconst reverseUnits = orderedUnits.slice(0).reverse();\n\n// clone really means \"create another instance just like this one, but with these changes\"\nfunction clone(dur, alts, clear = false) {\n  // deep merge for vals\n  const conf = {\n    values: clear ? alts.values : { ...dur.values, ...(alts.values || {}) },\n    loc: dur.loc.clone(alts.loc),\n    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,\n  };\n  return new Duration(conf);\n}\n\nfunction antiTrunc(n) {\n  return n < 0 ? Math.floor(n) : Math.ceil(n);\n}\n\n// NB: mutates parameters\nfunction convert(matrix, fromMap, fromUnit, toMap, toUnit) {\n  const conv = matrix[toUnit][fromUnit],\n    raw = fromMap[fromUnit] / conv,\n    sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]),\n    // ok, so this is wild, but see the matrix in the tests\n    added =\n      !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);\n  toMap[toUnit] += added;\n  fromMap[fromUnit] -= added * conv;\n}\n\n// NB: mutates parameters\nfunction normalizeValues(matrix, vals) {\n  reverseUnits.reduce((previous, current) => {\n    if (!isUndefined(vals[current])) {\n      if (previous) {\n        convert(matrix, vals, previous, vals, current);\n      }\n      return current;\n    } else {\n      return previous;\n    }\n  }, null);\n}\n\n/**\n * A Duration object represents a period of time, like \"2 months\" or \"1 day, 1 hour\". Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them. They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime#plus} to add a Duration object to a DateTime, producing another DateTime.\n *\n * Here is a brief overview of commonly used methods and getters in Duration:\n *\n * * **Creation** To create a Duration, use {@link Duration#fromMillis}, {@link Duration#fromObject}, or {@link Duration#fromISO}.\n * * **Unit values** See the {@link Duration#years}, {@link Duration#months}, {@link Duration#weeks}, {@link Duration#days}, {@link Duration#hours}, {@link Duration#minutes}, {@link Duration#seconds}, {@link Duration#milliseconds} accessors.\n * * **Configuration** See  {@link Duration#locale} and {@link Duration#numberingSystem} accessors.\n * * **Transformation** To create new Durations out of old ones use {@link Duration#plus}, {@link Duration#minus}, {@link Duration#normalize}, {@link Duration#set}, {@link Duration#reconfigure}, {@link Duration#shiftTo}, and {@link Duration#negate}.\n * * **Output** To convert the Duration into other representations, see {@link Duration#as}, {@link Duration#toISO}, {@link Duration#toFormat}, and {@link Duration#toJSON}\n *\n * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.\n */\nexport default class Duration {\n  /**\n   * @private\n   */\n  constructor(config) {\n    const accurate = config.conversionAccuracy === \"longterm\" || false;\n    /**\n     * @access private\n     */\n    this.values = config.values;\n    /**\n     * @access private\n     */\n    this.loc = config.loc || Locale.create();\n    /**\n     * @access private\n     */\n    this.conversionAccuracy = accurate ? \"longterm\" : \"casual\";\n    /**\n     * @access private\n     */\n    this.invalid = config.invalid || null;\n    /**\n     * @access private\n     */\n    this.matrix = accurate ? accurateMatrix : casualMatrix;\n    /**\n     * @access private\n     */\n    this.isLuxonDuration = true;\n  }\n\n  /**\n   * Create Duration from a number of milliseconds.\n   * @param {number} count of milliseconds\n   * @param {Object} opts - options for parsing\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @return {Duration}\n   */\n  static fromMillis(count, opts) {\n    return Duration.fromObject({ milliseconds: count }, opts);\n  }\n\n  /**\n   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.\n   * If this object is empty then a zero milliseconds duration is returned.\n   * @param {Object} obj - the object to create the DateTime from\n   * @param {number} obj.years\n   * @param {number} obj.quarters\n   * @param {number} obj.months\n   * @param {number} obj.weeks\n   * @param {number} obj.days\n   * @param {number} obj.hours\n   * @param {number} obj.minutes\n   * @param {number} obj.seconds\n   * @param {number} obj.milliseconds\n   * @param {Object} [opts=[]] - options for creating this Duration\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @return {Duration}\n   */\n  static fromObject(obj, opts = {}) {\n    if (obj == null || typeof obj !== \"object\") {\n      throw new InvalidArgumentError(\n        `Duration.fromObject: argument expected to be an object, got ${\n          obj === null ? \"null\" : typeof obj\n        }`\n      );\n    }\n\n    return new Duration({\n      values: normalizeObject(obj, Duration.normalizeUnit),\n      loc: Locale.fromObject(opts),\n      conversionAccuracy: opts.conversionAccuracy,\n    });\n  }\n\n  /**\n   * Create a Duration from DurationLike.\n   *\n   * @param {Object | number | Duration} durationLike\n   * One of:\n   * - object with keys like 'years' and 'hours'.\n   * - number representing milliseconds\n   * - Duration instance\n   * @return {Duration}\n   */\n  static fromDurationLike(durationLike) {\n    if (isNumber(durationLike)) {\n      return Duration.fromMillis(durationLike);\n    } else if (Duration.isDuration(durationLike)) {\n      return durationLike;\n    } else if (typeof durationLike === \"object\") {\n      return Duration.fromObject(durationLike);\n    } else {\n      throw new InvalidArgumentError(\n        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`\n      );\n    }\n  }\n\n  /**\n   * Create a Duration from an ISO 8601 duration string.\n   * @param {string} text - text to parse\n   * @param {Object} opts - options for parsing\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }\n   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }\n   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }\n   * @return {Duration}\n   */\n  static fromISO(text, opts) {\n    const [parsed] = parseISODuration(text);\n    if (parsed) {\n      return Duration.fromObject(parsed, opts);\n    } else {\n      return Duration.invalid(\"unparsable\", `the input \"${text}\" can't be parsed as ISO 8601`);\n    }\n  }\n\n  /**\n   * Create a Duration from an ISO 8601 time string.\n   * @param {string} text - text to parse\n   * @param {Object} opts - options for parsing\n   * @param {string} [opts.locale='en-US'] - the locale to use\n   * @param {string} opts.numberingSystem - the numbering system to use\n   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Times\n   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }\n   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n   * @return {Duration}\n   */\n  static fromISOTime(text, opts) {\n    const [parsed] = parseISOTimeOnly(text);\n    if (parsed) {\n      return Duration.fromObject(parsed, opts);\n    } else {\n      return Duration.invalid(\"unparsable\", `the input \"${text}\" can't be parsed as ISO 8601`);\n    }\n  }\n\n  /**\n   * Create an invalid Duration.\n   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\n   * @return {Duration}\n   */\n  static invalid(reason, explanation = null) {\n    if (!reason) {\n      throw new InvalidArgumentError(\"need to specify a reason the Duration is invalid\");\n    }\n\n    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);\n\n    if (Settings.throwOnInvalid) {\n      throw new InvalidDurationError(invalid);\n    } else {\n      return new Duration({ invalid });\n    }\n  }\n\n  /**\n   * @private\n   */\n  static normalizeUnit(unit) {\n    const normalized = {\n      year: \"years\",\n      years: \"years\",\n      quarter: \"quarters\",\n      quarters: \"quarters\",\n      month: \"months\",\n      months: \"months\",\n      week: \"weeks\",\n      weeks: \"weeks\",\n      day: \"days\",\n      days: \"days\",\n      hour: \"hours\",\n      hours: \"hours\",\n      minute: \"minutes\",\n      minutes: \"minutes\",\n      second: \"seconds\",\n      seconds: \"seconds\",\n      millisecond: \"milliseconds\",\n      milliseconds: \"milliseconds\",\n    }[unit ? unit.toLowerCase() : unit];\n\n    if (!normalized) throw new InvalidUnitError(unit);\n\n    return normalized;\n  }\n\n  /**\n   * Check if an object is a Duration. Works across context boundaries\n   * @param {object} o\n   * @return {boolean}\n   */\n  static isDuration(o) {\n    return (o && o.isLuxonDuration) || false;\n  }\n\n  /**\n   * Get  the locale of a Duration, such 'en-GB'\n   * @type {string}\n   */\n  get locale() {\n    return this.isValid ? this.loc.locale : null;\n  }\n\n  /**\n   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration\n   *\n   * @type {string}\n   */\n  get numberingSystem() {\n    return this.isValid ? this.loc.numberingSystem : null;\n  }\n\n  /**\n   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:\n   * * `S` for milliseconds\n   * * `s` for seconds\n   * * `m` for minutes\n   * * `h` for hours\n   * * `d` for days\n   * * `w` for weeks\n   * * `M` for months\n   * * `y` for years\n   * Notes:\n   * * Add padding by repeating the token, e.g. \"yy\" pads the years to two digits, \"hhhh\" pads the hours out to four digits\n   * * Tokens can be escaped by wrapping with single quotes.\n   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.\n   * @param {string} fmt - the format string\n   * @param {Object} opts - options\n   * @param {boolean} [opts.floor=true] - floor numerical values\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"y d s\") //=> \"1 6 2\"\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"yy dd sss\") //=> \"01 06 002\"\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"M S\") //=> \"12 518402000\"\n   * @return {string}\n   */\n  toFormat(fmt, opts = {}) {\n    // reverse-compat since 1.2; we always round down now, never up, and we do it by default\n    const fmtOpts = {\n      ...opts,\n      floor: opts.round !== false && opts.floor !== false,\n    };\n    return this.isValid\n      ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt)\n      : INVALID;\n  }\n\n  /**\n   * Returns a string representation of a Duration with all units included.\n   * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat\n   * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.\n   * @example\n   * ```js\n   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })\n   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'\n   * dur.toHuman({ listStyle: \"long\" }) //=> '1 day, 5 hours, and 6 minutes'\n   * dur.toHuman({ unitDisplay: \"short\" }) //=> '1 day, 5 hr, 6 min'\n   * ```\n   */\n  toHuman(opts = {}) {\n    const l = orderedUnits\n      .map((unit) => {\n        const val = this.values[unit];\n        if (isUndefined(val)) {\n          return null;\n        }\n        return this.loc\n          .numberFormatter({ style: \"unit\", unitDisplay: \"long\", ...opts, unit: unit.slice(0, -1) })\n          .format(val);\n      })\n      .filter((n) => n);\n\n    return this.loc\n      .listFormatter({ type: \"conjunction\", style: opts.listStyle || \"narrow\", ...opts })\n      .format(l);\n  }\n\n  /**\n   * Returns a JavaScript object with this Duration's values.\n   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }\n   * @return {Object}\n   */\n  toObject() {\n    if (!this.isValid) return {};\n    return { ...this.values };\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this Duration.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'\n   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'\n   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'\n   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'\n   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'\n   * @return {string}\n   */\n  toISO() {\n    // we could use the formatter, but this is an easier way to get the minimum string\n    if (!this.isValid) return null;\n\n    let s = \"P\";\n    if (this.years !== 0) s += this.years + \"Y\";\n    if (this.months !== 0 || this.quarters !== 0) s += this.months + this.quarters * 3 + \"M\";\n    if (this.weeks !== 0) s += this.weeks + \"W\";\n    if (this.days !== 0) s += this.days + \"D\";\n    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)\n      s += \"T\";\n    if (this.hours !== 0) s += this.hours + \"H\";\n    if (this.minutes !== 0) s += this.minutes + \"M\";\n    if (this.seconds !== 0 || this.milliseconds !== 0)\n      // this will handle \"floating point madness\" by removing extra decimal places\n      // https://stackoverflow.com/questions/588004/is-floating-point-math-broken\n      s += roundTo(this.seconds + this.milliseconds / 1000, 3) + \"S\";\n    if (s === \"P\") s += \"T0S\";\n    return s;\n  }\n\n  /**\n   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.\n   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Times\n   * @param {Object} opts - options\n   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0\n   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0\n   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix\n   * @param {string} [opts.format='extended'] - choose between the basic and extended format\n   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'\n   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'\n   * @return {string}\n   */\n  toISOTime(opts = {}) {\n    if (!this.isValid) return null;\n\n    const millis = this.toMillis();\n    if (millis < 0 || millis >= 86400000) return null;\n\n    opts = {\n      suppressMilliseconds: false,\n      suppressSeconds: false,\n      includePrefix: false,\n      format: \"extended\",\n      ...opts,\n    };\n\n    const value = this.shiftTo(\"hours\", \"minutes\", \"seconds\", \"milliseconds\");\n\n    let fmt = opts.format === \"basic\" ? \"hhmm\" : \"hh:mm\";\n\n    if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {\n      fmt += opts.format === \"basic\" ? \"ss\" : \":ss\";\n      if (!opts.suppressMilliseconds || value.milliseconds !== 0) {\n        fmt += \".SSS\";\n      }\n    }\n\n    let str = value.toFormat(fmt);\n\n    if (opts.includePrefix) {\n      str = \"T\" + str;\n    }\n\n    return str;\n  }\n\n  /**\n   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.\n   * @return {string}\n   */\n  toJSON() {\n    return this.toISO();\n  }\n\n  /**\n   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.\n   * @return {string}\n   */\n  toString() {\n    return this.toISO();\n  }\n\n  /**\n   * Returns an milliseconds value of this Duration.\n   * @return {number}\n   */\n  toMillis() {\n    return this.as(\"milliseconds\");\n  }\n\n  /**\n   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}\n   * @return {number}\n   */\n  valueOf() {\n    return this.toMillis();\n  }\n\n  /**\n   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.\n   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   * @return {Duration}\n   */\n  plus(duration) {\n    if (!this.isValid) return this;\n\n    const dur = Duration.fromDurationLike(duration),\n      result = {};\n\n    for (const k of orderedUnits) {\n      if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {\n        result[k] = dur.get(k) + this.get(k);\n      }\n    }\n\n    return clone(this, { values: result }, true);\n  }\n\n  /**\n   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.\n   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n   * @return {Duration}\n   */\n  minus(duration) {\n    if (!this.isValid) return this;\n\n    const dur = Duration.fromDurationLike(duration);\n    return this.plus(dur.negate());\n  }\n\n  /**\n   * Scale this Duration by the specified amount. Return a newly-constructed Duration.\n   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.\n   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }\n   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === \"hour\" ? x * 2 : x) //=> { hours: 2, minutes: 30 }\n   * @return {Duration}\n   */\n  mapUnits(fn) {\n    if (!this.isValid) return this;\n    const result = {};\n    for (const k of Object.keys(this.values)) {\n      result[k] = asNumber(fn(this.values[k], k));\n    }\n    return clone(this, { values: result }, true);\n  }\n\n  /**\n   * Get the value of unit.\n   * @param {string} unit - a unit such as 'minute' or 'day'\n   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2\n   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0\n   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3\n   * @return {number}\n   */\n  get(unit) {\n    return this[Duration.normalizeUnit(unit)];\n  }\n\n  /**\n   * \"Set\" the values of specified units. Return a newly-constructed Duration.\n   * @param {Object} values - a mapping of units to numbers\n   * @example dur.set({ years: 2017 })\n   * @example dur.set({ hours: 8, minutes: 30 })\n   * @return {Duration}\n   */\n  set(values) {\n    if (!this.isValid) return this;\n\n    const mixed = { ...this.values, ...normalizeObject(values, Duration.normalizeUnit) };\n    return clone(this, { values: mixed });\n  }\n\n  /**\n   * \"Set\" the locale and/or numberingSystem.  Returns a newly-constructed Duration.\n   * @example dur.reconfigure({ locale: 'en-GB' })\n   * @return {Duration}\n   */\n  reconfigure({ locale, numberingSystem, conversionAccuracy } = {}) {\n    const loc = this.loc.clone({ locale, numberingSystem }),\n      opts = { loc };\n\n    if (conversionAccuracy) {\n      opts.conversionAccuracy = conversionAccuracy;\n    }\n\n    return clone(this, opts);\n  }\n\n  /**\n   * Return the length of the duration in the specified unit.\n   * @param {string} unit - a unit such as 'minutes' or 'days'\n   * @example Duration.fromObject({years: 1}).as('days') //=> 365\n   * @example Duration.fromObject({years: 1}).as('months') //=> 12\n   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5\n   * @return {number}\n   */\n  as(unit) {\n    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;\n  }\n\n  /**\n   * Reduce this Duration to its canonical representation in its current units.\n   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }\n   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }\n   * @return {Duration}\n   */\n  normalize() {\n    if (!this.isValid) return this;\n    const vals = this.toObject();\n    normalizeValues(this.matrix, vals);\n    return clone(this, { values: vals }, true);\n  }\n\n  /**\n   * Convert this Duration into its representation in a different set of units.\n   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }\n   * @return {Duration}\n   */\n  shiftTo(...units) {\n    if (!this.isValid) return this;\n\n    if (units.length === 0) {\n      return this;\n    }\n\n    units = units.map((u) => Duration.normalizeUnit(u));\n\n    const built = {},\n      accumulated = {},\n      vals = this.toObject();\n    let lastUnit;\n\n    for (const k of orderedUnits) {\n      if (units.indexOf(k) >= 0) {\n        lastUnit = k;\n\n        let own = 0;\n\n        // anything we haven't boiled down yet should get boiled to this unit\n        for (const ak in accumulated) {\n          own += this.matrix[ak][k] * accumulated[ak];\n          accumulated[ak] = 0;\n        }\n\n        // plus anything that's already in this unit\n        if (isNumber(vals[k])) {\n          own += vals[k];\n        }\n\n        const i = Math.trunc(own);\n        built[k] = i;\n        accumulated[k] = (own * 1000 - i * 1000) / 1000;\n\n        // plus anything further down the chain that should be rolled up in to this\n        for (const down in vals) {\n          if (orderedUnits.indexOf(down) > orderedUnits.indexOf(k)) {\n            convert(this.matrix, vals, down, built, k);\n          }\n        }\n        // otherwise, keep it in the wings to boil it later\n      } else if (isNumber(vals[k])) {\n        accumulated[k] = vals[k];\n      }\n    }\n\n    // anything leftover becomes the decimal for the last unit\n    // lastUnit must be defined since units is not empty\n    for (const key in accumulated) {\n      if (accumulated[key] !== 0) {\n        built[lastUnit] +=\n          key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];\n      }\n    }\n\n    return clone(this, { values: built }, true).normalize();\n  }\n\n  /**\n   * Return the negative of this Duration.\n   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }\n   * @return {Duration}\n   */\n  negate() {\n    if (!this.isValid) return this;\n    const negated = {};\n    for (const k of Object.keys(this.values)) {\n      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];\n    }\n    return clone(this, { values: negated }, true);\n  }\n\n  /**\n   * Get the years.\n   * @type {number}\n   */\n  get years() {\n    return this.isValid ? this.values.years || 0 : NaN;\n  }\n\n  /**\n   * Get the quarters.\n   * @type {number}\n   */\n  get quarters() {\n    return this.isValid ? this.values.quarters || 0 : NaN;\n  }\n\n  /**\n   * Get the months.\n   * @type {number}\n   */\n  get months() {\n    return this.isValid ? this.values.months || 0 : NaN;\n  }\n\n  /**\n   * Get the weeks\n   * @type {number}\n   */\n  get weeks() {\n    return this.isValid ? this.values.weeks || 0 : NaN;\n  }\n\n  /**\n   * Get the days.\n   * @type {number}\n   */\n  get days() {\n    return this.isValid ? this.values.days || 0 : NaN;\n  }\n\n  /**\n   * Get the hours.\n   * @type {number}\n   */\n  get hours() {\n    return this.isValid ? this.values.hours || 0 : NaN;\n  }\n\n  /**\n   * Get the minutes.\n   * @type {number}\n   */\n  get minutes() {\n    return this.isValid ? this.values.minutes || 0 : NaN;\n  }\n\n  /**\n   * Get the seconds.\n   * @return {number}\n   */\n  get seconds() {\n    return this.isValid ? this.values.seconds || 0 : NaN;\n  }\n\n  /**\n   * Get the milliseconds.\n   * @return {number}\n   */\n  get milliseconds() {\n    return this.isValid ? this.values.milliseconds || 0 : NaN;\n  }\n\n  /**\n   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations\n   * on invalid DateTimes or Intervals.\n   * @return {boolean}\n   */\n  get isValid() {\n    return this.invalid === null;\n  }\n\n  /**\n   * Returns an error code if this Duration became invalid, or null if the Duration is valid\n   * @return {string}\n   */\n  get invalidReason() {\n    return this.invalid ? this.invalid.reason : null;\n  }\n\n  /**\n   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid\n   * @type {string}\n   */\n  get invalidExplanation() {\n    return this.invalid ? this.invalid.explanation : null;\n  }\n\n  /**\n   * Equality check\n   * Two Durations are equal iff they have the same units and the same values for each unit.\n   * @param {Duration} other\n   * @return {boolean}\n   */\n  equals(other) {\n    if (!this.isValid || !other.isValid) {\n      return false;\n    }\n\n    if (!this.loc.equals(other.loc)) {\n      return false;\n    }\n\n    function eq(v1, v2) {\n      // Consider 0 and undefined as equal\n      if (v1 === undefined || v1 === 0) return v2 === undefined || v2 === 0;\n      return v1 === v2;\n    }\n\n    for (const u of orderedUnits) {\n      if (!eq(this.values[u], other.values[u])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}