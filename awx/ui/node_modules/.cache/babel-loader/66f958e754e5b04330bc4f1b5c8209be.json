{"ast":null,"code":"import _defineProperty from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { top, left, right, bottom } from '../enums';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport getWindow from '../dom-utils/getWindow';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport getComputedStyle from '../dom-utils/getComputedStyle';\nimport getBasePlacement from '../utils/getBasePlacement';\nvar unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n\n/**\n *\n */\n\nfunction roundOffsets(_ref) {\n  var x = _ref.x,\n      y = _ref.y;\n  var win = window;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: Math.round(x * dpr) / dpr || 0,\n    y: Math.round(y * dpr) / dpr || 0\n  };\n}\n/**\n *\n */\n\n\nexport function mapToStyles(_ref2) {\n  var _Object$assign2;\n\n  var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive;\n\n  var _roundOffsets = roundOffsets(offsets),\n      x = _roundOffsets.x,\n      y = _roundOffsets.y;\n\n  var hasX = offsets.hasOwnProperty('x');\n  var hasY = offsets.hasOwnProperty('y');\n  var sideX = left;\n  var sideY = top;\n  var win = window;\n\n  if (adaptive) {\n    var offsetParent = getOffsetParent(popper);\n\n    if (offsetParent === getWindow(popper)) {\n      offsetParent = getDocumentElement(popper);\n    } // $FlowFixMe: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n    /* :: offsetParent = (offsetParent: Element); */\n\n\n    if (placement === top) {\n      sideY = bottom;\n      y -= offsetParent.clientHeight - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === left) {\n      sideX = right;\n      x -= offsetParent.clientWidth - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  var commonStyles = Object.assign({\n    position: position\n  }, adaptive && unsetSides);\n\n  if (gpuAcceleration) {\n    var _Object$assign;\n\n    return Object.assign(Object.assign({}, commonStyles), (_Object$assign = {}, _defineProperty(_Object$assign, sideY, hasY ? '0' : ''), _defineProperty(_Object$assign, sideX, hasX ? '0' : ''), _defineProperty(_Object$assign, \"transform\", (win.devicePixelRatio || 1) < 2 ? \"translate(\".concat(x, \"px, \").concat(y, \"px)\") : \"translate3d(\".concat(x, \"px, \").concat(y, \"px, 0)\")), _Object$assign));\n  }\n\n  return Object.assign(Object.assign({}, commonStyles), (_Object$assign2 = {}, _defineProperty(_Object$assign2, sideY, hasY ? \"\".concat(y, \"px\") : ''), _defineProperty(_Object$assign2, sideX, hasX ? \"\".concat(x, \"px\") : ''), _defineProperty(_Object$assign2, \"transform\", ''), _Object$assign2));\n}\n/**\n *\n */\n\nfunction computeStyles(_ref3) {\n  var state = _ref3.state,\n      options = _ref3.options;\n  var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive;\n\n  if (false\n  /* __DEV__*/\n  ) {\n    var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || '';\n\n    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {\n      return transitionProperty.indexOf(property) >= 0;\n    })) {\n      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".', '\\n\\n', 'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\\n\\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));\n    }\n  }\n\n  var commonStyles = {\n    placement: getBasePlacement(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration: gpuAcceleration\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign(Object.assign({}, state.styles.popper), mapToStyles(Object.assign(Object.assign({}, commonStyles), {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive: adaptive\n    })));\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign(Object.assign({}, state.styles.arrow), mapToStyles(Object.assign(Object.assign({}, commonStyles), {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false\n    })));\n  }\n\n  state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), {\n    'data-popper-placement': state.placement\n  });\n}\n\nexport default {\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n};","map":{"version":3,"sources":["/awx_devel/awx/ui/node_modules/@patternfly/react-core/src/helpers/Popper/thirdparty/popper-core/modifiers/computeStyles.ts"],"names":[],"mappings":"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","sourcesContent":["// @ts-nocheck\nimport { PositioningStrategy, Offsets, Modifier, ModifierArguments, Rect, Window } from '../types';\nimport { BasePlacement, top, left, right, bottom } from '../enums';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport getWindow from '../dom-utils/getWindow';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport getComputedStyle from '../dom-utils/getComputedStyle';\nimport getBasePlacement from '../utils/getBasePlacement';\n\n// eslint-disable-next-line import/no-unused-modules\nexport interface Options {\n  gpuAcceleration: boolean;\n  adaptive: boolean;\n}\n\nconst unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n};\n\n// Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n/**\n *\n */\nfunction roundOffsets({ x, y }): Offsets {\n  const win: Window = window;\n  const dpr = win.devicePixelRatio || 1;\n\n  return {\n    x: Math.round(x * dpr) / dpr || 0,\n    y: Math.round(y * dpr) / dpr || 0\n  };\n}\n\n/**\n *\n */\nexport function mapToStyles({\n  popper,\n  popperRect,\n  placement,\n  offsets,\n  position,\n  gpuAcceleration,\n  adaptive\n}: {\n  popper: HTMLElement;\n  popperRect: Rect;\n  placement: BasePlacement;\n  offsets: Partial<{ x: number; y: number; centerOffset: number }>;\n  position: PositioningStrategy;\n  gpuAcceleration: boolean;\n  adaptive: boolean;\n}) {\n  let { x, y } = roundOffsets(offsets);\n\n  const hasX = offsets.hasOwnProperty('x');\n  const hasY = offsets.hasOwnProperty('y');\n\n  let sideX: string = left;\n  let sideY: string = top;\n\n  const win: Window = window;\n\n  if (adaptive) {\n    let offsetParent = getOffsetParent(popper);\n    if (offsetParent === getWindow(popper)) {\n      offsetParent = getDocumentElement(popper);\n    }\n\n    // $FlowFixMe: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n    /* :: offsetParent = (offsetParent: Element); */\n\n    if (placement === top) {\n      sideY = bottom;\n      y -= offsetParent.clientHeight - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === left) {\n      sideX = right;\n      x -= offsetParent.clientWidth - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  const commonStyles = {\n    position,\n    ...(adaptive && unsetSides)\n  };\n\n  if (gpuAcceleration) {\n    return {\n      ...commonStyles,\n      [sideY]: hasY ? '0' : '',\n      [sideX]: hasX ? '0' : '',\n      // Layer acceleration can disable subpixel rendering which causes slightly\n      // blurry text on low PPI displays, so we want to use 2D transforms\n      // instead\n      transform: (win.devicePixelRatio || 1) < 2 ? `translate(${x}px, ${y}px)` : `translate3d(${x}px, ${y}px, 0)`\n    };\n  }\n\n  return {\n    ...commonStyles,\n    [sideY]: hasY ? `${y}px` : '',\n    [sideX]: hasX ? `${x}px` : '',\n    transform: ''\n  };\n}\n\n/**\n *\n */\nfunction computeStyles({ state, options }: ModifierArguments<Options>) {\n  const { gpuAcceleration = true, adaptive = true } = options;\n\n  if (false /* __DEV__*/) {\n    const transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || '';\n\n    if (\n      adaptive &&\n      ['transform', 'top', 'right', 'bottom', 'left'].some(property => transitionProperty.indexOf(property) >= 0)\n    ) {\n      console.warn(\n        [\n          'Popper: Detected CSS transitions on at least one of the following',\n          'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".',\n          '\\n\\n',\n          'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow',\n          'for smooth transitions, or remove these properties from the CSS',\n          'transition declaration on the popper element if only transitioning',\n          'opacity or background-color for example.',\n          '\\n\\n',\n          'We recommend using the popper element as a wrapper around an inner',\n          'element that can have any CSS property transitioned for animations.'\n        ].join(' ')\n      );\n    }\n  }\n\n  const commonStyles = {\n    placement: getBasePlacement(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = {\n      ...state.styles.popper,\n      ...mapToStyles({\n        ...commonStyles,\n        offsets: state.modifiersData.popperOffsets,\n        position: state.options.strategy,\n        adaptive\n      })\n    };\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = {\n      ...state.styles.arrow,\n      ...mapToStyles({\n        ...commonStyles,\n        offsets: state.modifiersData.arrow,\n        position: 'absolute',\n        adaptive: false\n      })\n    };\n  }\n\n  state.attributes.popper = {\n    ...state.attributes.popper,\n    'data-popper-placement': state.placement\n  };\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport type ComputeStylesModifier = Modifier<'computeStyles', Options>;\nexport default {\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n} as ComputeStylesModifier;\n"]},"metadata":{},"sourceType":"module"}