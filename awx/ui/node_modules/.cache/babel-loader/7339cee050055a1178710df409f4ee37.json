{"ast":null,"code":"import _objectSpread from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { untruncateYear, signedOffset, parseInteger, parseMillis, ianaRegex, isUndefined, parseFloating } from \"./util.js\";\nimport * as English from \"./english.js\";\nimport FixedOffsetZone from \"../zones/fixedOffsetZone.js\";\nimport IANAZone from \"../zones/IANAZone.js\";\n/*\n * This file handles parsing for well-specified formats. Here's how it works:\n * Two things go into parsing: a regex to match with and an extractor to take apart the groups in the match.\n * An extractor is just a function that takes a regex match array and returns a { year: ..., month: ... } object\n * parse() does the work of executing the regex and applying the extractor. It takes multiple regex/extractor pairs to try in sequence.\n * Extractors can take a \"cursor\" representing the offset in the match to look at. This makes it easy to combine extractors.\n * combineExtractors() does the work of combining them, keeping track of the cursor through multiple extractions.\n * Some extractions are super dumb and simpleParse and fromStrings help DRY them.\n */\n\nfunction combineRegexes() {\n  for (var _len = arguments.length, regexes = new Array(_len), _key = 0; _key < _len; _key++) {\n    regexes[_key] = arguments[_key];\n  }\n\n  var full = regexes.reduce(function (f, r) {\n    return f + r.source;\n  }, \"\");\n  return RegExp(\"^\".concat(full, \"$\"));\n}\n\nfunction combineExtractors() {\n  for (var _len2 = arguments.length, extractors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    extractors[_key2] = arguments[_key2];\n  }\n\n  return function (m) {\n    return extractors.reduce(function (_ref, ex) {\n      var _ref2 = _slicedToArray(_ref, 3),\n          mergedVals = _ref2[0],\n          mergedZone = _ref2[1],\n          cursor = _ref2[2];\n\n      var _ex = ex(m, cursor),\n          _ex2 = _slicedToArray(_ex, 3),\n          val = _ex2[0],\n          zone = _ex2[1],\n          next = _ex2[2];\n\n      return [_objectSpread(_objectSpread({}, mergedVals), val), zone || mergedZone, next];\n    }, [{}, null, 1]).slice(0, 2);\n  };\n}\n\nfunction parse(s) {\n  if (s == null) {\n    return [null, null];\n  }\n\n  for (var _len3 = arguments.length, patterns = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    patterns[_key3 - 1] = arguments[_key3];\n  }\n\n  for (var _i = 0, _patterns = patterns; _i < _patterns.length; _i++) {\n    var _patterns$_i = _slicedToArray(_patterns[_i], 2),\n        regex = _patterns$_i[0],\n        extractor = _patterns$_i[1];\n\n    var m = regex.exec(s);\n\n    if (m) {\n      return extractor(m);\n    }\n  }\n\n  return [null, null];\n}\n\nfunction simpleParse() {\n  for (var _len4 = arguments.length, keys = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    keys[_key4] = arguments[_key4];\n  }\n\n  return function (match, cursor) {\n    var ret = {};\n    var i;\n\n    for (i = 0; i < keys.length; i++) {\n      ret[keys[i]] = parseInteger(match[cursor + i]);\n    }\n\n    return [ret, null, cursor + i];\n  };\n} // ISO and SQL parsing\n\n\nvar offsetRegex = /(?:(Z)|([+-]\\d\\d)(?::?(\\d\\d))?)/;\nvar isoExtendedZone = \"(?:\".concat(offsetRegex.source, \"?(?:\\\\[(\").concat(ianaRegex.source, \")\\\\])?)?\");\nvar isoTimeBaseRegex = /(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:[.,](\\d{1,30}))?)?)?/;\nvar isoTimeRegex = RegExp(\"\".concat(isoTimeBaseRegex.source).concat(isoExtendedZone));\nvar isoTimeExtensionRegex = RegExp(\"(?:T\".concat(isoTimeRegex.source, \")?\"));\nvar isoYmdRegex = /([+-]\\d{6}|\\d{4})(?:-?(\\d\\d)(?:-?(\\d\\d))?)?/;\nvar isoWeekRegex = /(\\d{4})-?W(\\d\\d)(?:-?(\\d))?/;\nvar isoOrdinalRegex = /(\\d{4})-?(\\d{3})/;\nvar extractISOWeekData = simpleParse(\"weekYear\", \"weekNumber\", \"weekDay\");\nvar extractISOOrdinalData = simpleParse(\"year\", \"ordinal\");\nvar sqlYmdRegex = /(\\d{4})-(\\d\\d)-(\\d\\d)/; // dumbed-down version of the ISO one\n\nvar sqlTimeRegex = RegExp(\"\".concat(isoTimeBaseRegex.source, \" ?(?:\").concat(offsetRegex.source, \"|(\").concat(ianaRegex.source, \"))?\"));\nvar sqlTimeExtensionRegex = RegExp(\"(?: \".concat(sqlTimeRegex.source, \")?\"));\n\nfunction int(match, pos, fallback) {\n  var m = match[pos];\n  return isUndefined(m) ? fallback : parseInteger(m);\n}\n\nfunction extractISOYmd(match, cursor) {\n  var item = {\n    year: int(match, cursor),\n    month: int(match, cursor + 1, 1),\n    day: int(match, cursor + 2, 1)\n  };\n  return [item, null, cursor + 3];\n}\n\nfunction extractISOTime(match, cursor) {\n  var item = {\n    hours: int(match, cursor, 0),\n    minutes: int(match, cursor + 1, 0),\n    seconds: int(match, cursor + 2, 0),\n    milliseconds: parseMillis(match[cursor + 3])\n  };\n  return [item, null, cursor + 4];\n}\n\nfunction extractISOOffset(match, cursor) {\n  var local = !match[cursor] && !match[cursor + 1],\n      fullOffset = signedOffset(match[cursor + 1], match[cursor + 2]),\n      zone = local ? null : FixedOffsetZone.instance(fullOffset);\n  return [{}, zone, cursor + 3];\n}\n\nfunction extractIANAZone(match, cursor) {\n  var zone = match[cursor] ? IANAZone.create(match[cursor]) : null;\n  return [{}, zone, cursor + 1];\n} // ISO time parsing\n\n\nvar isoTimeOnly = RegExp(\"^T?\".concat(isoTimeBaseRegex.source, \"$\")); // ISO duration parsing\n\nvar isoDuration = /^-?P(?:(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)Y)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)M)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)W)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)D)?(?:T(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)H)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)M)?(?:(-?\\d{1,20})(?:[.,](-?\\d{1,20}))?S)?)?)$/;\n\nfunction extractISODuration(match) {\n  var _match = _slicedToArray(match, 9),\n      s = _match[0],\n      yearStr = _match[1],\n      monthStr = _match[2],\n      weekStr = _match[3],\n      dayStr = _match[4],\n      hourStr = _match[5],\n      minuteStr = _match[6],\n      secondStr = _match[7],\n      millisecondsStr = _match[8];\n\n  var hasNegativePrefix = s[0] === \"-\";\n  var negativeSeconds = secondStr && secondStr[0] === \"-\";\n\n  var maybeNegate = function maybeNegate(num) {\n    var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return num !== undefined && (force || num && hasNegativePrefix) ? -num : num;\n  };\n\n  return [{\n    years: maybeNegate(parseFloating(yearStr)),\n    months: maybeNegate(parseFloating(monthStr)),\n    weeks: maybeNegate(parseFloating(weekStr)),\n    days: maybeNegate(parseFloating(dayStr)),\n    hours: maybeNegate(parseFloating(hourStr)),\n    minutes: maybeNegate(parseFloating(minuteStr)),\n    seconds: maybeNegate(parseFloating(secondStr), secondStr === \"-0\"),\n    milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)\n  }];\n} // These are a little braindead. EDT *should* tell us that we're in, say, America/New_York\n// and not just that we're in -240 *right now*. But since I don't think these are used that often\n// I'm just going to ignore that\n\n\nvar obsOffsets = {\n  GMT: 0,\n  EDT: -4 * 60,\n  EST: -5 * 60,\n  CDT: -5 * 60,\n  CST: -6 * 60,\n  MDT: -6 * 60,\n  MST: -7 * 60,\n  PDT: -7 * 60,\n  PST: -8 * 60\n};\n\nfunction fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n  var result = {\n    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),\n    month: English.monthsShort.indexOf(monthStr) + 1,\n    day: parseInteger(dayStr),\n    hour: parseInteger(hourStr),\n    minute: parseInteger(minuteStr)\n  };\n  if (secondStr) result.second = parseInteger(secondStr);\n\n  if (weekdayStr) {\n    result.weekday = weekdayStr.length > 3 ? English.weekdaysLong.indexOf(weekdayStr) + 1 : English.weekdaysShort.indexOf(weekdayStr) + 1;\n  }\n\n  return result;\n} // RFC 2822/5322\n\n\nvar rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\\d\\d)(\\d\\d)))$/;\n\nfunction extractRFC2822(match) {\n  var _match2 = _slicedToArray(match, 12),\n      weekdayStr = _match2[1],\n      dayStr = _match2[2],\n      monthStr = _match2[3],\n      yearStr = _match2[4],\n      hourStr = _match2[5],\n      minuteStr = _match2[6],\n      secondStr = _match2[7],\n      obsOffset = _match2[8],\n      milOffset = _match2[9],\n      offHourStr = _match2[10],\n      offMinuteStr = _match2[11],\n      result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n\n  var offset;\n\n  if (obsOffset) {\n    offset = obsOffsets[obsOffset];\n  } else if (milOffset) {\n    offset = 0;\n  } else {\n    offset = signedOffset(offHourStr, offMinuteStr);\n  }\n\n  return [result, new FixedOffsetZone(offset)];\n}\n\nfunction preprocessRFC2822(s) {\n  // Remove comments and folding whitespace and replace multiple-spaces with a single space\n  return s.replace(/\\([^)]*\\)|[\\n\\t]/g, \" \").replace(/(\\s\\s+)/g, \" \").trim();\n} // http date\n\n\nvar rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\\d\\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4}) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,\n    rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\\d\\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,\n    ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \\d|\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) (\\d{4})$/;\n\nfunction extractRFC1123Or850(match) {\n  var _match3 = _slicedToArray(match, 8),\n      weekdayStr = _match3[1],\n      dayStr = _match3[2],\n      monthStr = _match3[3],\n      yearStr = _match3[4],\n      hourStr = _match3[5],\n      minuteStr = _match3[6],\n      secondStr = _match3[7],\n      result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n\n  return [result, FixedOffsetZone.utcInstance];\n}\n\nfunction extractASCII(match) {\n  var _match4 = _slicedToArray(match, 8),\n      weekdayStr = _match4[1],\n      monthStr = _match4[2],\n      dayStr = _match4[3],\n      hourStr = _match4[4],\n      minuteStr = _match4[5],\n      secondStr = _match4[6],\n      yearStr = _match4[7],\n      result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n\n  return [result, FixedOffsetZone.utcInstance];\n}\n\nvar isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);\nvar isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);\nvar isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);\nvar isoTimeCombinedRegex = combineRegexes(isoTimeRegex);\nvar extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);\nvar extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset, extractIANAZone);\nvar extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset, extractIANAZone);\nvar extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);\n/*\n * @private\n */\n\nexport function parseISODate(s) {\n  return parse(s, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);\n}\nexport function parseRFC2822Date(s) {\n  return parse(preprocessRFC2822(s), [rfc2822, extractRFC2822]);\n}\nexport function parseHTTPDate(s) {\n  return parse(s, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);\n}\nexport function parseISODuration(s) {\n  return parse(s, [isoDuration, extractISODuration]);\n}\nvar extractISOTimeOnly = combineExtractors(extractISOTime);\nexport function parseISOTimeOnly(s) {\n  return parse(s, [isoTimeOnly, extractISOTimeOnly]);\n}\nvar sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);\nvar sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);\nvar extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);\nexport function parseSQL(s) {\n  return parse(s, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);\n}","map":{"version":3,"sources":["/awx_devel/awx/ui/node_modules/luxon/src/impl/regexParser.js"],"names":["untruncateYear","signedOffset","parseInteger","parseMillis","ianaRegex","isUndefined","parseFloating","English","FixedOffsetZone","IANAZone","combineRegexes","regexes","full","reduce","f","r","source","RegExp","combineExtractors","extractors","m","ex","mergedVals","mergedZone","cursor","val","zone","next","slice","parse","s","patterns","regex","extractor","exec","simpleParse","keys","match","ret","i","length","offsetRegex","isoExtendedZone","isoTimeBaseRegex","isoTimeRegex","isoTimeExtensionRegex","isoYmdRegex","isoWeekRegex","isoOrdinalRegex","extractISOWeekData","extractISOOrdinalData","sqlYmdRegex","sqlTimeRegex","sqlTimeExtensionRegex","int","pos","fallback","extractISOYmd","item","year","month","day","extractISOTime","hours","minutes","seconds","milliseconds","extractISOOffset","local","fullOffset","instance","extractIANAZone","create","isoTimeOnly","isoDuration","extractISODuration","yearStr","monthStr","weekStr","dayStr","hourStr","minuteStr","secondStr","millisecondsStr","hasNegativePrefix","negativeSeconds","maybeNegate","num","force","undefined","years","months","weeks","days","obsOffsets","GMT","EDT","EST","CDT","CST","MDT","MST","PDT","PST","fromStrings","weekdayStr","result","monthsShort","indexOf","hour","minute","second","weekday","weekdaysLong","weekdaysShort","rfc2822","extractRFC2822","obsOffset","milOffset","offHourStr","offMinuteStr","offset","preprocessRFC2822","replace","trim","rfc1123","rfc850","ascii","extractRFC1123Or850","utcInstance","extractASCII","isoYmdWithTimeExtensionRegex","isoWeekWithTimeExtensionRegex","isoOrdinalWithTimeExtensionRegex","isoTimeCombinedRegex","extractISOYmdTimeAndOffset","extractISOWeekTimeAndOffset","extractISOOrdinalDateAndTime","extractISOTimeAndOffset","parseISODate","parseRFC2822Date","parseHTTPDate","parseISODuration","extractISOTimeOnly","parseISOTimeOnly","sqlYmdWithTimeExtensionRegex","sqlTimeCombinedRegex","extractISOTimeOffsetAndIANAZone","parseSQL"],"mappings":"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","sourcesContent":["import {\n  untruncateYear,\n  signedOffset,\n  parseInteger,\n  parseMillis,\n  ianaRegex,\n  isUndefined,\n  parseFloating,\n} from \"./util.js\";\nimport * as English from \"./english.js\";\nimport FixedOffsetZone from \"../zones/fixedOffsetZone.js\";\nimport IANAZone from \"../zones/IANAZone.js\";\n\n/*\n * This file handles parsing for well-specified formats. Here's how it works:\n * Two things go into parsing: a regex to match with and an extractor to take apart the groups in the match.\n * An extractor is just a function that takes a regex match array and returns a { year: ..., month: ... } object\n * parse() does the work of executing the regex and applying the extractor. It takes multiple regex/extractor pairs to try in sequence.\n * Extractors can take a \"cursor\" representing the offset in the match to look at. This makes it easy to combine extractors.\n * combineExtractors() does the work of combining them, keeping track of the cursor through multiple extractions.\n * Some extractions are super dumb and simpleParse and fromStrings help DRY them.\n */\n\nfunction combineRegexes(...regexes) {\n  const full = regexes.reduce((f, r) => f + r.source, \"\");\n  return RegExp(`^${full}$`);\n}\n\nfunction combineExtractors(...extractors) {\n  return (m) =>\n    extractors\n      .reduce(\n        ([mergedVals, mergedZone, cursor], ex) => {\n          const [val, zone, next] = ex(m, cursor);\n          return [{ ...mergedVals, ...val }, zone || mergedZone, next];\n        },\n        [{}, null, 1]\n      )\n      .slice(0, 2);\n}\n\nfunction parse(s, ...patterns) {\n  if (s == null) {\n    return [null, null];\n  }\n\n  for (const [regex, extractor] of patterns) {\n    const m = regex.exec(s);\n    if (m) {\n      return extractor(m);\n    }\n  }\n  return [null, null];\n}\n\nfunction simpleParse(...keys) {\n  return (match, cursor) => {\n    const ret = {};\n    let i;\n\n    for (i = 0; i < keys.length; i++) {\n      ret[keys[i]] = parseInteger(match[cursor + i]);\n    }\n    return [ret, null, cursor + i];\n  };\n}\n\n// ISO and SQL parsing\nconst offsetRegex = /(?:(Z)|([+-]\\d\\d)(?::?(\\d\\d))?)/;\nconst isoExtendedZone = `(?:${offsetRegex.source}?(?:\\\\[(${ianaRegex.source})\\\\])?)?`;\nconst isoTimeBaseRegex = /(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:[.,](\\d{1,30}))?)?)?/;\nconst isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);\nconst isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);\nconst isoYmdRegex = /([+-]\\d{6}|\\d{4})(?:-?(\\d\\d)(?:-?(\\d\\d))?)?/;\nconst isoWeekRegex = /(\\d{4})-?W(\\d\\d)(?:-?(\\d))?/;\nconst isoOrdinalRegex = /(\\d{4})-?(\\d{3})/;\nconst extractISOWeekData = simpleParse(\"weekYear\", \"weekNumber\", \"weekDay\");\nconst extractISOOrdinalData = simpleParse(\"year\", \"ordinal\");\nconst sqlYmdRegex = /(\\d{4})-(\\d\\d)-(\\d\\d)/; // dumbed-down version of the ISO one\nconst sqlTimeRegex = RegExp(\n  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`\n);\nconst sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);\n\nfunction int(match, pos, fallback) {\n  const m = match[pos];\n  return isUndefined(m) ? fallback : parseInteger(m);\n}\n\nfunction extractISOYmd(match, cursor) {\n  const item = {\n    year: int(match, cursor),\n    month: int(match, cursor + 1, 1),\n    day: int(match, cursor + 2, 1),\n  };\n\n  return [item, null, cursor + 3];\n}\n\nfunction extractISOTime(match, cursor) {\n  const item = {\n    hours: int(match, cursor, 0),\n    minutes: int(match, cursor + 1, 0),\n    seconds: int(match, cursor + 2, 0),\n    milliseconds: parseMillis(match[cursor + 3]),\n  };\n\n  return [item, null, cursor + 4];\n}\n\nfunction extractISOOffset(match, cursor) {\n  const local = !match[cursor] && !match[cursor + 1],\n    fullOffset = signedOffset(match[cursor + 1], match[cursor + 2]),\n    zone = local ? null : FixedOffsetZone.instance(fullOffset);\n  return [{}, zone, cursor + 3];\n}\n\nfunction extractIANAZone(match, cursor) {\n  const zone = match[cursor] ? IANAZone.create(match[cursor]) : null;\n  return [{}, zone, cursor + 1];\n}\n\n// ISO time parsing\n\nconst isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);\n\n// ISO duration parsing\n\nconst isoDuration =\n  /^-?P(?:(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)Y)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)M)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)W)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)D)?(?:T(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)H)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)M)?(?:(-?\\d{1,20})(?:[.,](-?\\d{1,20}))?S)?)?)$/;\n\nfunction extractISODuration(match) {\n  const [s, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] =\n    match;\n\n  const hasNegativePrefix = s[0] === \"-\";\n  const negativeSeconds = secondStr && secondStr[0] === \"-\";\n\n  const maybeNegate = (num, force = false) =>\n    num !== undefined && (force || (num && hasNegativePrefix)) ? -num : num;\n\n  return [\n    {\n      years: maybeNegate(parseFloating(yearStr)),\n      months: maybeNegate(parseFloating(monthStr)),\n      weeks: maybeNegate(parseFloating(weekStr)),\n      days: maybeNegate(parseFloating(dayStr)),\n      hours: maybeNegate(parseFloating(hourStr)),\n      minutes: maybeNegate(parseFloating(minuteStr)),\n      seconds: maybeNegate(parseFloating(secondStr), secondStr === \"-0\"),\n      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds),\n    },\n  ];\n}\n\n// These are a little braindead. EDT *should* tell us that we're in, say, America/New_York\n// and not just that we're in -240 *right now*. But since I don't think these are used that often\n// I'm just going to ignore that\nconst obsOffsets = {\n  GMT: 0,\n  EDT: -4 * 60,\n  EST: -5 * 60,\n  CDT: -5 * 60,\n  CST: -6 * 60,\n  MDT: -6 * 60,\n  MST: -7 * 60,\n  PDT: -7 * 60,\n  PST: -8 * 60,\n};\n\nfunction fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n  const result = {\n    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),\n    month: English.monthsShort.indexOf(monthStr) + 1,\n    day: parseInteger(dayStr),\n    hour: parseInteger(hourStr),\n    minute: parseInteger(minuteStr),\n  };\n\n  if (secondStr) result.second = parseInteger(secondStr);\n  if (weekdayStr) {\n    result.weekday =\n      weekdayStr.length > 3\n        ? English.weekdaysLong.indexOf(weekdayStr) + 1\n        : English.weekdaysShort.indexOf(weekdayStr) + 1;\n  }\n\n  return result;\n}\n\n// RFC 2822/5322\nconst rfc2822 =\n  /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\\d\\d)(\\d\\d)))$/;\n\nfunction extractRFC2822(match) {\n  const [\n      ,\n      weekdayStr,\n      dayStr,\n      monthStr,\n      yearStr,\n      hourStr,\n      minuteStr,\n      secondStr,\n      obsOffset,\n      milOffset,\n      offHourStr,\n      offMinuteStr,\n    ] = match,\n    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n\n  let offset;\n  if (obsOffset) {\n    offset = obsOffsets[obsOffset];\n  } else if (milOffset) {\n    offset = 0;\n  } else {\n    offset = signedOffset(offHourStr, offMinuteStr);\n  }\n\n  return [result, new FixedOffsetZone(offset)];\n}\n\nfunction preprocessRFC2822(s) {\n  // Remove comments and folding whitespace and replace multiple-spaces with a single space\n  return s\n    .replace(/\\([^)]*\\)|[\\n\\t]/g, \" \")\n    .replace(/(\\s\\s+)/g, \" \")\n    .trim();\n}\n\n// http date\n\nconst rfc1123 =\n    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\\d\\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4}) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,\n  rfc850 =\n    /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\\d\\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,\n  ascii =\n    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \\d|\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) (\\d{4})$/;\n\nfunction extractRFC1123Or850(match) {\n  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match,\n    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n  return [result, FixedOffsetZone.utcInstance];\n}\n\nfunction extractASCII(match) {\n  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match,\n    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n  return [result, FixedOffsetZone.utcInstance];\n}\n\nconst isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);\nconst isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);\nconst isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);\nconst isoTimeCombinedRegex = combineRegexes(isoTimeRegex);\n\nconst extractISOYmdTimeAndOffset = combineExtractors(\n  extractISOYmd,\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\nconst extractISOWeekTimeAndOffset = combineExtractors(\n  extractISOWeekData,\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\nconst extractISOOrdinalDateAndTime = combineExtractors(\n  extractISOOrdinalData,\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\nconst extractISOTimeAndOffset = combineExtractors(\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\n\n/*\n * @private\n */\n\nexport function parseISODate(s) {\n  return parse(\n    s,\n    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],\n    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],\n    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],\n    [isoTimeCombinedRegex, extractISOTimeAndOffset]\n  );\n}\n\nexport function parseRFC2822Date(s) {\n  return parse(preprocessRFC2822(s), [rfc2822, extractRFC2822]);\n}\n\nexport function parseHTTPDate(s) {\n  return parse(\n    s,\n    [rfc1123, extractRFC1123Or850],\n    [rfc850, extractRFC1123Or850],\n    [ascii, extractASCII]\n  );\n}\n\nexport function parseISODuration(s) {\n  return parse(s, [isoDuration, extractISODuration]);\n}\n\nconst extractISOTimeOnly = combineExtractors(extractISOTime);\n\nexport function parseISOTimeOnly(s) {\n  return parse(s, [isoTimeOnly, extractISOTimeOnly]);\n}\n\nconst sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);\nconst sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);\n\nconst extractISOTimeOffsetAndIANAZone = combineExtractors(\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\n\nexport function parseSQL(s) {\n  return parse(\n    s,\n    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],\n    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]\n  );\n}\n"]},"metadata":{},"sourceType":"module"}