{"ast":null,"code":"import _slicedToArray from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _objectWithoutProperties from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"base\"],\n    _excluded2 = [\"padTo\", \"floor\"];\nimport { padStart, roundTo, hasRelative } from \"./util.js\";\nimport * as English from \"./english.js\";\nimport Settings from \"../settings.js\";\nimport DateTime from \"../datetime.js\";\nimport IANAZone from \"../zones/IANAZone.js\"; // todo - remap caching\n\nvar intlLFCache = {};\n\nfunction getCachedLF(locString) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var key = JSON.stringify([locString, opts]);\n  var dtf = intlLFCache[key];\n\n  if (!dtf) {\n    dtf = new Intl.ListFormat(locString, opts);\n    intlLFCache[key] = dtf;\n  }\n\n  return dtf;\n}\n\nvar intlDTCache = {};\n\nfunction getCachedDTF(locString) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var key = JSON.stringify([locString, opts]);\n  var dtf = intlDTCache[key];\n\n  if (!dtf) {\n    dtf = new Intl.DateTimeFormat(locString, opts);\n    intlDTCache[key] = dtf;\n  }\n\n  return dtf;\n}\n\nvar intlNumCache = {};\n\nfunction getCachedINF(locString) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var key = JSON.stringify([locString, opts]);\n  var inf = intlNumCache[key];\n\n  if (!inf) {\n    inf = new Intl.NumberFormat(locString, opts);\n    intlNumCache[key] = inf;\n  }\n\n  return inf;\n}\n\nvar intlRelCache = {};\n\nfunction getCachedRTF(locString) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var base = opts.base,\n      cacheKeyOpts = _objectWithoutProperties(opts, _excluded); // exclude `base` from the options\n\n\n  var key = JSON.stringify([locString, cacheKeyOpts]);\n  var inf = intlRelCache[key];\n\n  if (!inf) {\n    inf = new Intl.RelativeTimeFormat(locString, opts);\n    intlRelCache[key] = inf;\n  }\n\n  return inf;\n}\n\nvar sysLocaleCache = null;\n\nfunction systemLocale() {\n  if (sysLocaleCache) {\n    return sysLocaleCache;\n  } else {\n    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;\n    return sysLocaleCache;\n  }\n}\n\nfunction parseLocaleString(localeStr) {\n  // I really want to avoid writing a BCP 47 parser\n  // see, e.g. https://github.com/wooorm/bcp-47\n  // Instead, we'll do this:\n  // a) if the string has no -u extensions, just leave it alone\n  // b) if it does, use Intl to resolve everything\n  // c) if Intl fails, try again without the -u\n  var uIndex = localeStr.indexOf(\"-u-\");\n\n  if (uIndex === -1) {\n    return [localeStr];\n  } else {\n    var options;\n    var smaller = localeStr.substring(0, uIndex);\n\n    try {\n      options = getCachedDTF(localeStr).resolvedOptions();\n    } catch (e) {\n      options = getCachedDTF(smaller).resolvedOptions();\n    }\n\n    var _options = options,\n        numberingSystem = _options.numberingSystem,\n        calendar = _options.calendar; // return the smaller one so that we can append the calendar and numbering overrides to it\n\n    return [smaller, numberingSystem, calendar];\n  }\n}\n\nfunction intlConfigString(localeStr, numberingSystem, outputCalendar) {\n  if (outputCalendar || numberingSystem) {\n    localeStr += \"-u\";\n\n    if (outputCalendar) {\n      localeStr += \"-ca-\".concat(outputCalendar);\n    }\n\n    if (numberingSystem) {\n      localeStr += \"-nu-\".concat(numberingSystem);\n    }\n\n    return localeStr;\n  } else {\n    return localeStr;\n  }\n}\n\nfunction mapMonths(f) {\n  var ms = [];\n\n  for (var i = 1; i <= 12; i++) {\n    var dt = DateTime.utc(2016, i, 1);\n    ms.push(f(dt));\n  }\n\n  return ms;\n}\n\nfunction mapWeekdays(f) {\n  var ms = [];\n\n  for (var i = 1; i <= 7; i++) {\n    var dt = DateTime.utc(2016, 11, 13 + i);\n    ms.push(f(dt));\n  }\n\n  return ms;\n}\n\nfunction listStuff(loc, length, defaultOK, englishFn, intlFn) {\n  var mode = loc.listingMode(defaultOK);\n\n  if (mode === \"error\") {\n    return null;\n  } else if (mode === \"en\") {\n    return englishFn(length);\n  } else {\n    return intlFn(length);\n  }\n}\n\nfunction supportsFastNumbers(loc) {\n  if (loc.numberingSystem && loc.numberingSystem !== \"latn\") {\n    return false;\n  } else {\n    return loc.numberingSystem === \"latn\" || !loc.locale || loc.locale.startsWith(\"en\") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === \"latn\";\n  }\n}\n/**\n * @private\n */\n\n\nvar PolyNumberFormatter = /*#__PURE__*/function () {\n  function PolyNumberFormatter(intl, forceSimple, opts) {\n    _classCallCheck(this, PolyNumberFormatter);\n\n    this.padTo = opts.padTo || 0;\n    this.floor = opts.floor || false;\n\n    var padTo = opts.padTo,\n        floor = opts.floor,\n        otherOpts = _objectWithoutProperties(opts, _excluded2);\n\n    if (!forceSimple || Object.keys(otherOpts).length > 0) {\n      var intlOpts = _objectSpread({\n        useGrouping: false\n      }, opts);\n\n      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;\n      this.inf = getCachedINF(intl, intlOpts);\n    }\n  }\n\n  _createClass(PolyNumberFormatter, [{\n    key: \"format\",\n    value: function format(i) {\n      if (this.inf) {\n        var fixed = this.floor ? Math.floor(i) : i;\n        return this.inf.format(fixed);\n      } else {\n        // to match the browser's numberformatter defaults\n        var _fixed = this.floor ? Math.floor(i) : roundTo(i, 3);\n\n        return padStart(_fixed, this.padTo);\n      }\n    }\n  }]);\n\n  return PolyNumberFormatter;\n}();\n/**\n * @private\n */\n\n\nvar PolyDateFormatter = /*#__PURE__*/function () {\n  function PolyDateFormatter(dt, intl, opts) {\n    _classCallCheck(this, PolyDateFormatter);\n\n    this.opts = opts;\n    var z;\n\n    if (dt.zone.isUniversal) {\n      // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.\n      // That is why fixed-offset TZ is set to that unless it is:\n      // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.\n      // 2. Unsupported by the browser:\n      //    - some do not support Etc/\n      //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata\n      var gmtOffset = -1 * (dt.offset / 60);\n      var offsetZ = gmtOffset >= 0 ? \"Etc/GMT+\".concat(gmtOffset) : \"Etc/GMT\".concat(gmtOffset);\n\n      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {\n        z = offsetZ;\n        this.dt = dt;\n      } else {\n        // Not all fixed-offset zones like Etc/+4:30 are present in tzdata.\n        // So we have to make do. Two cases:\n        // 1. The format options tell us to show the zone. We can't do that, so the best\n        // we can do is format the date in UTC.\n        // 2. The format options don't tell us to show the zone. Then we can adjust them\n        // the time and tell the formatter to show it to us in UTC, so that the time is right\n        // and the bad zone doesn't show up.\n        z = \"UTC\";\n\n        if (opts.timeZoneName) {\n          this.dt = dt;\n        } else {\n          this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1000);\n        }\n      }\n    } else if (dt.zone.type === \"system\") {\n      this.dt = dt;\n    } else {\n      this.dt = dt;\n      z = dt.zone.name;\n    }\n\n    var intlOpts = _objectSpread({}, this.opts);\n\n    if (z) {\n      intlOpts.timeZone = z;\n    }\n\n    this.dtf = getCachedDTF(intl, intlOpts);\n  }\n\n  _createClass(PolyDateFormatter, [{\n    key: \"format\",\n    value: function format() {\n      return this.dtf.format(this.dt.toJSDate());\n    }\n  }, {\n    key: \"formatToParts\",\n    value: function formatToParts() {\n      return this.dtf.formatToParts(this.dt.toJSDate());\n    }\n  }, {\n    key: \"resolvedOptions\",\n    value: function resolvedOptions() {\n      return this.dtf.resolvedOptions();\n    }\n  }]);\n\n  return PolyDateFormatter;\n}();\n/**\n * @private\n */\n\n\nvar PolyRelFormatter = /*#__PURE__*/function () {\n  function PolyRelFormatter(intl, isEnglish, opts) {\n    _classCallCheck(this, PolyRelFormatter);\n\n    this.opts = _objectSpread({\n      style: \"long\"\n    }, opts);\n\n    if (!isEnglish && hasRelative()) {\n      this.rtf = getCachedRTF(intl, opts);\n    }\n  }\n\n  _createClass(PolyRelFormatter, [{\n    key: \"format\",\n    value: function format(count, unit) {\n      if (this.rtf) {\n        return this.rtf.format(count, unit);\n      } else {\n        return English.formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== \"long\");\n      }\n    }\n  }, {\n    key: \"formatToParts\",\n    value: function formatToParts(count, unit) {\n      if (this.rtf) {\n        return this.rtf.formatToParts(count, unit);\n      } else {\n        return [];\n      }\n    }\n  }]);\n\n  return PolyRelFormatter;\n}();\n/**\n * @private\n */\n\n\nvar Locale = /*#__PURE__*/function () {\n  function Locale(locale, numbering, outputCalendar, specifiedLocale) {\n    _classCallCheck(this, Locale);\n\n    var _parseLocaleString = parseLocaleString(locale),\n        _parseLocaleString2 = _slicedToArray(_parseLocaleString, 3),\n        parsedLocale = _parseLocaleString2[0],\n        parsedNumberingSystem = _parseLocaleString2[1],\n        parsedOutputCalendar = _parseLocaleString2[2];\n\n    this.locale = parsedLocale;\n    this.numberingSystem = numbering || parsedNumberingSystem || null;\n    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;\n    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);\n    this.weekdaysCache = {\n      format: {},\n      standalone: {}\n    };\n    this.monthsCache = {\n      format: {},\n      standalone: {}\n    };\n    this.meridiemCache = null;\n    this.eraCache = {};\n    this.specifiedLocale = specifiedLocale;\n    this.fastNumbersCached = null;\n  }\n\n  _createClass(Locale, [{\n    key: \"fastNumbers\",\n    get: function get() {\n      if (this.fastNumbersCached == null) {\n        this.fastNumbersCached = supportsFastNumbers(this);\n      }\n\n      return this.fastNumbersCached;\n    }\n  }, {\n    key: \"listingMode\",\n    value: function listingMode() {\n      var isActuallyEn = this.isEnglish();\n      var hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === \"latn\") && (this.outputCalendar === null || this.outputCalendar === \"gregory\");\n      return isActuallyEn && hasNoWeirdness ? \"en\" : \"intl\";\n    }\n  }, {\n    key: \"clone\",\n    value: function clone(alts) {\n      if (!alts || Object.getOwnPropertyNames(alts).length === 0) {\n        return this;\n      } else {\n        return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);\n      }\n    }\n  }, {\n    key: \"redefaultToEN\",\n    value: function redefaultToEN() {\n      var alts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.clone(_objectSpread(_objectSpread({}, alts), {}, {\n        defaultToEN: true\n      }));\n    }\n  }, {\n    key: \"redefaultToSystem\",\n    value: function redefaultToSystem() {\n      var alts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.clone(_objectSpread(_objectSpread({}, alts), {}, {\n        defaultToEN: false\n      }));\n    }\n  }, {\n    key: \"months\",\n    value: function months(length) {\n      var _this = this;\n\n      var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var defaultOK = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      return listStuff(this, length, defaultOK, English.months, function () {\n        var intl = format ? {\n          month: length,\n          day: \"numeric\"\n        } : {\n          month: length\n        },\n            formatStr = format ? \"format\" : \"standalone\";\n\n        if (!_this.monthsCache[formatStr][length]) {\n          _this.monthsCache[formatStr][length] = mapMonths(function (dt) {\n            return _this.extract(dt, intl, \"month\");\n          });\n        }\n\n        return _this.monthsCache[formatStr][length];\n      });\n    }\n  }, {\n    key: \"weekdays\",\n    value: function weekdays(length) {\n      var _this2 = this;\n\n      var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var defaultOK = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      return listStuff(this, length, defaultOK, English.weekdays, function () {\n        var intl = format ? {\n          weekday: length,\n          year: \"numeric\",\n          month: \"long\",\n          day: \"numeric\"\n        } : {\n          weekday: length\n        },\n            formatStr = format ? \"format\" : \"standalone\";\n\n        if (!_this2.weekdaysCache[formatStr][length]) {\n          _this2.weekdaysCache[formatStr][length] = mapWeekdays(function (dt) {\n            return _this2.extract(dt, intl, \"weekday\");\n          });\n        }\n\n        return _this2.weekdaysCache[formatStr][length];\n      });\n    }\n  }, {\n    key: \"meridiems\",\n    value: function meridiems() {\n      var _this3 = this;\n\n      var defaultOK = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return listStuff(this, undefined, defaultOK, function () {\n        return English.meridiems;\n      }, function () {\n        // In theory there could be aribitrary day periods. We're gonna assume there are exactly two\n        // for AM and PM. This is probably wrong, but it's makes parsing way easier.\n        if (!_this3.meridiemCache) {\n          var intl = {\n            hour: \"numeric\",\n            hourCycle: \"h12\"\n          };\n          _this3.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(function (dt) {\n            return _this3.extract(dt, intl, \"dayperiod\");\n          });\n        }\n\n        return _this3.meridiemCache;\n      });\n    }\n  }, {\n    key: \"eras\",\n    value: function eras(length) {\n      var _this4 = this;\n\n      var defaultOK = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return listStuff(this, length, defaultOK, English.eras, function () {\n        var intl = {\n          era: length\n        }; // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates\n        // to definitely enumerate them.\n\n        if (!_this4.eraCache[length]) {\n          _this4.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(function (dt) {\n            return _this4.extract(dt, intl, \"era\");\n          });\n        }\n\n        return _this4.eraCache[length];\n      });\n    }\n  }, {\n    key: \"extract\",\n    value: function extract(dt, intlOpts, field) {\n      var df = this.dtFormatter(dt, intlOpts),\n          results = df.formatToParts(),\n          matching = results.find(function (m) {\n        return m.type.toLowerCase() === field;\n      });\n      return matching ? matching.value : null;\n    }\n  }, {\n    key: \"numberFormatter\",\n    value: function numberFormatter() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)\n      // (in contrast, the rest of the condition is used heavily)\n      return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);\n    }\n  }, {\n    key: \"dtFormatter\",\n    value: function dtFormatter(dt) {\n      var intlOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return new PolyDateFormatter(dt, this.intl, intlOpts);\n    }\n  }, {\n    key: \"relFormatter\",\n    value: function relFormatter() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return new PolyRelFormatter(this.intl, this.isEnglish(), opts);\n    }\n  }, {\n    key: \"listFormatter\",\n    value: function listFormatter() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return getCachedLF(this.intl, opts);\n    }\n  }, {\n    key: \"isEnglish\",\n    value: function isEnglish() {\n      return this.locale === \"en\" || this.locale.toLowerCase() === \"en-us\" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith(\"en-us\");\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;\n    }\n  }], [{\n    key: \"fromOpts\",\n    value: function fromOpts(opts) {\n      return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);\n    }\n  }, {\n    key: \"create\",\n    value: function create(locale, numberingSystem, outputCalendar) {\n      var defaultToEN = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var specifiedLocale = locale || Settings.defaultLocale; // the system locale is useful for human readable strings but annoying for parsing/formatting known formats\n\n      var localeR = specifiedLocale || (defaultToEN ? \"en-US\" : systemLocale());\n      var numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;\n      var outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;\n      return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);\n    }\n  }, {\n    key: \"resetCache\",\n    value: function resetCache() {\n      sysLocaleCache = null;\n      intlDTCache = {};\n      intlNumCache = {};\n      intlRelCache = {};\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          locale = _ref.locale,\n          numberingSystem = _ref.numberingSystem,\n          outputCalendar = _ref.outputCalendar;\n\n      return Locale.create(locale, numberingSystem, outputCalendar);\n    }\n  }]);\n\n  return Locale;\n}();\n\nexport { Locale as default };","map":{"version":3,"sources":["/awx_devel/awx/ui/node_modules/luxon/src/impl/locale.js"],"names":["padStart","roundTo","hasRelative","English","Settings","DateTime","IANAZone","intlLFCache","getCachedLF","locString","opts","key","JSON","stringify","dtf","Intl","ListFormat","intlDTCache","getCachedDTF","DateTimeFormat","intlNumCache","getCachedINF","inf","NumberFormat","intlRelCache","getCachedRTF","base","cacheKeyOpts","RelativeTimeFormat","sysLocaleCache","systemLocale","resolvedOptions","locale","parseLocaleString","localeStr","uIndex","indexOf","options","smaller","substring","e","numberingSystem","calendar","intlConfigString","outputCalendar","mapMonths","f","ms","i","dt","utc","push","mapWeekdays","listStuff","loc","length","defaultOK","englishFn","intlFn","mode","listingMode","supportsFastNumbers","startsWith","intl","PolyNumberFormatter","forceSimple","padTo","floor","otherOpts","Object","keys","intlOpts","useGrouping","minimumIntegerDigits","fixed","Math","format","PolyDateFormatter","z","zone","isUniversal","gmtOffset","offset","offsetZ","create","valid","timeZoneName","fromMillis","ts","type","name","timeZone","toJSDate","formatToParts","PolyRelFormatter","isEnglish","style","rtf","count","unit","formatRelativeTime","numeric","Locale","numbering","specifiedLocale","parsedLocale","parsedNumberingSystem","parsedOutputCalendar","weekdaysCache","standalone","monthsCache","meridiemCache","eraCache","fastNumbersCached","isActuallyEn","hasNoWeirdness","alts","getOwnPropertyNames","defaultToEN","clone","months","month","day","formatStr","extract","weekdays","weekday","year","undefined","meridiems","hour","hourCycle","map","eras","era","field","df","dtFormatter","results","matching","find","m","toLowerCase","value","fastNumbers","other","defaultLocale","localeR","numberingSystemR","defaultNumberingSystem","outputCalendarR","defaultOutputCalendar"],"mappings":"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","sourcesContent":["import { padStart, roundTo, hasRelative } from \"./util.js\";\nimport * as English from \"./english.js\";\nimport Settings from \"../settings.js\";\nimport DateTime from \"../datetime.js\";\nimport IANAZone from \"../zones/IANAZone.js\";\n\n// todo - remap caching\n\nlet intlLFCache = {};\nfunction getCachedLF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlLFCache[key];\n  if (!dtf) {\n    dtf = new Intl.ListFormat(locString, opts);\n    intlLFCache[key] = dtf;\n  }\n  return dtf;\n}\n\nlet intlDTCache = {};\nfunction getCachedDTF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlDTCache[key];\n  if (!dtf) {\n    dtf = new Intl.DateTimeFormat(locString, opts);\n    intlDTCache[key] = dtf;\n  }\n  return dtf;\n}\n\nlet intlNumCache = {};\nfunction getCachedINF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let inf = intlNumCache[key];\n  if (!inf) {\n    inf = new Intl.NumberFormat(locString, opts);\n    intlNumCache[key] = inf;\n  }\n  return inf;\n}\n\nlet intlRelCache = {};\nfunction getCachedRTF(locString, opts = {}) {\n  const { base, ...cacheKeyOpts } = opts; // exclude `base` from the options\n  const key = JSON.stringify([locString, cacheKeyOpts]);\n  let inf = intlRelCache[key];\n  if (!inf) {\n    inf = new Intl.RelativeTimeFormat(locString, opts);\n    intlRelCache[key] = inf;\n  }\n  return inf;\n}\n\nlet sysLocaleCache = null;\nfunction systemLocale() {\n  if (sysLocaleCache) {\n    return sysLocaleCache;\n  } else {\n    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;\n    return sysLocaleCache;\n  }\n}\n\nfunction parseLocaleString(localeStr) {\n  // I really want to avoid writing a BCP 47 parser\n  // see, e.g. https://github.com/wooorm/bcp-47\n  // Instead, we'll do this:\n\n  // a) if the string has no -u extensions, just leave it alone\n  // b) if it does, use Intl to resolve everything\n  // c) if Intl fails, try again without the -u\n\n  const uIndex = localeStr.indexOf(\"-u-\");\n  if (uIndex === -1) {\n    return [localeStr];\n  } else {\n    let options;\n    const smaller = localeStr.substring(0, uIndex);\n    try {\n      options = getCachedDTF(localeStr).resolvedOptions();\n    } catch (e) {\n      options = getCachedDTF(smaller).resolvedOptions();\n    }\n\n    const { numberingSystem, calendar } = options;\n    // return the smaller one so that we can append the calendar and numbering overrides to it\n    return [smaller, numberingSystem, calendar];\n  }\n}\n\nfunction intlConfigString(localeStr, numberingSystem, outputCalendar) {\n  if (outputCalendar || numberingSystem) {\n    localeStr += \"-u\";\n\n    if (outputCalendar) {\n      localeStr += `-ca-${outputCalendar}`;\n    }\n\n    if (numberingSystem) {\n      localeStr += `-nu-${numberingSystem}`;\n    }\n    return localeStr;\n  } else {\n    return localeStr;\n  }\n}\n\nfunction mapMonths(f) {\n  const ms = [];\n  for (let i = 1; i <= 12; i++) {\n    const dt = DateTime.utc(2016, i, 1);\n    ms.push(f(dt));\n  }\n  return ms;\n}\n\nfunction mapWeekdays(f) {\n  const ms = [];\n  for (let i = 1; i <= 7; i++) {\n    const dt = DateTime.utc(2016, 11, 13 + i);\n    ms.push(f(dt));\n  }\n  return ms;\n}\n\nfunction listStuff(loc, length, defaultOK, englishFn, intlFn) {\n  const mode = loc.listingMode(defaultOK);\n\n  if (mode === \"error\") {\n    return null;\n  } else if (mode === \"en\") {\n    return englishFn(length);\n  } else {\n    return intlFn(length);\n  }\n}\n\nfunction supportsFastNumbers(loc) {\n  if (loc.numberingSystem && loc.numberingSystem !== \"latn\") {\n    return false;\n  } else {\n    return (\n      loc.numberingSystem === \"latn\" ||\n      !loc.locale ||\n      loc.locale.startsWith(\"en\") ||\n      new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === \"latn\"\n    );\n  }\n}\n\n/**\n * @private\n */\n\nclass PolyNumberFormatter {\n  constructor(intl, forceSimple, opts) {\n    this.padTo = opts.padTo || 0;\n    this.floor = opts.floor || false;\n\n    const { padTo, floor, ...otherOpts } = opts;\n\n    if (!forceSimple || Object.keys(otherOpts).length > 0) {\n      const intlOpts = { useGrouping: false, ...opts };\n      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;\n      this.inf = getCachedINF(intl, intlOpts);\n    }\n  }\n\n  format(i) {\n    if (this.inf) {\n      const fixed = this.floor ? Math.floor(i) : i;\n      return this.inf.format(fixed);\n    } else {\n      // to match the browser's numberformatter defaults\n      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);\n      return padStart(fixed, this.padTo);\n    }\n  }\n}\n\n/**\n * @private\n */\n\nclass PolyDateFormatter {\n  constructor(dt, intl, opts) {\n    this.opts = opts;\n\n    let z;\n    if (dt.zone.isUniversal) {\n      // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.\n      // That is why fixed-offset TZ is set to that unless it is:\n      // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.\n      // 2. Unsupported by the browser:\n      //    - some do not support Etc/\n      //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata\n      const gmtOffset = -1 * (dt.offset / 60);\n      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;\n      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {\n        z = offsetZ;\n        this.dt = dt;\n      } else {\n        // Not all fixed-offset zones like Etc/+4:30 are present in tzdata.\n        // So we have to make do. Two cases:\n        // 1. The format options tell us to show the zone. We can't do that, so the best\n        // we can do is format the date in UTC.\n        // 2. The format options don't tell us to show the zone. Then we can adjust them\n        // the time and tell the formatter to show it to us in UTC, so that the time is right\n        // and the bad zone doesn't show up.\n        z = \"UTC\";\n        if (opts.timeZoneName) {\n          this.dt = dt;\n        } else {\n          this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1000);\n        }\n      }\n    } else if (dt.zone.type === \"system\") {\n      this.dt = dt;\n    } else {\n      this.dt = dt;\n      z = dt.zone.name;\n    }\n\n    const intlOpts = { ...this.opts };\n    if (z) {\n      intlOpts.timeZone = z;\n    }\n    this.dtf = getCachedDTF(intl, intlOpts);\n  }\n\n  format() {\n    return this.dtf.format(this.dt.toJSDate());\n  }\n\n  formatToParts() {\n    return this.dtf.formatToParts(this.dt.toJSDate());\n  }\n\n  resolvedOptions() {\n    return this.dtf.resolvedOptions();\n  }\n}\n\n/**\n * @private\n */\nclass PolyRelFormatter {\n  constructor(intl, isEnglish, opts) {\n    this.opts = { style: \"long\", ...opts };\n    if (!isEnglish && hasRelative()) {\n      this.rtf = getCachedRTF(intl, opts);\n    }\n  }\n\n  format(count, unit) {\n    if (this.rtf) {\n      return this.rtf.format(count, unit);\n    } else {\n      return English.formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== \"long\");\n    }\n  }\n\n  formatToParts(count, unit) {\n    if (this.rtf) {\n      return this.rtf.formatToParts(count, unit);\n    } else {\n      return [];\n    }\n  }\n}\n\n/**\n * @private\n */\n\nexport default class Locale {\n  static fromOpts(opts) {\n    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);\n  }\n\n  static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {\n    const specifiedLocale = locale || Settings.defaultLocale;\n    // the system locale is useful for human readable strings but annoying for parsing/formatting known formats\n    const localeR = specifiedLocale || (defaultToEN ? \"en-US\" : systemLocale());\n    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;\n    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;\n    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);\n  }\n\n  static resetCache() {\n    sysLocaleCache = null;\n    intlDTCache = {};\n    intlNumCache = {};\n    intlRelCache = {};\n  }\n\n  static fromObject({ locale, numberingSystem, outputCalendar } = {}) {\n    return Locale.create(locale, numberingSystem, outputCalendar);\n  }\n\n  constructor(locale, numbering, outputCalendar, specifiedLocale) {\n    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);\n\n    this.locale = parsedLocale;\n    this.numberingSystem = numbering || parsedNumberingSystem || null;\n    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;\n    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);\n\n    this.weekdaysCache = { format: {}, standalone: {} };\n    this.monthsCache = { format: {}, standalone: {} };\n    this.meridiemCache = null;\n    this.eraCache = {};\n\n    this.specifiedLocale = specifiedLocale;\n    this.fastNumbersCached = null;\n  }\n\n  get fastNumbers() {\n    if (this.fastNumbersCached == null) {\n      this.fastNumbersCached = supportsFastNumbers(this);\n    }\n\n    return this.fastNumbersCached;\n  }\n\n  listingMode() {\n    const isActuallyEn = this.isEnglish();\n    const hasNoWeirdness =\n      (this.numberingSystem === null || this.numberingSystem === \"latn\") &&\n      (this.outputCalendar === null || this.outputCalendar === \"gregory\");\n    return isActuallyEn && hasNoWeirdness ? \"en\" : \"intl\";\n  }\n\n  clone(alts) {\n    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {\n      return this;\n    } else {\n      return Locale.create(\n        alts.locale || this.specifiedLocale,\n        alts.numberingSystem || this.numberingSystem,\n        alts.outputCalendar || this.outputCalendar,\n        alts.defaultToEN || false\n      );\n    }\n  }\n\n  redefaultToEN(alts = {}) {\n    return this.clone({ ...alts, defaultToEN: true });\n  }\n\n  redefaultToSystem(alts = {}) {\n    return this.clone({ ...alts, defaultToEN: false });\n  }\n\n  months(length, format = false, defaultOK = true) {\n    return listStuff(this, length, defaultOK, English.months, () => {\n      const intl = format ? { month: length, day: \"numeric\" } : { month: length },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.monthsCache[formatStr][length]) {\n        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, \"month\"));\n      }\n      return this.monthsCache[formatStr][length];\n    });\n  }\n\n  weekdays(length, format = false, defaultOK = true) {\n    return listStuff(this, length, defaultOK, English.weekdays, () => {\n      const intl = format\n          ? { weekday: length, year: \"numeric\", month: \"long\", day: \"numeric\" }\n          : { weekday: length },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.weekdaysCache[formatStr][length]) {\n        this.weekdaysCache[formatStr][length] = mapWeekdays((dt) =>\n          this.extract(dt, intl, \"weekday\")\n        );\n      }\n      return this.weekdaysCache[formatStr][length];\n    });\n  }\n\n  meridiems(defaultOK = true) {\n    return listStuff(\n      this,\n      undefined,\n      defaultOK,\n      () => English.meridiems,\n      () => {\n        // In theory there could be aribitrary day periods. We're gonna assume there are exactly two\n        // for AM and PM. This is probably wrong, but it's makes parsing way easier.\n        if (!this.meridiemCache) {\n          const intl = { hour: \"numeric\", hourCycle: \"h12\" };\n          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(\n            (dt) => this.extract(dt, intl, \"dayperiod\")\n          );\n        }\n\n        return this.meridiemCache;\n      }\n    );\n  }\n\n  eras(length, defaultOK = true) {\n    return listStuff(this, length, defaultOK, English.eras, () => {\n      const intl = { era: length };\n\n      // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates\n      // to definitely enumerate them.\n      if (!this.eraCache[length]) {\n        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map((dt) =>\n          this.extract(dt, intl, \"era\")\n        );\n      }\n\n      return this.eraCache[length];\n    });\n  }\n\n  extract(dt, intlOpts, field) {\n    const df = this.dtFormatter(dt, intlOpts),\n      results = df.formatToParts(),\n      matching = results.find((m) => m.type.toLowerCase() === field);\n    return matching ? matching.value : null;\n  }\n\n  numberFormatter(opts = {}) {\n    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)\n    // (in contrast, the rest of the condition is used heavily)\n    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);\n  }\n\n  dtFormatter(dt, intlOpts = {}) {\n    return new PolyDateFormatter(dt, this.intl, intlOpts);\n  }\n\n  relFormatter(opts = {}) {\n    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);\n  }\n\n  listFormatter(opts = {}) {\n    return getCachedLF(this.intl, opts);\n  }\n\n  isEnglish() {\n    return (\n      this.locale === \"en\" ||\n      this.locale.toLowerCase() === \"en-us\" ||\n      new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith(\"en-us\")\n    );\n  }\n\n  equals(other) {\n    return (\n      this.locale === other.locale &&\n      this.numberingSystem === other.numberingSystem &&\n      this.outputCalendar === other.outputCalendar\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}