{"ast":null,"code":"/* eslint-disable import/prefer-default-export */import*as d3 from'd3';import*as dagre from'dagre';var normalizeY=function normalizeY(nodePositions,y){return y-nodePositions[1].y;};export var constants={nodeW:180,nodeH:60,rootW:72,rootH:40};export function getScaleAndOffsetToFit(gBoundingClientRect,svgBoundingClientRect,gBBoxDimensions,currentScale){gBoundingClientRect.height/=currentScale;gBoundingClientRect.width/=currentScale;// For some reason the root width needs to be added?\ngBoundingClientRect.width+=constants.rootW;var scaleNeededForMaxHeight=svgBoundingClientRect.height/gBoundingClientRect.height;var scaleNeededForMaxWidth=svgBoundingClientRect.width/gBoundingClientRect.width;var lowerScale=Math.min(scaleNeededForMaxHeight,scaleNeededForMaxWidth);var scaleToFit;var yTranslate;if(lowerScale<0.1||lowerScale>2){scaleToFit=lowerScale<0.1?0.1:2;yTranslate=svgBoundingClientRect.height/2-constants.nodeH*scaleToFit/2;}else{scaleToFit=Math.floor(lowerScale*1000)/1000;yTranslate=(svgBoundingClientRect.height-gBoundingClientRect.height*scaleToFit)/2-gBBoxDimensions.y/currentScale*scaleToFit;}return[scaleToFit,yTranslate];}export function generateLine(points){var line=d3.line().x(function(d){return d.x;}).y(function(d){return d.y;});return line(points);}export function getLinePoints(link,nodePositions){var sourceX=nodePositions[link.source.id].x+nodePositions[link.source.id].width+1;var sourceY=normalizeY(nodePositions,nodePositions[link.source.id].y)+nodePositions[link.source.id].height/2;var targetX=nodePositions[link.target.id].x-1;var targetY=normalizeY(nodePositions,nodePositions[link.target.id].y)+nodePositions[link.target.id].height/2;// There's something off with the math on the root node...\nif(link.source.id===1){sourceY+=10;}return[{x:sourceX,y:sourceY},{x:targetX,y:targetY}];}export function getLinkOverlayPoints(link,nodePositions){var sourceX=nodePositions[link.source.id].x+nodePositions[link.source.id].width+1;var sourceY=normalizeY(nodePositions,nodePositions[link.source.id].y)+nodePositions[link.source.id].height/2;var targetX=nodePositions[link.target.id].x-1;var targetY=normalizeY(nodePositions,nodePositions[link.target.id].y)+nodePositions[link.target.id].height/2;// There's something off with the math on the root node...\nif(link.source.id===1){sourceY+=10;}var slope=(targetY-sourceY)/(targetX-sourceX);var yIntercept=targetY-slope*targetX;var orthogonalDistance=8;var pt1=[targetX,slope*targetX+yIntercept+orthogonalDistance*Math.sqrt(1+slope*slope)].join(',');var pt2=[sourceX,slope*sourceX+yIntercept+orthogonalDistance*Math.sqrt(1+slope*slope)].join(',');var pt3=[sourceX,slope*sourceX+yIntercept-orthogonalDistance*Math.sqrt(1+slope*slope)].join(',');var pt4=[targetX,slope*targetX+yIntercept-orthogonalDistance*Math.sqrt(1+slope*slope)].join(',');return[pt1,pt2,pt3,pt4].join(' ');}export function layoutGraph(nodes,links){var g=new dagre.graphlib.Graph();g.setGraph({rankdir:'LR',nodesep:30,ranksep:120});// This is needed for Dagre\ng.setDefaultEdgeLabel(function(){return{};});nodes.forEach(function(node){if(node.id===1){g.setNode(node.id,{label:'',width:constants.rootW,height:constants.rootH});}else{g.setNode(node.id,{label:'',width:constants.nodeW,height:constants.nodeH});}});links.forEach(function(link){g.setEdge(link.source.id,link.target.id);});dagre.layout(g);return g;}export function getTranslatePointsForZoom(svgBoundingClientRect,currentScaleAndOffset,newScale){var origScale=currentScaleAndOffset.k;var unscaledOffsetX=(currentScaleAndOffset.x+(svgBoundingClientRect.width*origScale-svgBoundingClientRect.width)/2)/origScale;var unscaledOffsetY=(currentScaleAndOffset.y+(svgBoundingClientRect.height*origScale-svgBoundingClientRect.height)/2)/origScale;var translateX=unscaledOffsetX*newScale-(newScale*svgBoundingClientRect.width-svgBoundingClientRect.width)/2;var translateY=unscaledOffsetY*newScale-(newScale*svgBoundingClientRect.height-svgBoundingClientRect.height)/2;return[translateX,translateY];}","map":{"version":3,"sources":["/awx_devel/awx/ui/src/components/Workflow/WorkflowUtils.js"],"names":["d3","dagre","normalizeY","nodePositions","y","constants","nodeW","nodeH","rootW","rootH","getScaleAndOffsetToFit","gBoundingClientRect","svgBoundingClientRect","gBBoxDimensions","currentScale","height","width","scaleNeededForMaxHeight","scaleNeededForMaxWidth","lowerScale","Math","min","scaleToFit","yTranslate","floor","generateLine","points","line","x","d","getLinePoints","link","sourceX","source","id","sourceY","targetX","target","targetY","getLinkOverlayPoints","slope","yIntercept","orthogonalDistance","pt1","sqrt","join","pt2","pt3","pt4","layoutGraph","nodes","links","g","graphlib","Graph","setGraph","rankdir","nodesep","ranksep","setDefaultEdgeLabel","forEach","node","setNode","label","setEdge","layout","getTranslatePointsForZoom","currentScaleAndOffset","newScale","origScale","k","unscaledOffsetX","unscaledOffsetY","translateX","translateY"],"mappings":"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","sourcesContent":["/* eslint-disable import/prefer-default-export */\nimport * as d3 from 'd3';\nimport * as dagre from 'dagre';\n\nconst normalizeY = (nodePositions, y) => y - nodePositions[1].y;\n\nexport const constants = {\n  nodeW: 180,\n  nodeH: 60,\n  rootW: 72,\n  rootH: 40,\n};\n\nexport function getScaleAndOffsetToFit(\n  gBoundingClientRect,\n  svgBoundingClientRect,\n  gBBoxDimensions,\n  currentScale\n) {\n  gBoundingClientRect.height /= currentScale;\n  gBoundingClientRect.width /= currentScale;\n\n  // For some reason the root width needs to be added?\n  gBoundingClientRect.width += constants.rootW;\n\n  const scaleNeededForMaxHeight =\n    svgBoundingClientRect.height / gBoundingClientRect.height;\n  const scaleNeededForMaxWidth =\n    svgBoundingClientRect.width / gBoundingClientRect.width;\n  const lowerScale = Math.min(scaleNeededForMaxHeight, scaleNeededForMaxWidth);\n\n  let scaleToFit;\n  let yTranslate;\n  if (lowerScale < 0.1 || lowerScale > 2) {\n    scaleToFit = lowerScale < 0.1 ? 0.1 : 2;\n    yTranslate =\n      svgBoundingClientRect.height / 2 - (constants.nodeH * scaleToFit) / 2;\n  } else {\n    scaleToFit = Math.floor(lowerScale * 1000) / 1000;\n    yTranslate =\n      (svgBoundingClientRect.height - gBoundingClientRect.height * scaleToFit) /\n        2 -\n      (gBBoxDimensions.y / currentScale) * scaleToFit;\n  }\n\n  return [scaleToFit, yTranslate];\n}\n\nexport function generateLine(points) {\n  const line = d3\n    .line()\n    .x((d) => d.x)\n    .y((d) => d.y);\n\n  return line(points);\n}\n\nexport function getLinePoints(link, nodePositions) {\n  const sourceX =\n    nodePositions[link.source.id].x + nodePositions[link.source.id].width + 1;\n  let sourceY =\n    normalizeY(nodePositions, nodePositions[link.source.id].y) +\n    nodePositions[link.source.id].height / 2;\n  const targetX = nodePositions[link.target.id].x - 1;\n  const targetY =\n    normalizeY(nodePositions, nodePositions[link.target.id].y) +\n    nodePositions[link.target.id].height / 2;\n\n  // There's something off with the math on the root node...\n  if (link.source.id === 1) {\n    sourceY += 10;\n  }\n\n  return [\n    {\n      x: sourceX,\n      y: sourceY,\n    },\n    {\n      x: targetX,\n      y: targetY,\n    },\n  ];\n}\n\nexport function getLinkOverlayPoints(link, nodePositions) {\n  const sourceX =\n    nodePositions[link.source.id].x + nodePositions[link.source.id].width + 1;\n  let sourceY =\n    normalizeY(nodePositions, nodePositions[link.source.id].y) +\n    nodePositions[link.source.id].height / 2;\n  const targetX = nodePositions[link.target.id].x - 1;\n  const targetY =\n    normalizeY(nodePositions, nodePositions[link.target.id].y) +\n    nodePositions[link.target.id].height / 2;\n\n  // There's something off with the math on the root node...\n  if (link.source.id === 1) {\n    sourceY += 10;\n  }\n  const slope = (targetY - sourceY) / (targetX - sourceX);\n  const yIntercept = targetY - slope * targetX;\n  const orthogonalDistance = 8;\n\n  const pt1 = [\n    targetX,\n    slope * targetX +\n      yIntercept +\n      orthogonalDistance * Math.sqrt(1 + slope * slope),\n  ].join(',');\n  const pt2 = [\n    sourceX,\n    slope * sourceX +\n      yIntercept +\n      orthogonalDistance * Math.sqrt(1 + slope * slope),\n  ].join(',');\n  const pt3 = [\n    sourceX,\n    slope * sourceX +\n      yIntercept -\n      orthogonalDistance * Math.sqrt(1 + slope * slope),\n  ].join(',');\n  const pt4 = [\n    targetX,\n    slope * targetX +\n      yIntercept -\n      orthogonalDistance * Math.sqrt(1 + slope * slope),\n  ].join(',');\n\n  return [pt1, pt2, pt3, pt4].join(' ');\n}\n\nexport function layoutGraph(nodes, links) {\n  const g = new dagre.graphlib.Graph();\n  g.setGraph({ rankdir: 'LR', nodesep: 30, ranksep: 120 });\n\n  // This is needed for Dagre\n  g.setDefaultEdgeLabel(() => ({}));\n\n  nodes.forEach((node) => {\n    if (node.id === 1) {\n      g.setNode(node.id, {\n        label: '',\n        width: constants.rootW,\n        height: constants.rootH,\n      });\n    } else {\n      g.setNode(node.id, {\n        label: '',\n        width: constants.nodeW,\n        height: constants.nodeH,\n      });\n    }\n  });\n\n  links.forEach((link) => {\n    g.setEdge(link.source.id, link.target.id);\n  });\n\n  dagre.layout(g);\n\n  return g;\n}\n\nexport function getTranslatePointsForZoom(\n  svgBoundingClientRect,\n  currentScaleAndOffset,\n  newScale\n) {\n  const origScale = currentScaleAndOffset.k;\n  const unscaledOffsetX =\n    (currentScaleAndOffset.x +\n      (svgBoundingClientRect.width * origScale - svgBoundingClientRect.width) /\n        2) /\n    origScale;\n  const unscaledOffsetY =\n    (currentScaleAndOffset.y +\n      (svgBoundingClientRect.height * origScale -\n        svgBoundingClientRect.height) /\n        2) /\n    origScale;\n  const translateX =\n    unscaledOffsetX * newScale -\n    (newScale * svgBoundingClientRect.width - svgBoundingClientRect.width) / 2;\n  const translateY =\n    unscaledOffsetY * newScale -\n    (newScale * svgBoundingClientRect.height - svgBoundingClientRect.height) /\n      2;\n  return [translateX, translateY];\n}\n"]},"metadata":{},"sourceType":"module"}