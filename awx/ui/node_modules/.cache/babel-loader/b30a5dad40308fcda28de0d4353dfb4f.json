{"ast":null,"code":"import dateutil from './dateutil';\nimport IterResult from './iterresult';\nimport CallbackIterResult from './callbackiterresult';\nimport { fromText, parseText, toText, isFullyConvertible } from './nlp/index';\nimport { Frequency } from './types';\nimport { parseOptions, initializeOptions } from './parseoptions';\nimport { parseString } from './parsestring';\nimport { optionsToString } from './optionstostring';\nimport { Cache } from './cache';\nimport { Weekday } from './weekday';\nimport { iter } from './iter/index'; // =============================================================================\n// RRule\n// =============================================================================\n\nexport var Days = {\n  MO: new Weekday(0),\n  TU: new Weekday(1),\n  WE: new Weekday(2),\n  TH: new Weekday(3),\n  FR: new Weekday(4),\n  SA: new Weekday(5),\n  SU: new Weekday(6)\n};\nexport var DEFAULT_OPTIONS = {\n  freq: Frequency.YEARLY,\n  dtstart: null,\n  interval: 1,\n  wkst: Days.MO,\n  count: null,\n  until: null,\n  tzid: null,\n  bysetpos: null,\n  bymonth: null,\n  bymonthday: null,\n  bynmonthday: null,\n  byyearday: null,\n  byweekno: null,\n  byweekday: null,\n  bynweekday: null,\n  byhour: null,\n  byminute: null,\n  bysecond: null,\n  byeaster: null\n};\nexport var defaultKeys = Object.keys(DEFAULT_OPTIONS);\n/**\n *\n * @param {Options?} options - see <http://labix.org/python-dateutil/#head-cf004ee9a75592797e076752b2a889c10f445418>\n * - The only required option is `freq`, one of RRule.YEARLY, RRule.MONTHLY, ...\n * @constructor\n */\n\nvar RRule =\n/** @class */\nfunction () {\n  function RRule(options, noCache) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (noCache === void 0) {\n      noCache = false;\n    } // RFC string\n\n\n    this._cache = noCache ? null : new Cache(); // used by toString()\n\n    this.origOptions = initializeOptions(options);\n    var parsedOptions = parseOptions(options).parsedOptions;\n    this.options = parsedOptions;\n  }\n\n  RRule.parseText = function (text, language) {\n    return parseText(text, language);\n  };\n\n  RRule.fromText = function (text, language) {\n    return fromText(text, language);\n  };\n\n  RRule.fromString = function (str) {\n    return new RRule(RRule.parseString(str) || undefined);\n  };\n\n  RRule.prototype._iter = function (iterResult) {\n    return iter(iterResult, this.options);\n  };\n\n  RRule.prototype._cacheGet = function (what, args) {\n    if (!this._cache) return false;\n    return this._cache._cacheGet(what, args);\n  };\n\n  RRule.prototype._cacheAdd = function (what, value, args) {\n    if (!this._cache) return;\n    return this._cache._cacheAdd(what, value, args);\n  };\n  /**\n   * @param {Function} iterator - optional function that will be called\n   * on each date that is added. It can return false\n   * to stop the iteration.\n   * @return Array containing all recurrences.\n   */\n\n\n  RRule.prototype.all = function (iterator) {\n    if (iterator) {\n      return this._iter(new CallbackIterResult('all', {}, iterator));\n    }\n\n    var result = this._cacheGet('all');\n\n    if (result === false) {\n      result = this._iter(new IterResult('all', {}));\n\n      this._cacheAdd('all', result);\n    }\n\n    return result;\n  };\n  /**\n   * Returns all the occurrences of the rrule between after and before.\n   * The inc keyword defines what happens if after and/or before are\n   * themselves occurrences. With inc == True, they will be included in the\n   * list, if they are found in the recurrence set.\n   *\n   * @return Array\n   */\n\n\n  RRule.prototype.between = function (after, before, inc, iterator) {\n    if (inc === void 0) {\n      inc = false;\n    }\n\n    if (!dateutil.isValidDate(after) || !dateutil.isValidDate(before)) {\n      throw new Error('Invalid date passed in to RRule.between');\n    }\n\n    var args = {\n      before: before,\n      after: after,\n      inc: inc\n    };\n\n    if (iterator) {\n      return this._iter(new CallbackIterResult('between', args, iterator));\n    }\n\n    var result = this._cacheGet('between', args);\n\n    if (result === false) {\n      result = this._iter(new IterResult('between', args));\n\n      this._cacheAdd('between', result, args);\n    }\n\n    return result;\n  };\n  /**\n   * Returns the last recurrence before the given datetime instance.\n   * The inc keyword defines what happens if dt is an occurrence.\n   * With inc == True, if dt itself is an occurrence, it will be returned.\n   *\n   * @return Date or null\n   */\n\n\n  RRule.prototype.before = function (dt, inc) {\n    if (inc === void 0) {\n      inc = false;\n    }\n\n    if (!dateutil.isValidDate(dt)) {\n      throw new Error('Invalid date passed in to RRule.before');\n    }\n\n    var args = {\n      dt: dt,\n      inc: inc\n    };\n\n    var result = this._cacheGet('before', args);\n\n    if (result === false) {\n      result = this._iter(new IterResult('before', args));\n\n      this._cacheAdd('before', result, args);\n    }\n\n    return result;\n  };\n  /**\n   * Returns the first recurrence after the given datetime instance.\n   * The inc keyword defines what happens if dt is an occurrence.\n   * With inc == True, if dt itself is an occurrence, it will be returned.\n   *\n   * @return Date or null\n   */\n\n\n  RRule.prototype.after = function (dt, inc) {\n    if (inc === void 0) {\n      inc = false;\n    }\n\n    if (!dateutil.isValidDate(dt)) {\n      throw new Error('Invalid date passed in to RRule.after');\n    }\n\n    var args = {\n      dt: dt,\n      inc: inc\n    };\n\n    var result = this._cacheGet('after', args);\n\n    if (result === false) {\n      result = this._iter(new IterResult('after', args));\n\n      this._cacheAdd('after', result, args);\n    }\n\n    return result;\n  };\n  /**\n   * Returns the number of recurrences in this set. It will have go trough\n   * the whole recurrence, if this hasn't been done before.\n   */\n\n\n  RRule.prototype.count = function () {\n    return this.all().length;\n  };\n  /**\n   * Converts the rrule into its string representation\n   *\n   * @see <http://www.ietf.org/rfc/rfc2445.txt>\n   * @return String\n   */\n\n\n  RRule.prototype.toString = function () {\n    return optionsToString(this.origOptions);\n  };\n  /**\n   * Will convert all rules described in nlp:ToText\n   * to text.\n   */\n\n\n  RRule.prototype.toText = function (gettext, language, dateFormatter) {\n    return toText(this, gettext, language, dateFormatter);\n  };\n\n  RRule.prototype.isFullyConvertibleToText = function () {\n    return isFullyConvertible(this);\n  };\n  /**\n   * @return a RRule instance with the same freq and options\n   * as this one (cache is not cloned)\n   */\n\n\n  RRule.prototype.clone = function () {\n    return new RRule(this.origOptions);\n  }; // RRule class 'constants'\n\n\n  RRule.FREQUENCIES = ['YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY', 'HOURLY', 'MINUTELY', 'SECONDLY'];\n  RRule.YEARLY = Frequency.YEARLY;\n  RRule.MONTHLY = Frequency.MONTHLY;\n  RRule.WEEKLY = Frequency.WEEKLY;\n  RRule.DAILY = Frequency.DAILY;\n  RRule.HOURLY = Frequency.HOURLY;\n  RRule.MINUTELY = Frequency.MINUTELY;\n  RRule.SECONDLY = Frequency.SECONDLY;\n  RRule.MO = Days.MO;\n  RRule.TU = Days.TU;\n  RRule.WE = Days.WE;\n  RRule.TH = Days.TH;\n  RRule.FR = Days.FR;\n  RRule.SA = Days.SA;\n  RRule.SU = Days.SU;\n  RRule.parseString = parseString;\n  RRule.optionsToString = optionsToString;\n  return RRule;\n}();\n\nexport { RRule };","map":{"version":3,"sources":["../../src/rrule.ts"],"names":[],"mappings":"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","sourcesContent":["import dateutil from './dateutil';\nimport IterResult from './iterresult';\nimport CallbackIterResult from './callbackiterresult';\nimport { fromText, parseText, toText, isFullyConvertible } from './nlp/index';\nimport { Frequency, } from './types';\nimport { parseOptions, initializeOptions } from './parseoptions';\nimport { parseString } from './parsestring';\nimport { optionsToString } from './optionstostring';\nimport { Cache } from './cache';\nimport { Weekday } from './weekday';\nimport { iter } from './iter/index';\n// =============================================================================\n// RRule\n// =============================================================================\nexport var Days = {\n    MO: new Weekday(0),\n    TU: new Weekday(1),\n    WE: new Weekday(2),\n    TH: new Weekday(3),\n    FR: new Weekday(4),\n    SA: new Weekday(5),\n    SU: new Weekday(6),\n};\nexport var DEFAULT_OPTIONS = {\n    freq: Frequency.YEARLY,\n    dtstart: null,\n    interval: 1,\n    wkst: Days.MO,\n    count: null,\n    until: null,\n    tzid: null,\n    bysetpos: null,\n    bymonth: null,\n    bymonthday: null,\n    bynmonthday: null,\n    byyearday: null,\n    byweekno: null,\n    byweekday: null,\n    bynweekday: null,\n    byhour: null,\n    byminute: null,\n    bysecond: null,\n    byeaster: null,\n};\nexport var defaultKeys = Object.keys(DEFAULT_OPTIONS);\n/**\n *\n * @param {Options?} options - see <http://labix.org/python-dateutil/#head-cf004ee9a75592797e076752b2a889c10f445418>\n * - The only required option is `freq`, one of RRule.YEARLY, RRule.MONTHLY, ...\n * @constructor\n */\nvar RRule = /** @class */ (function () {\n    function RRule(options, noCache) {\n        if (options === void 0) { options = {}; }\n        if (noCache === void 0) { noCache = false; }\n        // RFC string\n        this._cache = noCache ? null : new Cache();\n        // used by toString()\n        this.origOptions = initializeOptions(options);\n        var parsedOptions = parseOptions(options).parsedOptions;\n        this.options = parsedOptions;\n    }\n    RRule.parseText = function (text, language) {\n        return parseText(text, language);\n    };\n    RRule.fromText = function (text, language) {\n        return fromText(text, language);\n    };\n    RRule.fromString = function (str) {\n        return new RRule(RRule.parseString(str) || undefined);\n    };\n    RRule.prototype._iter = function (iterResult) {\n        return iter(iterResult, this.options);\n    };\n    RRule.prototype._cacheGet = function (what, args) {\n        if (!this._cache)\n            return false;\n        return this._cache._cacheGet(what, args);\n    };\n    RRule.prototype._cacheAdd = function (what, value, args) {\n        if (!this._cache)\n            return;\n        return this._cache._cacheAdd(what, value, args);\n    };\n    /**\n     * @param {Function} iterator - optional function that will be called\n     * on each date that is added. It can return false\n     * to stop the iteration.\n     * @return Array containing all recurrences.\n     */\n    RRule.prototype.all = function (iterator) {\n        if (iterator) {\n            return this._iter(new CallbackIterResult('all', {}, iterator));\n        }\n        var result = this._cacheGet('all');\n        if (result === false) {\n            result = this._iter(new IterResult('all', {}));\n            this._cacheAdd('all', result);\n        }\n        return result;\n    };\n    /**\n     * Returns all the occurrences of the rrule between after and before.\n     * The inc keyword defines what happens if after and/or before are\n     * themselves occurrences. With inc == True, they will be included in the\n     * list, if they are found in the recurrence set.\n     *\n     * @return Array\n     */\n    RRule.prototype.between = function (after, before, inc, iterator) {\n        if (inc === void 0) { inc = false; }\n        if (!dateutil.isValidDate(after) || !dateutil.isValidDate(before)) {\n            throw new Error('Invalid date passed in to RRule.between');\n        }\n        var args = {\n            before: before,\n            after: after,\n            inc: inc,\n        };\n        if (iterator) {\n            return this._iter(new CallbackIterResult('between', args, iterator));\n        }\n        var result = this._cacheGet('between', args);\n        if (result === false) {\n            result = this._iter(new IterResult('between', args));\n            this._cacheAdd('between', result, args);\n        }\n        return result;\n    };\n    /**\n     * Returns the last recurrence before the given datetime instance.\n     * The inc keyword defines what happens if dt is an occurrence.\n     * With inc == True, if dt itself is an occurrence, it will be returned.\n     *\n     * @return Date or null\n     */\n    RRule.prototype.before = function (dt, inc) {\n        if (inc === void 0) { inc = false; }\n        if (!dateutil.isValidDate(dt)) {\n            throw new Error('Invalid date passed in to RRule.before');\n        }\n        var args = { dt: dt, inc: inc };\n        var result = this._cacheGet('before', args);\n        if (result === false) {\n            result = this._iter(new IterResult('before', args));\n            this._cacheAdd('before', result, args);\n        }\n        return result;\n    };\n    /**\n     * Returns the first recurrence after the given datetime instance.\n     * The inc keyword defines what happens if dt is an occurrence.\n     * With inc == True, if dt itself is an occurrence, it will be returned.\n     *\n     * @return Date or null\n     */\n    RRule.prototype.after = function (dt, inc) {\n        if (inc === void 0) { inc = false; }\n        if (!dateutil.isValidDate(dt)) {\n            throw new Error('Invalid date passed in to RRule.after');\n        }\n        var args = { dt: dt, inc: inc };\n        var result = this._cacheGet('after', args);\n        if (result === false) {\n            result = this._iter(new IterResult('after', args));\n            this._cacheAdd('after', result, args);\n        }\n        return result;\n    };\n    /**\n     * Returns the number of recurrences in this set. It will have go trough\n     * the whole recurrence, if this hasn't been done before.\n     */\n    RRule.prototype.count = function () {\n        return this.all().length;\n    };\n    /**\n     * Converts the rrule into its string representation\n     *\n     * @see <http://www.ietf.org/rfc/rfc2445.txt>\n     * @return String\n     */\n    RRule.prototype.toString = function () {\n        return optionsToString(this.origOptions);\n    };\n    /**\n     * Will convert all rules described in nlp:ToText\n     * to text.\n     */\n    RRule.prototype.toText = function (gettext, language, dateFormatter) {\n        return toText(this, gettext, language, dateFormatter);\n    };\n    RRule.prototype.isFullyConvertibleToText = function () {\n        return isFullyConvertible(this);\n    };\n    /**\n     * @return a RRule instance with the same freq and options\n     * as this one (cache is not cloned)\n     */\n    RRule.prototype.clone = function () {\n        return new RRule(this.origOptions);\n    };\n    // RRule class 'constants'\n    RRule.FREQUENCIES = [\n        'YEARLY',\n        'MONTHLY',\n        'WEEKLY',\n        'DAILY',\n        'HOURLY',\n        'MINUTELY',\n        'SECONDLY',\n    ];\n    RRule.YEARLY = Frequency.YEARLY;\n    RRule.MONTHLY = Frequency.MONTHLY;\n    RRule.WEEKLY = Frequency.WEEKLY;\n    RRule.DAILY = Frequency.DAILY;\n    RRule.HOURLY = Frequency.HOURLY;\n    RRule.MINUTELY = Frequency.MINUTELY;\n    RRule.SECONDLY = Frequency.SECONDLY;\n    RRule.MO = Days.MO;\n    RRule.TU = Days.TU;\n    RRule.WE = Days.WE;\n    RRule.TH = Days.TH;\n    RRule.FR = Days.FR;\n    RRule.SA = Days.SA;\n    RRule.SU = Days.SU;\n    RRule.parseString = parseString;\n    RRule.optionsToString = optionsToString;\n    return RRule;\n}());\nexport { RRule };\n"]},"metadata":{},"sourceType":"module"}