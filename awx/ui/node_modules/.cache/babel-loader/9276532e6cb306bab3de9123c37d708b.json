{"ast":null,"code":"import getBoundingClientRect from '../dom-utils/getBoundingClientRect';\nimport getClippingRect from '../dom-utils/getClippingRect';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport computeOffsets from './computeOffsets';\nimport rectToClientRect from './rectToClientRect';\nimport { clippingParents, reference, popper, bottom, top, right, basePlacements, viewport } from '../enums';\nimport { isElement } from '../dom-utils/instanceOf';\nimport mergePaddingObject from './mergePaddingObject';\nimport expandToHashMap from './expandToHashMap';\n/**\n * @param state\n * @param options\n */\n\nexport default function detectOverflow(state) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$placement = options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$boundary = options.boundary,\n      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n      _options$rootBoundary = options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = options.elementContext,\n      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n      _options$altBoundary = options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === popper ? reference : popper;\n  var referenceElement = state.elements.reference;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n  var referenceClientRect = getBoundingClientRect(referenceElement);\n  var popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement: placement\n  });\n  var popperClientRect = rectToClientRect(Object.assign(Object.assign({}, popperRect), popperOffsets));\n  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === popper && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}","map":{"version":3,"sources":["/awx_devel/awx/ui/node_modules/@patternfly/react-core/src/helpers/Popper/thirdparty/popper-core/utils/detectOverflow.ts"],"names":[],"mappings":"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","sourcesContent":["// @ts-nocheck\nimport { State, SideObject, Padding } from '../types';\nimport { Placement, Boundary, RootBoundary, Context } from '../enums';\nimport getBoundingClientRect from '../dom-utils/getBoundingClientRect';\nimport getClippingRect from '../dom-utils/getClippingRect';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport computeOffsets from './computeOffsets';\nimport rectToClientRect from './rectToClientRect';\nimport { clippingParents, reference, popper, bottom, top, right, basePlacements, viewport } from '../enums';\nimport { isElement } from '../dom-utils/instanceOf';\nimport mergePaddingObject from './mergePaddingObject';\nimport expandToHashMap from './expandToHashMap';\n\n// eslint-disable-next-line import/no-unused-modules\nexport interface Options {\n  placement: Placement;\n  boundary: Boundary;\n  rootBoundary: RootBoundary;\n  elementContext: Context;\n  altBoundary: boolean;\n  padding: Padding;\n}\n\n/**\n * @param state\n * @param options\n */\nexport default function detectOverflow(state: State, options: Partial<Options> = {}): SideObject {\n  const {\n    placement = state.placement,\n    boundary = clippingParents,\n    rootBoundary = viewport,\n    elementContext = popper,\n    altBoundary = false,\n    padding = 0\n  } = options;\n\n  const paddingObject = mergePaddingObject(\n    typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements)\n  );\n\n  const altContext = elementContext === popper ? reference : popper;\n\n  const referenceElement = state.elements.reference;\n  const popperRect = state.rects.popper;\n  const element = state.elements[altBoundary ? altContext : elementContext];\n\n  const clippingClientRect = getClippingRect(\n    isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper),\n    boundary,\n    rootBoundary\n  );\n\n  const referenceClientRect = getBoundingClientRect(referenceElement);\n\n  const popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement\n  });\n\n  const popperClientRect = rectToClientRect({\n    ...popperRect,\n    ...popperOffsets\n  });\n\n  const elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;\n\n  // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n  const overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n\n  const offsetData = state.modifiersData.offset;\n\n  // Offsets can be applied only to the popper element\n  if (elementContext === popper && offsetData) {\n    const offset = offsetData[placement];\n\n    Object.keys(overflowOffsets).forEach(key => {\n      const multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      const axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}\n"]},"metadata":{},"sourceType":"module"}