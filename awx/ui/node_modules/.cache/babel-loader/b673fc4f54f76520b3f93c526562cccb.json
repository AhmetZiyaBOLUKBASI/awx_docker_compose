{"ast":null,"code":"'use strict';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar entities = require('entities');\n\nvar defaults = {\n  fg: '#FFF',\n  bg: '#000',\n  newline: false,\n  escapeXML: false,\n  stream: false,\n  colors: getDefaultColors()\n};\n\nfunction getDefaultColors() {\n  var colors = {\n    0: '#000',\n    1: '#A00',\n    2: '#0A0',\n    3: '#A50',\n    4: '#00A',\n    5: '#A0A',\n    6: '#0AA',\n    7: '#AAA',\n    8: '#555',\n    9: '#F55',\n    10: '#5F5',\n    11: '#FF5',\n    12: '#55F',\n    13: '#F5F',\n    14: '#5FF',\n    15: '#FFF'\n  };\n  range(0, 5).forEach(function (red) {\n    range(0, 5).forEach(function (green) {\n      range(0, 5).forEach(function (blue) {\n        return setStyleColor(red, green, blue, colors);\n      });\n    });\n  });\n  range(0, 23).forEach(function (gray) {\n    var c = gray + 232;\n    var l = toHexString(gray * 10 + 8);\n    colors[c] = '#' + l + l + l;\n  });\n  return colors;\n}\n/**\n * @param {number} red\n * @param {number} green\n * @param {number} blue\n * @param {object} colors\n */\n\n\nfunction setStyleColor(red, green, blue, colors) {\n  var c = 16 + red * 36 + green * 6 + blue;\n  var r = red > 0 ? red * 40 + 55 : 0;\n  var g = green > 0 ? green * 40 + 55 : 0;\n  var b = blue > 0 ? blue * 40 + 55 : 0;\n  colors[c] = toColorHexString([r, g, b]);\n}\n/**\n * Converts from a number like 15 to a hex string like 'F'\n * @param {number} num\n * @returns {string}\n */\n\n\nfunction toHexString(num) {\n  var str = num.toString(16);\n\n  while (str.length < 2) {\n    str = '0' + str;\n  }\n\n  return str;\n}\n/**\n * Converts from an array of numbers like [15, 15, 15] to a hex string like 'FFF'\n * @param {[red, green, blue]} ref\n * @returns {string}\n */\n\n\nfunction toColorHexString(ref) {\n  var results = [];\n\n  var _iterator = _createForOfIteratorHelper(ref),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var r = _step.value;\n      results.push(toHexString(r));\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return '#' + results.join('');\n}\n/**\n * @param {Array} stack\n * @param {string} token\n * @param {*} data\n * @param {object} options\n */\n\n\nfunction generateOutput(stack, token, data, options) {\n  var result;\n\n  if (token === 'text') {\n    result = pushText(data, options);\n  } else if (token === 'display') {\n    result = handleDisplay(stack, data, options);\n  } else if (token === 'xterm256Foreground') {\n    result = pushForegroundColor(stack, options.colors[data]);\n  } else if (token === 'xterm256Background') {\n    result = pushBackgroundColor(stack, options.colors[data]);\n  } else if (token === 'rgb') {\n    result = handleRgb(stack, data);\n  }\n\n  return result;\n}\n/**\n * @param {Array} stack\n * @param {string} data\n * @returns {*}\n */\n\n\nfunction handleRgb(stack, data) {\n  data = data.substring(2).slice(0, -1);\n  var operation = +data.substr(0, 2);\n  var color = data.substring(5).split(';');\n  var rgb = color.map(function (value) {\n    return ('0' + Number(value).toString(16)).substr(-2);\n  }).join('');\n  return pushStyle(stack, (operation === 38 ? 'color:#' : 'background-color:#') + rgb);\n}\n/**\n * @param {Array} stack\n * @param {number} code\n * @param {object} options\n * @returns {*}\n */\n\n\nfunction handleDisplay(stack, code, options) {\n  code = parseInt(code, 10);\n  var codeMap = {\n    '-1': function _() {\n      return '<br/>';\n    },\n    0: function _() {\n      return stack.length && resetStyles(stack);\n    },\n    1: function _() {\n      return pushTag(stack, 'b');\n    },\n    3: function _() {\n      return pushTag(stack, 'i');\n    },\n    4: function _() {\n      return pushTag(stack, 'u');\n    },\n    8: function _() {\n      return pushStyle(stack, 'display:none');\n    },\n    9: function _() {\n      return pushTag(stack, 'strike');\n    },\n    22: function _() {\n      return pushStyle(stack, 'font-weight:normal;text-decoration:none;font-style:normal');\n    },\n    23: function _() {\n      return closeTag(stack, 'i');\n    },\n    24: function _() {\n      return closeTag(stack, 'u');\n    },\n    39: function _() {\n      return pushForegroundColor(stack, options.fg);\n    },\n    49: function _() {\n      return pushBackgroundColor(stack, options.bg);\n    },\n    53: function _() {\n      return pushStyle(stack, 'text-decoration:overline');\n    }\n  };\n  var result;\n\n  if (codeMap[code]) {\n    result = codeMap[code]();\n  } else if (4 < code && code < 7) {\n    result = pushTag(stack, 'blink');\n  } else if (29 < code && code < 38) {\n    result = pushForegroundColor(stack, options.colors[code - 30]);\n  } else if (39 < code && code < 48) {\n    result = pushBackgroundColor(stack, options.colors[code - 40]);\n  } else if (89 < code && code < 98) {\n    result = pushForegroundColor(stack, options.colors[8 + (code - 90)]);\n  } else if (99 < code && code < 108) {\n    result = pushBackgroundColor(stack, options.colors[8 + (code - 100)]);\n  }\n\n  return result;\n}\n/**\n * Clear all the styles\n * @returns {string}\n */\n\n\nfunction resetStyles(stack) {\n  var stackClone = stack.slice(0);\n  stack.length = 0;\n  return stackClone.reverse().map(function (tag) {\n    return '</' + tag + '>';\n  }).join('');\n}\n/**\n * Creates an array of numbers ranging from low to high\n * @param {number} low\n * @param {number} high\n * @returns {Array}\n * @example range(3, 7); // creates [3, 4, 5, 6, 7]\n */\n\n\nfunction range(low, high) {\n  var results = [];\n\n  for (var j = low; j <= high; j++) {\n    results.push(j);\n  }\n\n  return results;\n}\n/**\n * Returns a new function that is true if value is NOT the same category\n * @param {string} category\n * @returns {function}\n */\n\n\nfunction notCategory(category) {\n  return function (e) {\n    return (category === null || e.category !== category) && category !== 'all';\n  };\n}\n/**\n * Converts a code into an ansi token type\n * @param {number} code\n * @returns {string}\n */\n\n\nfunction categoryForCode(code) {\n  code = parseInt(code, 10);\n  var result = null;\n\n  if (code === 0) {\n    result = 'all';\n  } else if (code === 1) {\n    result = 'bold';\n  } else if (2 < code && code < 5) {\n    result = 'underline';\n  } else if (4 < code && code < 7) {\n    result = 'blink';\n  } else if (code === 8) {\n    result = 'hide';\n  } else if (code === 9) {\n    result = 'strike';\n  } else if (29 < code && code < 38 || code === 39 || 89 < code && code < 98) {\n    result = 'foreground-color';\n  } else if (39 < code && code < 48 || code === 49 || 99 < code && code < 108) {\n    result = 'background-color';\n  }\n\n  return result;\n}\n/**\n * @param {string} text\n * @param {object} options\n * @returns {string}\n */\n\n\nfunction pushText(text, options) {\n  if (options.escapeXML) {\n    return entities.encodeXML(text);\n  }\n\n  return text;\n}\n/**\n * @param {Array} stack\n * @param {string} tag\n * @param {string} [style='']\n * @returns {string}\n */\n\n\nfunction pushTag(stack, tag, style) {\n  if (!style) {\n    style = '';\n  }\n\n  stack.push(tag);\n  return \"<\".concat(tag).concat(style ? \" style=\\\"\".concat(style, \"\\\"\") : '', \">\");\n}\n/**\n * @param {Array} stack\n * @param {string} style\n * @returns {string}\n */\n\n\nfunction pushStyle(stack, style) {\n  return pushTag(stack, 'span', style);\n}\n\nfunction pushForegroundColor(stack, color) {\n  return pushTag(stack, 'span', 'color:' + color);\n}\n\nfunction pushBackgroundColor(stack, color) {\n  return pushTag(stack, 'span', 'background-color:' + color);\n}\n/**\n * @param {Array} stack\n * @param {string} style\n * @returns {string}\n */\n\n\nfunction closeTag(stack, style) {\n  var last;\n\n  if (stack.slice(-1)[0] === style) {\n    last = stack.pop();\n  }\n\n  if (last) {\n    return '</' + style + '>';\n  }\n}\n/**\n * @param {string} text\n * @param {object} options\n * @param {function} callback\n * @returns {Array}\n */\n\n\nfunction tokenize(text, options, callback) {\n  var ansiMatch = false;\n  var ansiHandler = 3;\n\n  function remove() {\n    return '';\n  }\n\n  function removeXterm256Foreground(m, g1) {\n    callback('xterm256Foreground', g1);\n    return '';\n  }\n\n  function removeXterm256Background(m, g1) {\n    callback('xterm256Background', g1);\n    return '';\n  }\n\n  function newline(m) {\n    if (options.newline) {\n      callback('display', -1);\n    } else {\n      callback('text', m);\n    }\n\n    return '';\n  }\n\n  function ansiMess(m, g1) {\n    ansiMatch = true;\n\n    if (g1.trim().length === 0) {\n      g1 = '0';\n    }\n\n    g1 = g1.trimRight(';').split(';');\n\n    var _iterator2 = _createForOfIteratorHelper(g1),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var g = _step2.value;\n        callback('display', g);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return '';\n  }\n\n  function realText(m) {\n    callback('text', m);\n    return '';\n  }\n\n  function rgb(m) {\n    callback('rgb', m);\n    return '';\n  }\n  /* eslint no-control-regex:0 */\n\n\n  var tokens = [{\n    pattern: /^\\x08+/,\n    sub: remove\n  }, {\n    pattern: /^\\x1b\\[[012]?K/,\n    sub: remove\n  }, {\n    pattern: /^\\x1b\\[\\(B/,\n    sub: remove\n  }, {\n    pattern: /^\\x1b\\[[34]8;2;\\d+;\\d+;\\d+m/,\n    sub: rgb\n  }, {\n    pattern: /^\\x1b\\[38;5;(\\d+)m/,\n    sub: removeXterm256Foreground\n  }, {\n    pattern: /^\\x1b\\[48;5;(\\d+)m/,\n    sub: removeXterm256Background\n  }, {\n    pattern: /^\\n/,\n    sub: newline\n  }, {\n    pattern: /^\\r+\\n/,\n    sub: newline\n  }, {\n    pattern: /^\\r/,\n    sub: newline\n  }, {\n    pattern: /^\\x1b\\[((?:\\d{1,3};?)+|)m/,\n    sub: ansiMess\n  }, {\n    // CSI n J\n    // ED - Erase in Display Clears part of the screen.\n    // If n is 0 (or missing), clear from cursor to end of screen.\n    // If n is 1, clear from cursor to beginning of the screen.\n    // If n is 2, clear entire screen (and moves cursor to upper left on DOS ANSI.SYS).\n    // If n is 3, clear entire screen and delete all lines saved in the scrollback buffer\n    //   (this feature was added for xterm and is supported by other terminal applications).\n    pattern: /^\\x1b\\[\\d?J/,\n    sub: remove\n  }, {\n    // CSI n ; m f\n    // HVP - Horizontal Vertical Position Same as CUP\n    pattern: /^\\x1b\\[\\d{0,3};\\d{0,3}f/,\n    sub: remove\n  }, {\n    // catch-all for CSI sequences?\n    pattern: /^\\x1b\\[?[\\d;]{0,3}/,\n    sub: remove\n  }, {\n    /**\n     * extracts real text - not containing:\n     * - `\\x1b' - ESC - escape (Ascii 27)\n     * - '\\x08' - BS - backspace (Ascii 8)\n     * - `\\n` - Newline - linefeed (LF) (ascii 10)\n     * - `\\r` - Windows Carriage Return (CR)\n     */\n    pattern: /^(([^\\x1b\\x08\\r\\n])+)/,\n    sub: realText\n  }];\n\n  function process(handler, i) {\n    if (i > ansiHandler && ansiMatch) {\n      return;\n    }\n\n    ansiMatch = false;\n    text = text.replace(handler.pattern, handler.sub);\n  }\n\n  var results1 = [];\n  var _text = text,\n      length = _text.length;\n\n  outer: while (length > 0) {\n    for (var i = 0, o = 0, len = tokens.length; o < len; i = ++o) {\n      var handler = tokens[i];\n      process(handler, i);\n\n      if (text.length !== length) {\n        // We matched a token and removed it from the text. We need to\n        // start matching *all* tokens against the new text.\n        length = text.length;\n        continue outer;\n      }\n    }\n\n    if (text.length === length) {\n      break;\n    }\n\n    results1.push(0);\n    length = text.length;\n  }\n\n  return results1;\n}\n/**\n * If streaming, then the stack is \"sticky\"\n *\n * @param {Array} stickyStack\n * @param {string} token\n * @param {*} data\n * @returns {Array}\n */\n\n\nfunction updateStickyStack(stickyStack, token, data) {\n  if (token !== 'text') {\n    stickyStack = stickyStack.filter(notCategory(categoryForCode(data)));\n    stickyStack.push({\n      token: token,\n      data: data,\n      category: categoryForCode(data)\n    });\n  }\n\n  return stickyStack;\n}\n\nvar Filter = /*#__PURE__*/function () {\n  /**\n   * @param {object} options\n   * @param {string=} options.fg The default foreground color used when reset color codes are encountered.\n   * @param {string=} options.bg The default background color used when reset color codes are encountered.\n   * @param {boolean=} options.newline Convert newline characters to `<br/>`.\n   * @param {boolean=} options.escapeXML Generate HTML/XML entities.\n   * @param {boolean=} options.stream Save style state across invocations of `toHtml()`.\n   * @param {(string[] | {[code: number]: string})=} options.colors Can override specific colors or the entire ANSI palette.\n   */\n  function Filter(options) {\n    _classCallCheck(this, Filter);\n\n    options = options || {};\n\n    if (options.colors) {\n      options.colors = Object.assign({}, defaults.colors, options.colors);\n    }\n\n    this.options = Object.assign({}, defaults, options);\n    this.stack = [];\n    this.stickyStack = [];\n  }\n  /**\n   * @param {string | string[]} input\n   * @returns {string}\n   */\n\n\n  _createClass(Filter, [{\n    key: \"toHtml\",\n    value: function toHtml(input) {\n      var _this = this;\n\n      input = typeof input === 'string' ? [input] : input;\n      var stack = this.stack,\n          options = this.options;\n      var buf = [];\n      this.stickyStack.forEach(function (element) {\n        var output = generateOutput(stack, element.token, element.data, options);\n\n        if (output) {\n          buf.push(output);\n        }\n      });\n      tokenize(input.join(''), options, function (token, data) {\n        var output = generateOutput(stack, token, data, options);\n\n        if (output) {\n          buf.push(output);\n        }\n\n        if (options.stream) {\n          _this.stickyStack = updateStickyStack(_this.stickyStack, token, data);\n        }\n      });\n\n      if (stack.length) {\n        buf.push(resetStyles(stack));\n      }\n\n      return buf.join('');\n    }\n  }]);\n\n  return Filter;\n}();\n\nmodule.exports = Filter;","map":{"version":3,"sources":["/awx_devel/awx/ui/node_modules/ansi-to-html/src/ansi_to_html.js"],"names":["entities","require","defaults","fg","bg","newline","escapeXML","stream","colors","getDefaultColors","range","setStyleColor","c","gray","l","toHexString","red","green","r","g","b","blue","toColorHexString","str","num","results","token","result","pushText","handleDisplay","pushForegroundColor","options","pushBackgroundColor","handleRgb","data","operation","color","rgb","Number","pushStyle","code","parseInt","codeMap","stack","resetStyles","pushTag","closeTag","stackClone","j","category","e","style","last","ansiMatch","ansiHandler","callback","g1","tokens","pattern","sub","remove","removeXterm256Foreground","removeXterm256Background","ansiMess","realText","i","text","handler","results1","length","outer","o","len","process","stickyStack","notCategory","categoryForCode","Filter","Object","input","buf","output","generateOutput","element","tokenize","updateStickyStack","module"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,IAAMA,QAAQ,GAAGC,OAAO,CAAxB,UAAwB,CAAxB;;AACA,IAAMC,QAAQ,GAAG;AACbC,EAAAA,EAAE,EADW,MAAA;AAEbC,EAAAA,EAAE,EAFW,MAAA;AAGbC,EAAAA,OAAO,EAHM,KAAA;AAIbC,EAAAA,SAAS,EAJI,KAAA;AAKbC,EAAAA,MAAM,EALO,KAAA;AAMbC,EAAAA,MAAM,EAAEC,gBAAgB;AANX,CAAjB;;AASA,SAAA,gBAAA,GAA4B;AACxB,MAAMD,MAAM,GAAG;AACX,OADW,MAAA;AAEX,OAFW,MAAA;AAGX,OAHW,MAAA;AAIX,OAJW,MAAA;AAKX,OALW,MAAA;AAMX,OANW,MAAA;AAOX,OAPW,MAAA;AAQX,OARW,MAAA;AASX,OATW,MAAA;AAUX,OAVW,MAAA;AAWX,QAXW,MAAA;AAYX,QAZW,MAAA;AAaX,QAbW,MAAA;AAcX,QAdW,MAAA;AAeX,QAfW,MAAA;AAgBX,QAAI;AAhBO,GAAf;AAmBAE,EAAAA,KAAK,CAAA,CAAA,EAALA,CAAK,CAALA,CAAAA,OAAAA,CAAoB,UAAA,GAAA,EAAO;AACvBA,IAAAA,KAAK,CAAA,CAAA,EAALA,CAAK,CAALA,CAAAA,OAAAA,CAAoB,UAAA,KAAA,EAAS;AACzBA,MAAAA,KAAK,CAAA,CAAA,EAALA,CAAK,CAALA,CAAAA,OAAAA,CAAoB,UAAA,IAAA,EAAI;AAAA,eAAIC,aAAa,CAAA,GAAA,EAAA,KAAA,EAAA,IAAA,EAAjB,MAAiB,CAAjB;AAAxBD,OAAAA;AADJA,KAAAA;AADJA,GAAAA;AAMAA,EAAAA,KAAK,CAAA,CAAA,EAALA,EAAK,CAALA,CAAAA,OAAAA,CAAqB,UAAA,IAAA,EAAgB;AACjC,QAAME,CAAC,GAAGC,IAAI,GAAd,GAAA;AACA,QAAMC,CAAC,GAAGC,WAAW,CAACF,IAAI,GAAJA,EAAAA,GAAtB,CAAqB,CAArB;AAEAL,IAAAA,MAAM,CAANA,CAAM,CAANA,GAAY,MAAA,CAAA,GAAA,CAAA,GAAZA,CAAAA;AAJJE,GAAAA;AAOA,SAAA,MAAA;AACH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAA,aAAA,CAAA,GAAA,EAAA,KAAA,EAAA,IAAA,EAAA,MAAA,EAAiD;AAC7C,MAAME,CAAC,GAAG,KAAMI,GAAG,GAAT,EAAA,GAAmBC,KAAK,GAAxB,CAAA,GAAV,IAAA;AACA,MAAMC,CAAC,GAAGF,GAAG,GAAHA,CAAAA,GAAUA,GAAG,GAAHA,EAAAA,GAAVA,EAAAA,GAAV,CAAA;AACA,MAAMG,CAAC,GAAGF,KAAK,GAALA,CAAAA,GAAYA,KAAK,GAALA,EAAAA,GAAZA,EAAAA,GAAV,CAAA;AACA,MAAMG,CAAC,GAAGC,IAAI,GAAJA,CAAAA,GAAWA,IAAI,GAAJA,EAAAA,GAAXA,EAAAA,GAAV,CAAA;AAEAb,EAAAA,MAAM,CAANA,CAAM,CAANA,GAAYc,gBAAgB,CAAC,CAAA,CAAA,EAAA,CAAA,EAA7Bd,CAA6B,CAAD,CAA5BA;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAAA,WAAA,CAAA,GAAA,EAA0B;AACtB,MAAIe,GAAG,GAAGC,GAAG,CAAHA,QAAAA,CAAV,EAAUA,CAAV;;AAEA,SAAOD,GAAG,CAAHA,MAAAA,GAAP,CAAA,EAAuB;AACnBA,IAAAA,GAAG,GAAG,MAANA,GAAAA;AACH;;AAED,SAAA,GAAA;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAAA,gBAAA,CAAA,GAAA,EAA+B;AAC3B,MAAME,OAAO,GAAb,EAAA;;AAD2B,MAAA,SAAA,GAAA,0BAAA,CAAA,GAAA,CAAA;AAAA,MAAA,KAAA;;AAAA,MAAA;AAG3B,SAAA,SAAA,CAAA,CAAA,EAAA,EAAA,CAAA,CAAA,KAAA,GAAA,SAAA,CAAA,CAAA,EAAA,EAAA,IAAA,GAAqB;AAAA,UAAVP,CAAU,GAAA,KAAA,CAAA,KAAA;AACjBO,MAAAA,OAAO,CAAPA,IAAAA,CAAaV,WAAW,CAAxBU,CAAwB,CAAxBA;AACH;AAL0B,GAAA,CAAA,OAAA,GAAA,EAAA;AAAA,IAAA,SAAA,CAAA,CAAA,CAAA,GAAA;AAAA,GAAA,SAAA;AAAA,IAAA,SAAA,CAAA,CAAA;AAAA;;AAO3B,SAAO,MAAMA,OAAO,CAAPA,IAAAA,CAAb,EAAaA,CAAb;AACH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAA,cAAA,CAAA,KAAA,EAAA,KAAA,EAAA,IAAA,EAAA,OAAA,EAAqD;AACjD,MAAA,MAAA;;AAEA,MAAIC,KAAK,KAAT,MAAA,EAAsB;AAClBC,IAAAA,MAAM,GAAGC,QAAQ,CAAA,IAAA,EAAjBD,OAAiB,CAAjBA;AADJ,GAAA,MAEO,IAAID,KAAK,KAAT,SAAA,EAAyB;AAC5BC,IAAAA,MAAM,GAAGE,aAAa,CAAA,KAAA,EAAA,IAAA,EAAtBF,OAAsB,CAAtBA;AADG,GAAA,MAEA,IAAID,KAAK,KAAT,oBAAA,EAAoC;AACvCC,IAAAA,MAAM,GAAGG,mBAAmB,CAAA,KAAA,EAAQC,OAAO,CAAPA,MAAAA,CAApCJ,IAAoCI,CAAR,CAA5BJ;AADG,GAAA,MAEA,IAAID,KAAK,KAAT,oBAAA,EAAoC;AACvCC,IAAAA,MAAM,GAAGK,mBAAmB,CAAA,KAAA,EAAQD,OAAO,CAAPA,MAAAA,CAApCJ,IAAoCI,CAAR,CAA5BJ;AADG,GAAA,MAEA,IAAID,KAAK,KAAT,KAAA,EAAqB;AACxBC,IAAAA,MAAM,GAAGM,SAAS,CAAA,KAAA,EAAlBN,IAAkB,CAAlBA;AACH;;AAED,SAAA,MAAA;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAAA,SAAA,CAAA,KAAA,EAAA,IAAA,EAAgC;AAC5BO,EAAAA,IAAI,GAAGA,IAAI,CAAJA,SAAAA,CAAAA,CAAAA,EAAAA,KAAAA,CAAAA,CAAAA,EAA2B,CAAlCA,CAAOA,CAAPA;AACA,MAAMC,SAAS,GAAG,CAACD,IAAI,CAAJA,MAAAA,CAAAA,CAAAA,EAAnB,CAAmBA,CAAnB;AAEA,MAAME,KAAK,GAAGF,IAAI,CAAJA,SAAAA,CAAAA,CAAAA,EAAAA,KAAAA,CAAd,GAAcA,CAAd;AACA,MAAMG,GAAG,GAAG,KAAK,CAAL,GAAA,CAAU,UAAA,KAAA,EAAiB;AACnC,WAAO,CAAC,MAAMC,MAAM,CAANA,KAAM,CAANA,CAAAA,QAAAA,CAAP,EAAOA,CAAP,EAAA,MAAA,CAA0C,CAAjD,CAAO,CAAP;AADQ,GAAA,EAAA,IAAA,CAAZ,EAAY,CAAZ;AAIA,SAAOC,SAAS,CAAA,KAAA,EAAQ,CAACJ,SAAS,KAATA,EAAAA,GAAAA,SAAAA,GAAD,oBAAA,IAAxB,GAAgB,CAAhB;AACH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAA,aAAA,CAAA,KAAA,EAAA,IAAA,EAAA,OAAA,EAA6C;AACzCK,EAAAA,IAAI,GAAGC,QAAQ,CAAA,IAAA,EAAfD,EAAe,CAAfA;AAEA,MAAME,OAAO,GAAG;AACZ,UAAM,SAAA,CAAA,GAAA;AAAA,aAAA,OAAA;AADM,KAAA;AAEZ,OAAG,SAAA,CAAA,GAAA;AAAA,aAAMC,KAAK,CAALA,MAAAA,IAAgBC,WAAW,CAAjC,KAAiC,CAAjC;AAFS,KAAA;AAGZ,OAAG,SAAA,CAAA,GAAA;AAAA,aAAMC,OAAO,CAAA,KAAA,EAAb,GAAa,CAAb;AAHS,KAAA;AAIZ,OAAG,SAAA,CAAA,GAAA;AAAA,aAAMA,OAAO,CAAA,KAAA,EAAb,GAAa,CAAb;AAJS,KAAA;AAKZ,OAAG,SAAA,CAAA,GAAA;AAAA,aAAMA,OAAO,CAAA,KAAA,EAAb,GAAa,CAAb;AALS,KAAA;AAMZ,OAAG,SAAA,CAAA,GAAA;AAAA,aAAMN,SAAS,CAAA,KAAA,EAAf,cAAe,CAAf;AANS,KAAA;AAOZ,OAAG,SAAA,CAAA,GAAA;AAAA,aAAMM,OAAO,CAAA,KAAA,EAAb,QAAa,CAAb;AAPS,KAAA;AAQZ,QAAI,SAAA,CAAA,GAAA;AAAA,aAAMN,SAAS,CAAA,KAAA,EAAf,2DAAe,CAAf;AARQ,KAAA;AASZ,QAAI,SAAA,CAAA,GAAA;AAAA,aAAMO,QAAQ,CAAA,KAAA,EAAd,GAAc,CAAd;AATQ,KAAA;AAUZ,QAAI,SAAA,CAAA,GAAA;AAAA,aAAMA,QAAQ,CAAA,KAAA,EAAd,GAAc,CAAd;AAVQ,KAAA;AAWZ,QAAI,SAAA,CAAA,GAAA;AAAA,aAAMhB,mBAAmB,CAAA,KAAA,EAAQC,OAAO,CAAxC,EAAyB,CAAzB;AAXQ,KAAA;AAYZ,QAAI,SAAA,CAAA,GAAA;AAAA,aAAMC,mBAAmB,CAAA,KAAA,EAAQD,OAAO,CAAxC,EAAyB,CAAzB;AAZQ,KAAA;AAaZ,QAAI,SAAA,CAAA,GAAA;AAAA,aAAMQ,SAAS,CAAA,KAAA,EAAf,0BAAe,CAAf;AAAA;AAbQ,GAAhB;AAgBA,MAAA,MAAA;;AACA,MAAIG,OAAO,CAAX,IAAW,CAAX,EAAmB;AACff,IAAAA,MAAM,GAAGe,OAAO,CAAhBf,IAAgB,CAAPe,EAATf;AADJ,GAAA,MAEO,IAAI,IAAA,IAAA,IAAYa,IAAI,GAApB,CAAA,EAA0B;AAC7Bb,IAAAA,MAAM,GAAGkB,OAAO,CAAA,KAAA,EAAhBlB,OAAgB,CAAhBA;AADG,GAAA,MAEA,IAAI,KAAA,IAAA,IAAaa,IAAI,GAArB,EAAA,EAA4B;AAC/Bb,IAAAA,MAAM,GAAGG,mBAAmB,CAAA,KAAA,EAAQC,OAAO,CAAPA,MAAAA,CAAeS,IAAI,GAAvDb,EAAoCI,CAAR,CAA5BJ;AADG,GAAA,MAEA,IAAK,KAAA,IAAA,IAAaa,IAAI,GAAtB,EAAA,EAA8B;AACjCb,IAAAA,MAAM,GAAGK,mBAAmB,CAAA,KAAA,EAAQD,OAAO,CAAPA,MAAAA,CAAeS,IAAI,GAAvDb,EAAoCI,CAAR,CAA5BJ;AADG,GAAA,MAEA,IAAK,KAAA,IAAA,IAAaa,IAAI,GAAtB,EAAA,EAA8B;AACjCb,IAAAA,MAAM,GAAGG,mBAAmB,CAAA,KAAA,EAAQC,OAAO,CAAPA,MAAAA,CAAe,KAAKS,IAAI,GAA5Db,EAAmD,CAAfI,CAAR,CAA5BJ;AADG,GAAA,MAEA,IAAK,KAAA,IAAA,IAAaa,IAAI,GAAtB,GAAA,EAA+B;AAClCb,IAAAA,MAAM,GAAGK,mBAAmB,CAAA,KAAA,EAAQD,OAAO,CAAPA,MAAAA,CAAe,KAAKS,IAAI,GAA5Db,GAAmD,CAAfI,CAAR,CAA5BJ;AACH;;AAED,SAAA,MAAA;AACH;AAED;AACA;AACA;AACA;;;AACA,SAAA,WAAA,CAAA,KAAA,EAA4B;AACxB,MAAMoB,UAAU,GAAGJ,KAAK,CAALA,KAAAA,CAAnB,CAAmBA,CAAnB;AAEAA,EAAAA,KAAK,CAALA,MAAAA,GAAAA,CAAAA;AAEA,SAAO,UAAU,CAAV,OAAA,GAAA,GAAA,CAAyB,UAAA,GAAA,EAAe;AAC3C,WAAO,OAAA,GAAA,GAAP,GAAA;AADG,GAAA,EAAA,IAAA,CAAP,EAAO,CAAP;AAGH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAA,KAAA,CAAA,GAAA,EAAA,IAAA,EAA0B;AACtB,MAAMlB,OAAO,GAAb,EAAA;;AAEA,OAAK,IAAIuB,CAAC,GAAV,GAAA,EAAkBA,CAAC,IAAnB,IAAA,EAA6BA,CAA7B,EAAA,EAAkC;AAC9BvB,IAAAA,OAAO,CAAPA,IAAAA,CAAAA,CAAAA;AACH;;AAED,SAAA,OAAA;AACH;AAID;AACA;AACA;AACA;AACA;;;AACA,SAAA,WAAA,CAAA,QAAA,EAA+B;AAC3B,SAAO,UAAA,CAAA,EAAa;AAChB,WAAO,CAACwB,QAAQ,KAARA,IAAAA,IAAqBC,CAAC,CAADA,QAAAA,KAAtB,QAAA,KAAkDD,QAAQ,KAAjE,KAAA;AADJ,GAAA;AAGH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAAA,eAAA,CAAA,IAAA,EAA+B;AAC3BT,EAAAA,IAAI,GAAGC,QAAQ,CAAA,IAAA,EAAfD,EAAe,CAAfA;AACA,MAAIb,MAAM,GAAV,IAAA;;AAEA,MAAIa,IAAI,KAAR,CAAA,EAAgB;AACZb,IAAAA,MAAM,GAANA,KAAAA;AADJ,GAAA,MAEO,IAAIa,IAAI,KAAR,CAAA,EAAgB;AACnBb,IAAAA,MAAM,GAANA,MAAAA;AADG,GAAA,MAEA,IAAK,IAAA,IAAA,IAAYa,IAAI,GAArB,CAAA,EAA4B;AAC/Bb,IAAAA,MAAM,GAANA,WAAAA;AADG,GAAA,MAEA,IAAK,IAAA,IAAA,IAAYa,IAAI,GAArB,CAAA,EAA4B;AAC/Bb,IAAAA,MAAM,GAANA,OAAAA;AADG,GAAA,MAEA,IAAIa,IAAI,KAAR,CAAA,EAAgB;AACnBb,IAAAA,MAAM,GAANA,MAAAA;AADG,GAAA,MAEA,IAAIa,IAAI,KAAR,CAAA,EAAgB;AACnBb,IAAAA,MAAM,GAANA,QAAAA;AADG,GAAA,MAEA,IAAK,KAAA,IAAA,IAAaa,IAAI,GAAlB,EAAC,IAA2BA,IAAI,KAAhC,EAAC,IAA2C,KAAA,IAAA,IAAaA,IAAI,GAAjE,EAAA,EAAyE;AAC5Eb,IAAAA,MAAM,GAANA,kBAAAA;AADG,GAAA,MAEA,IAAK,KAAA,IAAA,IAAaa,IAAI,GAAlB,EAAC,IAA2BA,IAAI,KAAhC,EAAC,IAA2C,KAAA,IAAA,IAAaA,IAAI,GAAjE,GAAA,EAA0E;AAC7Eb,IAAAA,MAAM,GAANA,kBAAAA;AACH;;AAED,SAAA,MAAA;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAAA,QAAA,CAAA,IAAA,EAAA,OAAA,EAAiC;AAC7B,MAAII,OAAO,CAAX,SAAA,EAAuB;AACnB,WAAO/B,QAAQ,CAARA,SAAAA,CAAP,IAAOA,CAAP;AACH;;AAED,SAAA,IAAA;AACH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAA,OAAA,CAAA,KAAA,EAAA,GAAA,EAAA,KAAA,EAAoC;AAChC,MAAI,CAAJ,KAAA,EAAY;AACRmD,IAAAA,KAAK,GAALA,EAAAA;AACH;;AAEDR,EAAAA,KAAK,CAALA,IAAAA,CAAAA,GAAAA;AAEA,SAAA,IAAA,MAAA,CAAA,GAAA,EAAA,MAAA,CAAiBQ,KAAK,GAAA,YAAA,MAAA,CAAA,KAAA,EAAA,IAAA,CAAA,GAAtB,EAAA,EAAA,GAAA,CAAA;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAAA,SAAA,CAAA,KAAA,EAAA,KAAA,EAAiC;AAC7B,SAAON,OAAO,CAAA,KAAA,EAAA,MAAA,EAAd,KAAc,CAAd;AACH;;AAED,SAAA,mBAAA,CAAA,KAAA,EAAA,KAAA,EAA2C;AACvC,SAAOA,OAAO,CAAA,KAAA,EAAA,MAAA,EAAgB,WAA9B,KAAc,CAAd;AACH;;AAED,SAAA,mBAAA,CAAA,KAAA,EAAA,KAAA,EAA2C;AACvC,SAAOA,OAAO,CAAA,KAAA,EAAA,MAAA,EAAgB,sBAA9B,KAAc,CAAd;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAAA,QAAA,CAAA,KAAA,EAAA,KAAA,EAAgC;AAC5B,MAAA,IAAA;;AAEA,MAAIF,KAAK,CAALA,KAAAA,CAAY,CAAZA,CAAAA,EAAAA,CAAAA,MAAJ,KAAA,EAAkC;AAC9BS,IAAAA,IAAI,GAAGT,KAAK,CAAZS,GAAOT,EAAPS;AACH;;AAED,MAAA,IAAA,EAAU;AACN,WAAO,OAAA,KAAA,GAAP,GAAA;AACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAA,QAAA,CAAA,IAAA,EAAA,OAAA,EAAA,QAAA,EAA2C;AACvC,MAAIC,SAAS,GAAb,KAAA;AACA,MAAMC,WAAW,GAAjB,CAAA;;AAEA,WAAA,MAAA,GAAkB;AACd,WAAA,EAAA;AACH;;AAED,WAAA,wBAAA,CAAA,CAAA,EAAA,EAAA,EAAyC;AACrCC,IAAAA,QAAQ,CAAA,oBAAA,EAARA,EAAQ,CAARA;AACA,WAAA,EAAA;AACH;;AAED,WAAA,wBAAA,CAAA,CAAA,EAAA,EAAA,EAAyC;AACrCA,IAAAA,QAAQ,CAAA,oBAAA,EAARA,EAAQ,CAARA;AACA,WAAA,EAAA;AACH;;AAED,WAAA,OAAA,CAAA,CAAA,EAAoB;AAChB,QAAIxB,OAAO,CAAX,OAAA,EAAqB;AACjBwB,MAAAA,QAAQ,CAAA,SAAA,EAAY,CAApBA,CAAQ,CAARA;AADJ,KAAA,MAEO;AACHA,MAAAA,QAAQ,CAAA,MAAA,EAARA,CAAQ,CAARA;AACH;;AAED,WAAA,EAAA;AACH;;AAED,WAAA,QAAA,CAAA,CAAA,EAAA,EAAA,EAAyB;AACrBF,IAAAA,SAAS,GAATA,IAAAA;;AACA,QAAIG,EAAE,CAAFA,IAAAA,GAAAA,MAAAA,KAAJ,CAAA,EAA4B;AACxBA,MAAAA,EAAE,GAAFA,GAAAA;AACH;;AAEDA,IAAAA,EAAE,GAAGA,EAAE,CAAFA,SAAAA,CAAAA,GAAAA,EAAAA,KAAAA,CAALA,GAAKA,CAALA;;AANqB,QAAA,UAAA,GAAA,0BAAA,CAAA,EAAA,CAAA;AAAA,QAAA,MAAA;;AAAA,QAAA;AAQrB,WAAA,UAAA,CAAA,CAAA,EAAA,EAAA,CAAA,CAAA,MAAA,GAAA,UAAA,CAAA,CAAA,EAAA,EAAA,IAAA,GAAoB;AAAA,YAATrC,CAAS,GAAA,MAAA,CAAA,KAAA;AAChBoC,QAAAA,QAAQ,CAAA,SAAA,EAARA,CAAQ,CAARA;AACH;AAVoB,KAAA,CAAA,OAAA,GAAA,EAAA;AAAA,MAAA,UAAA,CAAA,CAAA,CAAA,GAAA;AAAA,KAAA,SAAA;AAAA,MAAA,UAAA,CAAA,CAAA;AAAA;;AAYrB,WAAA,EAAA;AACH;;AAED,WAAA,QAAA,CAAA,CAAA,EAAqB;AACjBA,IAAAA,QAAQ,CAAA,MAAA,EAARA,CAAQ,CAARA;AAEA,WAAA,EAAA;AACH;;AAED,WAAA,GAAA,CAAA,CAAA,EAAgB;AACZA,IAAAA,QAAQ,CAAA,KAAA,EAARA,CAAQ,CAARA;AAEA,WAAA,EAAA;AACH;AAED;;;AACA,MAAME,MAAM,GAAG,CAAC;AACZC,IAAAA,OAAO,EADK,QAAA;AAEZC,IAAAA,GAAG,EAAEC;AAFO,GAAD,EAGZ;AACCF,IAAAA,OAAO,EADR,gBAAA;AAECC,IAAAA,GAAG,EAAEC;AAFN,GAHY,EAMZ;AACCF,IAAAA,OAAO,EADR,YAAA;AAECC,IAAAA,GAAG,EAAEC;AAFN,GANY,EASZ;AACCF,IAAAA,OAAO,EADR,6BAAA;AAECC,IAAAA,GAAG,EAAEtB;AAFN,GATY,EAYZ;AACCqB,IAAAA,OAAO,EADR,oBAAA;AAECC,IAAAA,GAAG,EAAEE;AAFN,GAZY,EAeZ;AACCH,IAAAA,OAAO,EADR,oBAAA;AAECC,IAAAA,GAAG,EAAEG;AAFN,GAfY,EAkBZ;AACCJ,IAAAA,OAAO,EADR,KAAA;AAECC,IAAAA,GAAG,EAAEtD;AAFN,GAlBY,EAqBZ;AACCqD,IAAAA,OAAO,EADR,QAAA;AAECC,IAAAA,GAAG,EAAEtD;AAFN,GArBY,EAwBZ;AACCqD,IAAAA,OAAO,EADR,KAAA;AAECC,IAAAA,GAAG,EAAEtD;AAFN,GAxBY,EA2BZ;AACCqD,IAAAA,OAAO,EADR,2BAAA;AAECC,IAAAA,GAAG,EAAEI;AAFN,GA3BY,EA8BZ;AACC;AACA;AACA;AACA;AACA;AACA;AACA;AACAL,IAAAA,OAAO,EARR,aAAA;AASCC,IAAAA,GAAG,EAAEC;AATN,GA9BY,EAwCZ;AACC;AACA;AACAF,IAAAA,OAAO,EAHR,yBAAA;AAICC,IAAAA,GAAG,EAAEC;AAJN,GAxCY,EA6CZ;AACC;AACAF,IAAAA,OAAO,EAFR,oBAAA;AAGCC,IAAAA,GAAG,EAAEC;AAHN,GA7CY,EAiDZ;AACC;AACR;AACA;AACA;AACA;AACA;AACA;AACQF,IAAAA,OAAO,EARR,uBAAA;AASCC,IAAAA,GAAG,EAAEK;AATN,GAjDY,CAAf;;AA6DA,WAAA,OAAA,CAAA,OAAA,EAAA,CAAA,EAA6B;AACzB,QAAIC,CAAC,GAADA,WAAAA,IAAJ,SAAA,EAAkC;AAC9B;AACH;;AAEDZ,IAAAA,SAAS,GAATA,KAAAA;AAEAa,IAAAA,IAAI,GAAGA,IAAI,CAAJA,OAAAA,CAAaC,OAAO,CAApBD,OAAAA,EAA8BC,OAAO,CAA5CD,GAAOA,CAAPA;AACH;;AAED,MAAME,QAAQ,GAAd,EAAA;AACA,MAAA,KAAA,GAAA,IAAA;AAAA,MAAKC,MAAL,GAAA,KAAA,CAAA,MAAA;;AAEAC,EAAAA,KAAK,EACL,OAAOD,MAAM,GAAb,CAAA,EAAmB;AACf,SAAK,IAAIJ,CAAC,GAAL,CAAA,EAAWM,CAAC,GAAZ,CAAA,EAAkBC,GAAG,GAAGf,MAAM,CAAnC,MAAA,EAA4Cc,CAAC,GAA7C,GAAA,EAAqDN,CAAC,GAAG,EAAzD,CAAA,EAA8D;AAC1D,UAAME,OAAO,GAAGV,MAAM,CAAtB,CAAsB,CAAtB;AACAgB,MAAAA,OAAO,CAAA,OAAA,EAAPA,CAAO,CAAPA;;AAEA,UAAIP,IAAI,CAAJA,MAAAA,KAAJ,MAAA,EAA4B;AACxB;AACA;AACAG,QAAAA,MAAM,GAAGH,IAAI,CAAbG,MAAAA;AACA,iBAAA,KAAA;AACH;AACJ;;AAED,QAAIH,IAAI,CAAJA,MAAAA,KAAJ,MAAA,EAA4B;AACxB;AACH;;AACDE,IAAAA,QAAQ,CAARA,IAAAA,CAAAA,CAAAA;AAEAC,IAAAA,MAAM,GAAGH,IAAI,CAAbG,MAAAA;AACH;;AAED,SAAA,QAAA;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAA,iBAAA,CAAA,WAAA,EAAA,KAAA,EAAA,IAAA,EAAqD;AACjD,MAAI3C,KAAK,KAAT,MAAA,EAAsB;AAClBgD,IAAAA,WAAW,GAAGA,WAAW,CAAXA,MAAAA,CAAmBC,WAAW,CAACC,eAAe,CAA5DF,IAA4D,CAAhB,CAA9BA,CAAdA;AACAA,IAAAA,WAAW,CAAXA,IAAAA,CAAiB;AAAChD,MAAAA,KAAK,EAAN,KAAA;AAAQQ,MAAAA,IAAI,EAAZ,IAAA;AAAce,MAAAA,QAAQ,EAAE2B,eAAe,CAAA,IAAA;AAAvC,KAAjBF;AACH;;AAED,SAAA,WAAA;AACH;;IAEKG,M;AACF;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,WAAA,MAAA,CAAA,OAAA,EAAqB;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,MAAA,CAAA;;AACjB9C,IAAAA,OAAO,GAAGA,OAAO,IAAjBA,EAAAA;;AAEA,QAAIA,OAAO,CAAX,MAAA,EAAoB;AAChBA,MAAAA,OAAO,CAAPA,MAAAA,GAAiB+C,MAAM,CAANA,MAAAA,CAAAA,EAAAA,EAAkB5E,QAAQ,CAA1B4E,MAAAA,EAAmC/C,OAAO,CAA3DA,MAAiB+C,CAAjB/C;AACH;;AAED,SAAA,OAAA,GAAe+C,MAAM,CAANA,MAAAA,CAAAA,EAAAA,EAAAA,QAAAA,EAAf,OAAeA,CAAf;AACA,SAAA,KAAA,GAAA,EAAA;AACA,SAAA,WAAA,GAAA,EAAA;AACH;AACD;AACJ;AACA;AACA;;;;;WACI,SAAA,MAAA,CAAA,KAAA,EAAc;AAAA,UAAA,KAAA,GAAA,IAAA;;AACVC,MAAAA,KAAK,GAAG,OAAA,KAAA,KAAA,QAAA,GAA4B,CAA5B,KAA4B,CAA5B,GAARA,KAAAA;AACA,UAAOpC,KAAP,GAAA,KAAA,KAAA;AAAA,UAAcZ,OAAd,GAAA,KAAA,OAAA;AACA,UAAMiD,GAAG,GAAT,EAAA;AAEA,WAAA,WAAA,CAAA,OAAA,CAAyB,UAAA,OAAA,EAAW;AAChC,YAAMC,MAAM,GAAGC,cAAc,CAAA,KAAA,EAAQC,OAAO,CAAf,KAAA,EAAuBA,OAAO,CAA9B,IAAA,EAA7B,OAA6B,CAA7B;;AAEA,YAAA,MAAA,EAAY;AACRH,UAAAA,GAAG,CAAHA,IAAAA,CAAAA,MAAAA;AACH;AALL,OAAA;AAQAI,MAAAA,QAAQ,CAACL,KAAK,CAALA,IAAAA,CAAD,EAACA,CAAD,EAAA,OAAA,EAA0B,UAAA,KAAA,EAAA,IAAA,EAAiB;AAC/C,YAAME,MAAM,GAAGC,cAAc,CAAA,KAAA,EAAA,KAAA,EAAA,IAAA,EAA7B,OAA6B,CAA7B;;AAEA,YAAA,MAAA,EAAY;AACRF,UAAAA,GAAG,CAAHA,IAAAA,CAAAA,MAAAA;AACH;;AAED,YAAIjD,OAAO,CAAX,MAAA,EAAoB;AAChB,UAAA,KAAI,CAAJ,WAAA,GAAmBsD,iBAAiB,CAAC,KAAI,CAAL,WAAA,EAAA,KAAA,EAApC,IAAoC,CAApC;AACH;AATLD,OAAQ,CAARA;;AAYA,UAAIzC,KAAK,CAAT,MAAA,EAAkB;AACdqC,QAAAA,GAAG,CAAHA,IAAAA,CAASpC,WAAW,CAApBoC,KAAoB,CAApBA;AACH;;AAED,aAAOA,GAAG,CAAHA,IAAAA,CAAP,EAAOA,CAAP;AACH;;;;;;AAGLM,MAAM,CAANA,OAAAA,GAAAA,MAAAA","sourcesContent":["'use strict';\nconst entities = require('entities');\nconst defaults = {\n    fg: '#FFF',\n    bg: '#000',\n    newline: false,\n    escapeXML: false,\n    stream: false,\n    colors: getDefaultColors()\n};\n\nfunction getDefaultColors() {\n    const colors = {\n        0: '#000',\n        1: '#A00',\n        2: '#0A0',\n        3: '#A50',\n        4: '#00A',\n        5: '#A0A',\n        6: '#0AA',\n        7: '#AAA',\n        8: '#555',\n        9: '#F55',\n        10: '#5F5',\n        11: '#FF5',\n        12: '#55F',\n        13: '#F5F',\n        14: '#5FF',\n        15: '#FFF'\n    };\n\n    range(0, 5).forEach(red => {\n        range(0, 5).forEach(green => {\n            range(0, 5).forEach(blue => setStyleColor(red, green, blue, colors));\n        });\n    });\n\n    range(0, 23).forEach(function (gray) {\n        const c = gray + 232;\n        const l = toHexString(gray * 10 + 8);\n\n        colors[c] = '#' + l + l + l;\n    });\n\n    return colors;\n}\n\n/**\n * @param {number} red\n * @param {number} green\n * @param {number} blue\n * @param {object} colors\n */\nfunction setStyleColor(red, green, blue, colors) {\n    const c = 16 + (red * 36) + (green * 6) + blue;\n    const r = red > 0 ? red * 40 + 55 : 0;\n    const g = green > 0 ? green * 40 + 55 : 0;\n    const b = blue > 0 ? blue * 40 + 55 : 0;\n\n    colors[c] = toColorHexString([r, g, b]);\n}\n\n/**\n * Converts from a number like 15 to a hex string like 'F'\n * @param {number} num\n * @returns {string}\n */\nfunction toHexString(num) {\n    let str = num.toString(16);\n\n    while (str.length < 2) {\n        str = '0' + str;\n    }\n\n    return str;\n}\n\n/**\n * Converts from an array of numbers like [15, 15, 15] to a hex string like 'FFF'\n * @param {[red, green, blue]} ref\n * @returns {string}\n */\nfunction toColorHexString(ref) {\n    const results = [];\n\n    for (const r of ref) {\n        results.push(toHexString(r));\n    }\n\n    return '#' + results.join('');\n}\n\n/**\n * @param {Array} stack\n * @param {string} token\n * @param {*} data\n * @param {object} options\n */\nfunction generateOutput(stack, token, data, options) {\n    let result;\n\n    if (token === 'text') {\n        result = pushText(data, options);\n    } else if (token === 'display') {\n        result = handleDisplay(stack, data, options);\n    } else if (token === 'xterm256Foreground') {\n        result = pushForegroundColor(stack, options.colors[data]);\n    } else if (token === 'xterm256Background') {\n        result = pushBackgroundColor(stack, options.colors[data]);\n    } else if (token === 'rgb') {\n        result = handleRgb(stack, data);\n    }\n\n    return result;\n}\n\n/**\n * @param {Array} stack\n * @param {string} data\n * @returns {*}\n */\nfunction handleRgb(stack, data) {\n    data = data.substring(2).slice(0, -1);\n    const operation = +data.substr(0, 2);\n\n    const color = data.substring(5).split(';');\n    const rgb = color.map(function (value) {\n        return ('0' + Number(value).toString(16)).substr(-2);\n    }).join('');\n\n    return pushStyle(stack, (operation === 38 ? 'color:#' : 'background-color:#') + rgb);\n}\n\n/**\n * @param {Array} stack\n * @param {number} code\n * @param {object} options\n * @returns {*}\n */\nfunction handleDisplay(stack, code, options) {\n    code = parseInt(code, 10);\n\n    const codeMap = {\n        '-1': () => '<br/>',\n        0: () => stack.length && resetStyles(stack),\n        1: () => pushTag(stack, 'b'),\n        3: () => pushTag(stack, 'i'),\n        4: () => pushTag(stack, 'u'),\n        8: () => pushStyle(stack, 'display:none'),\n        9: () => pushTag(stack, 'strike'),\n        22: () => pushStyle(stack, 'font-weight:normal;text-decoration:none;font-style:normal'),\n        23: () => closeTag(stack, 'i'),\n        24: () => closeTag(stack, 'u'),\n        39: () => pushForegroundColor(stack, options.fg),\n        49: () => pushBackgroundColor(stack, options.bg),\n        53: () => pushStyle(stack, 'text-decoration:overline')\n    };\n\n    let result;\n    if (codeMap[code]) {\n        result = codeMap[code]();\n    } else if (4 < code && code < 7) {\n        result = pushTag(stack, 'blink');\n    } else if (29 < code && code < 38) {\n        result = pushForegroundColor(stack, options.colors[code - 30]);\n    } else if ((39 < code && code < 48)) {\n        result = pushBackgroundColor(stack, options.colors[code - 40]);\n    } else if ((89 < code && code < 98)) {\n        result = pushForegroundColor(stack, options.colors[8 + (code - 90)]);\n    } else if ((99 < code && code < 108)) {\n        result = pushBackgroundColor(stack, options.colors[8 + (code - 100)]);\n    }\n\n    return result;\n}\n\n/**\n * Clear all the styles\n * @returns {string}\n */\nfunction resetStyles(stack) {\n    const stackClone = stack.slice(0);\n\n    stack.length = 0;\n\n    return stackClone.reverse().map(function (tag) {\n        return '</' + tag + '>';\n    }).join('');\n}\n\n/**\n * Creates an array of numbers ranging from low to high\n * @param {number} low\n * @param {number} high\n * @returns {Array}\n * @example range(3, 7); // creates [3, 4, 5, 6, 7]\n */\nfunction range(low, high) {\n    const results = [];\n\n    for (let j = low; j <= high; j++) {\n        results.push(j);\n    }\n\n    return results;\n}\n\n\n\n/**\n * Returns a new function that is true if value is NOT the same category\n * @param {string} category\n * @returns {function}\n */\nfunction notCategory(category) {\n    return function (e) {\n        return (category === null || e.category !== category) && category !== 'all';\n    };\n}\n\n/**\n * Converts a code into an ansi token type\n * @param {number} code\n * @returns {string}\n */\nfunction categoryForCode(code) {\n    code = parseInt(code, 10);\n    let result = null;\n\n    if (code === 0) {\n        result = 'all';\n    } else if (code === 1) {\n        result = 'bold';\n    } else if ((2 < code && code < 5)) {\n        result = 'underline';\n    } else if ((4 < code && code < 7)) {\n        result = 'blink';\n    } else if (code === 8) {\n        result = 'hide';\n    } else if (code === 9) {\n        result = 'strike';\n    } else if ((29 < code && code < 38) || code === 39 || (89 < code && code < 98)) {\n        result = 'foreground-color';\n    } else if ((39 < code && code < 48) || code === 49 || (99 < code && code < 108)) {\n        result = 'background-color';\n    }\n\n    return result;\n}\n\n/**\n * @param {string} text\n * @param {object} options\n * @returns {string}\n */\nfunction pushText(text, options) {\n    if (options.escapeXML) {\n        return entities.encodeXML(text);\n    }\n\n    return text;\n}\n\n/**\n * @param {Array} stack\n * @param {string} tag\n * @param {string} [style='']\n * @returns {string}\n */\nfunction pushTag(stack, tag, style) {\n    if (!style) {\n        style = '';\n    }\n\n    stack.push(tag);\n\n    return `<${tag}${style ? ` style=\"${style}\"` : ''}>`;\n}\n\n/**\n * @param {Array} stack\n * @param {string} style\n * @returns {string}\n */\nfunction pushStyle(stack, style) {\n    return pushTag(stack, 'span', style);\n}\n\nfunction pushForegroundColor(stack, color) {\n    return pushTag(stack, 'span', 'color:' + color);\n}\n\nfunction pushBackgroundColor(stack, color) {\n    return pushTag(stack, 'span', 'background-color:' + color);\n}\n\n/**\n * @param {Array} stack\n * @param {string} style\n * @returns {string}\n */\nfunction closeTag(stack, style) {\n    let last;\n\n    if (stack.slice(-1)[0] === style) {\n        last = stack.pop();\n    }\n\n    if (last) {\n        return '</' + style + '>';\n    }\n}\n\n/**\n * @param {string} text\n * @param {object} options\n * @param {function} callback\n * @returns {Array}\n */\nfunction tokenize(text, options, callback) {\n    let ansiMatch = false;\n    const ansiHandler = 3;\n\n    function remove() {\n        return '';\n    }\n\n    function removeXterm256Foreground(m, g1) {\n        callback('xterm256Foreground', g1);\n        return '';\n    }\n\n    function removeXterm256Background(m, g1) {\n        callback('xterm256Background', g1);\n        return '';\n    }\n\n    function newline(m) {\n        if (options.newline) {\n            callback('display', -1);\n        } else {\n            callback('text', m);\n        }\n\n        return '';\n    }\n\n    function ansiMess(m, g1) {\n        ansiMatch = true;\n        if (g1.trim().length === 0) {\n            g1 = '0';\n        }\n\n        g1 = g1.trimRight(';').split(';');\n\n        for (const g of g1) {\n            callback('display', g);\n        }\n\n        return '';\n    }\n\n    function realText(m) {\n        callback('text', m);\n\n        return '';\n    }\n\n    function rgb(m) {\n        callback('rgb', m);\n\n        return '';\n    }\n\n    /* eslint no-control-regex:0 */\n    const tokens = [{\n        pattern: /^\\x08+/,\n        sub: remove\n    }, {\n        pattern: /^\\x1b\\[[012]?K/,\n        sub: remove\n    }, {\n        pattern: /^\\x1b\\[\\(B/,\n        sub: remove\n    }, {\n        pattern: /^\\x1b\\[[34]8;2;\\d+;\\d+;\\d+m/,\n        sub: rgb\n    }, {\n        pattern: /^\\x1b\\[38;5;(\\d+)m/,\n        sub: removeXterm256Foreground\n    }, {\n        pattern: /^\\x1b\\[48;5;(\\d+)m/,\n        sub: removeXterm256Background\n    }, {\n        pattern: /^\\n/,\n        sub: newline\n    }, {\n        pattern: /^\\r+\\n/,\n        sub: newline\n    }, {\n        pattern: /^\\r/,\n        sub: newline\n    }, {\n        pattern: /^\\x1b\\[((?:\\d{1,3};?)+|)m/,\n        sub: ansiMess\n    }, {\n        // CSI n J\n        // ED - Erase in Display Clears part of the screen.\n        // If n is 0 (or missing), clear from cursor to end of screen.\n        // If n is 1, clear from cursor to beginning of the screen.\n        // If n is 2, clear entire screen (and moves cursor to upper left on DOS ANSI.SYS).\n        // If n is 3, clear entire screen and delete all lines saved in the scrollback buffer\n        //   (this feature was added for xterm and is supported by other terminal applications).\n        pattern: /^\\x1b\\[\\d?J/,\n        sub: remove\n    }, {\n        // CSI n ; m f\n        // HVP - Horizontal Vertical Position Same as CUP\n        pattern: /^\\x1b\\[\\d{0,3};\\d{0,3}f/,\n        sub: remove\n    }, {\n        // catch-all for CSI sequences?\n        pattern: /^\\x1b\\[?[\\d;]{0,3}/,\n        sub: remove\n    }, {\n        /**\n         * extracts real text - not containing:\n         * - `\\x1b' - ESC - escape (Ascii 27)\n         * - '\\x08' - BS - backspace (Ascii 8)\n         * - `\\n` - Newline - linefeed (LF) (ascii 10)\n         * - `\\r` - Windows Carriage Return (CR)\n         */\n        pattern: /^(([^\\x1b\\x08\\r\\n])+)/,\n        sub: realText\n    }];\n\n    function process(handler, i) {\n        if (i > ansiHandler && ansiMatch) {\n            return;\n        }\n\n        ansiMatch = false;\n\n        text = text.replace(handler.pattern, handler.sub);\n    }\n\n    const results1 = [];\n    let {length} = text;\n\n    outer:\n    while (length > 0) {\n        for (let i = 0, o = 0, len = tokens.length; o < len; i = ++o) {\n            const handler = tokens[i];\n            process(handler, i);\n\n            if (text.length !== length) {\n                // We matched a token and removed it from the text. We need to\n                // start matching *all* tokens against the new text.\n                length = text.length;\n                continue outer;\n            }\n        }\n\n        if (text.length === length) {\n            break;\n        }\n        results1.push(0);\n\n        length = text.length;\n    }\n\n    return results1;\n}\n\n/**\n * If streaming, then the stack is \"sticky\"\n *\n * @param {Array} stickyStack\n * @param {string} token\n * @param {*} data\n * @returns {Array}\n */\nfunction updateStickyStack(stickyStack, token, data) {\n    if (token !== 'text') {\n        stickyStack = stickyStack.filter(notCategory(categoryForCode(data)));\n        stickyStack.push({token, data, category: categoryForCode(data)});\n    }\n\n    return stickyStack;\n}\n\nclass Filter {\n    /**\n     * @param {object} options\n     * @param {string=} options.fg The default foreground color used when reset color codes are encountered.\n     * @param {string=} options.bg The default background color used when reset color codes are encountered.\n     * @param {boolean=} options.newline Convert newline characters to `<br/>`.\n     * @param {boolean=} options.escapeXML Generate HTML/XML entities.\n     * @param {boolean=} options.stream Save style state across invocations of `toHtml()`.\n     * @param {(string[] | {[code: number]: string})=} options.colors Can override specific colors or the entire ANSI palette.\n     */\n    constructor(options) {\n        options = options || {};\n\n        if (options.colors) {\n            options.colors = Object.assign({}, defaults.colors, options.colors);\n        }\n\n        this.options = Object.assign({}, defaults, options);\n        this.stack = [];\n        this.stickyStack = [];\n    }\n    /**\n     * @param {string | string[]} input\n     * @returns {string}\n     */\n    toHtml(input) {\n        input = typeof input === 'string' ? [input] : input;\n        const {stack, options} = this;\n        const buf = [];\n\n        this.stickyStack.forEach(element => {\n            const output = generateOutput(stack, element.token, element.data, options);\n\n            if (output) {\n                buf.push(output);\n            }\n        });\n\n        tokenize(input.join(''), options, (token, data) => {\n            const output = generateOutput(stack, token, data, options);\n\n            if (output) {\n                buf.push(output);\n            }\n\n            if (options.stream) {\n                this.stickyStack = updateStickyStack(this.stickyStack, token, data);\n            }\n        });\n\n        if (stack.length) {\n            buf.push(resetStyles(stack));\n        }\n\n        return buf.join('');\n    }\n}\n\nmodule.exports = Filter;\n"]},"metadata":{},"sourceType":"script"}