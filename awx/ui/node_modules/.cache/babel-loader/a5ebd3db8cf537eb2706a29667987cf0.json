{"ast":null,"code":"import _toConsumableArray from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { viewport } from '../enums';\nimport getViewportRect from './getViewportRect';\nimport getDocumentRect from './getDocumentRect';\nimport listScrollParents from './listScrollParents';\nimport getOffsetParent from './getOffsetParent';\nimport getDocumentElement from './getDocumentElement';\nimport getComputedStyle from './getComputedStyle';\nimport { isElement, isHTMLElement } from './instanceOf';\nimport getBoundingClientRect from './getBoundingClientRect';\nimport getParentNode from './getParentNode';\nimport contains from './contains';\nimport getNodeName from './getNodeName';\nimport rectToClientRect from '../utils/rectToClientRect';\n/**\n * @param element\n */\n\nfunction getInnerBoundingClientRect(element) {\n  var rect = getBoundingClientRect(element);\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\n/**\n * @param element\n * @param clippingParent\n */\n\n\nfunction getClientRectFromMixedType(element, clippingParent) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n/**\n * @param element\n */\n\n\nfunction getClippingParents(element) {\n  var clippingParents = listScrollParents(getParentNode(element));\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // $FlowFixMe: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(function (clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n/**\n * @param element\n * @param boundary\n * @param rootBoundary\n */\n\n\nexport default function getClippingRect(element, boundary, rootBoundary) {\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(_toConsumableArray(mainClippingParents), [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent);\n    accRect.top = Math.max(rect.top, accRect.top);\n    accRect.right = Math.min(rect.right, accRect.right);\n    accRect.bottom = Math.min(rect.bottom, accRect.bottom);\n    accRect.left = Math.max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}","map":{"version":3,"sources":["/awx_devel/awx/ui/node_modules/@patternfly/react-core/src/helpers/Popper/thirdparty/popper-core/dom-utils/getClippingRect.ts"],"names":[],"mappings":"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","sourcesContent":["// @ts-nocheck\nimport { ClientRectObject } from '../types';\nimport { Boundary, RootBoundary } from '../enums';\nimport { viewport } from '../enums';\nimport getViewportRect from './getViewportRect';\nimport getDocumentRect from './getDocumentRect';\nimport listScrollParents from './listScrollParents';\nimport getOffsetParent from './getOffsetParent';\nimport getDocumentElement from './getDocumentElement';\nimport getComputedStyle from './getComputedStyle';\nimport { isElement, isHTMLElement } from './instanceOf';\nimport getBoundingClientRect from './getBoundingClientRect';\nimport getParentNode from './getParentNode';\nimport contains from './contains';\nimport getNodeName from './getNodeName';\nimport rectToClientRect from '../utils/rectToClientRect';\n\n/**\n * @param element\n */\nfunction getInnerBoundingClientRect(element: Element) {\n  const rect = getBoundingClientRect(element);\n\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n\n  return rect;\n}\n\n/**\n * @param element\n * @param clippingParent\n */\nfunction getClientRectFromMixedType(element: Element, clippingParent: Element | RootBoundary): ClientRectObject {\n  return clippingParent === viewport\n    ? rectToClientRect(getViewportRect(element))\n    : isHTMLElement(clippingParent)\n    ? getInnerBoundingClientRect(clippingParent)\n    : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n}\n\n// A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n/**\n * @param element\n */\nfunction getClippingParents(element: Element): Element[] {\n  const clippingParents = listScrollParents(getParentNode(element));\n  const canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  }\n\n  // $FlowFixMe: https://github.com/facebook/flow/issues/1414\n  return clippingParents.filter(\n    clippingParent =>\n      isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body'\n  );\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n/**\n * @param element\n * @param boundary\n * @param rootBoundary\n */\nexport default function getClippingRect(\n  element: Element,\n  boundary: Boundary,\n  rootBoundary: RootBoundary\n): ClientRectObject {\n  const mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  const clippingParents = [...mainClippingParents, rootBoundary];\n  const firstClippingParent = clippingParents[0];\n\n  const clippingRect = clippingParents.reduce((accRect, clippingParent) => {\n    const rect = getClientRectFromMixedType(element, clippingParent);\n\n    accRect.top = Math.max(rect.top, accRect.top);\n    accRect.right = Math.min(rect.right, accRect.right);\n    accRect.bottom = Math.min(rect.bottom, accRect.bottom);\n    accRect.left = Math.max(rect.left, accRect.left);\n\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent));\n\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n\n  return clippingRect;\n}\n"]},"metadata":{},"sourceType":"module"}