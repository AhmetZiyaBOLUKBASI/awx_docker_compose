{"ast":null,"code":"import _defineProperty from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\nimport contains from '../dom-utils/contains';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport within from '../utils/within';\nimport mergePaddingObject from '../utils/mergePaddingObject';\nimport expandToHashMap from '../utils/expandToHashMap';\nimport { left, right, basePlacements, top, bottom } from '../enums';\nimport { isHTMLElement } from '../dom-utils/instanceOf';\n/**\n *\n */\n\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n\n  var state = _ref.state,\n      name = _ref.name;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var basePlacement = getBasePlacement(state.placement);\n  var axis = getMainAxisFromPlacement(basePlacement);\n  var isVertical = [left, right].indexOf(basePlacement) >= 0;\n  var len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  var paddingObject = state.modifiersData[\"\".concat(name, \"#persistent\")].padding;\n  var arrowRect = getLayoutRect(arrowElement);\n  var minProp = axis === 'y' ? top : left;\n  var maxProp = axis === 'y' ? bottom : right;\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = getOffsetParent(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n\n  var min = paddingObject[minProp];\n  var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _defineProperty(_state$modifiersData$, axisProp, offset), _defineProperty(_state$modifiersData$, \"centerOffset\", offset - center), _state$modifiersData$);\n}\n/**\n *\n */\n\n\nfunction effect(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element,\n      _options$padding = options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n\n  if (arrowElement == null) {\n    return;\n  } // CSS selector\n\n\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (false\n  /* __DEV__*/\n  ) {\n    if (!isHTMLElement(arrowElement)) {\n      console.error(['Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));\n    }\n  }\n\n  if (!contains(state.elements.popper, arrowElement)) {\n    if (false\n    /* __DEV__*/\n    ) {\n      console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper', 'element.'].join(' '));\n    }\n\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n  state.modifiersData[\"\".concat(name, \"#persistent\")] = {\n    padding: mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements))\n  };\n}\n\nexport default {\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect: effect,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n};","map":{"version":3,"sources":["/awx_devel/awx/ui/node_modules/@patternfly/react-core/src/helpers/Popper/thirdparty/popper-core/modifiers/arrow.ts"],"names":[],"mappings":"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","sourcesContent":["// @ts-nocheck\nimport { Modifier, ModifierArguments, Padding } from '../types';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\nimport contains from '../dom-utils/contains';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport within from '../utils/within';\nimport mergePaddingObject from '../utils/mergePaddingObject';\nimport expandToHashMap from '../utils/expandToHashMap';\nimport { left, right, basePlacements, top, bottom } from '../enums';\nimport { isHTMLElement } from '../dom-utils/instanceOf';\n\n// eslint-disable-next-line import/no-unused-modules\nexport interface Options {\n  element: HTMLElement | string | null;\n  padding: Padding;\n}\n\n/**\n *\n */\nfunction arrow({ state, name }: ModifierArguments<Options>) {\n  const arrowElement = state.elements.arrow;\n  const popperOffsets = state.modifiersData.popperOffsets;\n  const basePlacement = getBasePlacement(state.placement);\n  const axis = getMainAxisFromPlacement(basePlacement);\n  const isVertical = [left, right].indexOf(basePlacement) >= 0;\n  const len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  const paddingObject = state.modifiersData[`${name}#persistent`].padding;\n  const arrowRect = getLayoutRect(arrowElement);\n  const minProp = axis === 'y' ? top : left;\n  const maxProp = axis === 'y' ? bottom : right;\n\n  const endDiff =\n    state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  const startDiff = popperOffsets[axis] - state.rects.reference[axis];\n\n  const arrowOffsetParent = getOffsetParent(arrowElement);\n  const clientSize = arrowOffsetParent\n    ? axis === 'y'\n      ? arrowOffsetParent.clientHeight || 0\n      : arrowOffsetParent.clientWidth || 0\n    : 0;\n\n  const centerToReference = endDiff / 2 - startDiff / 2;\n\n  // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n  const min = paddingObject[minProp];\n  const max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  const center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  const offset = within(min, center, max);\n\n  // Prevents breaking syntax highlighting...\n  const axisProp: string = axis;\n  state.modifiersData[name] = {\n    [axisProp]: offset,\n    centerOffset: offset - center\n  };\n}\n\n/**\n *\n */\nfunction effect({ state, options, name }: ModifierArguments<Options>) {\n  let { element: arrowElement = '[data-popper-arrow]', padding = 0 } = options;\n\n  if (arrowElement == null) {\n    return;\n  }\n\n  // CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (false /* __DEV__*/) {\n    if (!isHTMLElement(arrowElement)) {\n      console.error(\n        [\n          'Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).',\n          'To use an SVG arrow, wrap it in an HTMLElement that will be used as',\n          'the arrow.'\n        ].join(' ')\n      );\n    }\n  }\n\n  if (!contains(state.elements.popper, arrowElement)) {\n    if (false /* __DEV__*/) {\n      console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper', 'element.'].join(' '));\n    }\n\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n  state.modifiersData[`${name}#persistent`] = {\n    padding: mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements))\n  };\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport type ArrowModifier = Modifier<'arrow', Options>;\nexport default {\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n} as ArrowModifier;\n"]},"metadata":{},"sourceType":"module"}