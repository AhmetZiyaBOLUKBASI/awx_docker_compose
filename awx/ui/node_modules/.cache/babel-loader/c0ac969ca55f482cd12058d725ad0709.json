{"ast":null,"code":"import getVariation from './getVariation';\nimport { variationPlacements, basePlacements, placements as allPlacements } from '../enums';\nimport detectOverflow from './detectOverflow';\nimport getBasePlacement from './getBasePlacement';\n/* :: type OverflowsMap = { [ComputedPlacement]: number }; */\n\n/* ;; type OverflowsMap = { [key in ComputedPlacement]: number }; */\n\n/**\n * @param state\n * @param options\n */\n\nexport default function computeAutoPlacement(state) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var placement = options.placement,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      padding = options.padding,\n      flipVariations = options.flipVariations,\n      _options$allowedAutoP = options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? allPlacements : _options$allowedAutoP;\n  var variation = getVariation(placement);\n  var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n    return getVariation(placement) === variation;\n  }) : basePlacements; // $FlowFixMe\n\n  var allowedPlacements = placements.filter(function (placement) {\n    return allowedAutoPlacements.indexOf(placement) >= 0;\n  });\n\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements;\n\n    if (false\n    /* __DEV__*/\n    ) {\n      console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, \"auto\" cannot be used to allow \"bottom-start\".', 'Use \"auto-start\" instead.'].join(' '));\n    }\n  } // $FlowFixMe: Flow seems to have problems with two array unions...\n\n\n  var overflows = allowedPlacements.reduce(function (acc, placement) {\n    acc[placement] = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding\n    })[getBasePlacement(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function (a, b) {\n    return overflows[a] - overflows[b];\n  });\n}","map":{"version":3,"sources":["/awx_devel/awx/ui/node_modules/@patternfly/react-core/src/helpers/Popper/thirdparty/popper-core/utils/computeAutoPlacement.ts"],"names":[],"mappings":"AAGA,OAAO,YAAP,MAAyB,gBAAzB;AACA,SAAS,mBAAT,EAA8B,cAA9B,EAA8C,UAAU,IAAI,aAA5D,QAAiF,UAAjF;AACA,OAAO,cAAP,MAA2B,kBAA3B;AACA,OAAO,gBAAP,MAA6B,oBAA7B;AAWA;;AAEA;;AAEA;;;AAGG;;AACH,eAAc,SAAU,oBAAV,CAA+B,KAA/B,EAA2E;AAAA,MAArB,OAAqB,uEAAF,EAAE;AACvF,MAAQ,SAAR,GAA8G,OAA9G,CAAQ,SAAR;AAAA,MAAmB,QAAnB,GAA8G,OAA9G,CAAmB,QAAnB;AAAA,MAA6B,YAA7B,GAA8G,OAA9G,CAA6B,YAA7B;AAAA,MAA2C,OAA3C,GAA8G,OAA9G,CAA2C,OAA3C;AAAA,MAAoD,cAApD,GAA8G,OAA9G,CAAoD,cAApD;AAAA,8BAA8G,OAA9G,CAAoE,qBAApE;AAAA,MAAoE,qBAApE,sCAA4F,aAA5F;AAEA,MAAM,SAAS,GAAG,YAAY,CAAC,SAAD,CAA9B;AAEA,MAAM,UAAU,GAAG,SAAS,GACxB,cAAc,GACZ,mBADY,GAEZ,mBAAmB,CAAC,MAApB,CAA2B,UAAA,SAAS;AAAA,WAAI,YAAY,CAAC,SAAD,CAAZ,KAA4B,SAAhC;AAAA,GAApC,CAHsB,GAIxB,cAJJ,CALuF,CAWvF;;AACA,MAAI,iBAAiB,GAAG,UAAU,CAAC,MAAX,CAAkB,UAAA,SAAS;AAAA,WAAI,qBAAqB,CAAC,OAAtB,CAA8B,SAA9B,KAA4C,CAAhD;AAAA,GAA3B,CAAxB;;AAEA,MAAI,iBAAiB,CAAC,MAAlB,KAA6B,CAAjC,EAAoC;AAClC,IAAA,iBAAiB,GAAG,UAApB;;AAEA,QAAI;AAAM;AAAV,MAAwB;AACtB,MAAA,OAAO,CAAC,KAAR,CACE,CACE,8DADF,EAEE,iEAFF,EAGE,4BAHF,EAIE,6DAJF,EAKE,2BALF,EAME,IANF,CAMO,GANP,CADF;AASD;AACF,GA5BsF,CA8BvF;;;AACA,MAAM,SAAS,GAAiB,iBAAiB,CAAC,MAAlB,CAAyB,UAAC,GAAD,EAAM,SAAN,EAAmB;AAC1E,IAAA,GAAG,CAAC,SAAD,CAAH,GAAiB,cAAc,CAAC,KAAD,EAAQ;AACrC,MAAA,SAAS,EAAT,SADqC;AAErC,MAAA,QAAQ,EAAR,QAFqC;AAGrC,MAAA,YAAY,EAAZ,YAHqC;AAIrC,MAAA,OAAO,EAAP;AAJqC,KAAR,CAAd,CAKd,gBAAgB,CAAC,SAAD,CALF,CAAjB;AAOA,WAAO,GAAP;AACD,GAT+B,EAS7B,EAT6B,CAAhC;AAWA,SAAO,MAAM,CAAC,IAAP,CAAY,SAAZ,EAAuB,IAAvB,CAA4B,UAAC,CAAD,EAAI,CAAJ;AAAA,WAAU,SAAS,CAAC,CAAD,CAAT,GAAe,SAAS,CAAC,CAAD,CAAlC;AAAA,GAA5B,CAAP;AACD","sourcesContent":["// @ts-nocheck\nimport { State, Padding } from '../types';\nimport { Placement, ComputedPlacement, Boundary, RootBoundary } from '../enums';\nimport getVariation from './getVariation';\nimport { variationPlacements, basePlacements, placements as allPlacements } from '../enums';\nimport detectOverflow from './detectOverflow';\nimport getBasePlacement from './getBasePlacement';\n\ninterface Options {\n  placement: Placement;\n  padding: Padding;\n  boundary: Boundary;\n  rootBoundary: RootBoundary;\n  flipVariations: boolean;\n  allowedAutoPlacements?: Placement[];\n}\n\n/* :: type OverflowsMap = { [ComputedPlacement]: number }; */\n\n/* ;; type OverflowsMap = { [key in ComputedPlacement]: number }; */\n\n/**\n * @param state\n * @param options\n */\nexport default function computeAutoPlacement(state: Partial<State>, options: Options = {}): ComputedPlacement[] {\n  const { placement, boundary, rootBoundary, padding, flipVariations, allowedAutoPlacements = allPlacements } = options;\n\n  const variation = getVariation(placement);\n\n  const placements = variation\n    ? flipVariations\n      ? variationPlacements\n      : variationPlacements.filter(placement => getVariation(placement) === variation)\n    : basePlacements;\n\n  // $FlowFixMe\n  let allowedPlacements = placements.filter(placement => allowedAutoPlacements.indexOf(placement) >= 0);\n\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements;\n\n    if (false /* __DEV__*/) {\n      console.error(\n        [\n          'Popper: The `allowedAutoPlacements` option did not allow any',\n          'placements. Ensure the `placement` option matches the variation',\n          'of the allowed placements.',\n          'For example, \"auto\" cannot be used to allow \"bottom-start\".',\n          'Use \"auto-start\" instead.'\n        ].join(' ')\n      );\n    }\n  }\n\n  // $FlowFixMe: Flow seems to have problems with two array unions...\n  const overflows: OverflowsMap = allowedPlacements.reduce((acc, placement) => {\n    acc[placement] = detectOverflow(state, {\n      placement,\n      boundary,\n      rootBoundary,\n      padding\n    })[getBasePlacement(placement)];\n\n    return acc;\n  }, {});\n\n  return Object.keys(overflows).sort((a, b) => overflows[a] - overflows[b]);\n}\n"]},"metadata":{},"sourceType":"module"}