{"ast":null,"code":"import { __rest } from \"tslib\";\nimport * as React from 'react';\nimport styles from '@patternfly/react-styles/css/components/Menu/menu';\nimport { css } from '@patternfly/react-styles';\nimport { MenuContext } from './MenuContext';\nexport var MenuContent = React.forwardRef(function (props, ref) {\n  var getHeight = props.getHeight,\n      children = props.children,\n      menuHeight = props.menuHeight,\n      maxMenuHeight = props.maxMenuHeight,\n      rest = __rest(props, [\"getHeight\", \"children\", \"menuHeight\", \"maxMenuHeight\"]);\n\n  var menuContentRef = React.createRef();\n\n  var refCallback = function refCallback(el, menuId, onGetMenuHeight) {\n    if (el) {\n      var clientHeight = el.clientHeight; // if this menu is a submenu, we need to account for the root menu list's padding and root menu content's border.\n\n      var rootMenuList = null;\n      var parentEl = el.closest(\".\".concat(styles.menuList));\n\n      while (parentEl !== null && parentEl.nodeType === 1) {\n        if (parentEl.classList.contains(styles.menuList)) {\n          rootMenuList = parentEl;\n        }\n\n        parentEl = parentEl.parentElement;\n      }\n\n      if (rootMenuList) {\n        var rootMenuListStyles = getComputedStyle(rootMenuList);\n        var rootMenuListPaddingOffset = parseFloat(rootMenuListStyles.getPropertyValue('padding-top').replace(/px/g, '')) + parseFloat(rootMenuListStyles.getPropertyValue('padding-bottom').replace(/px/g, '')) + parseFloat(getComputedStyle(rootMenuList.parentElement).getPropertyValue('border-bottom-width').replace(/px/g, ''));\n        clientHeight = clientHeight + rootMenuListPaddingOffset;\n      }\n\n      onGetMenuHeight && onGetMenuHeight(menuId, clientHeight);\n      getHeight && getHeight(clientHeight.toString());\n    }\n\n    return ref || menuContentRef;\n  };\n\n  return React.createElement(MenuContext.Consumer, null, function (_ref) {\n    var menuId = _ref.menuId,\n        onGetMenuHeight = _ref.onGetMenuHeight;\n    return React.createElement(\"div\", Object.assign({}, rest, {\n      className: css(styles.menuContent, props.className),\n      ref: function ref(el) {\n        return refCallback(el, menuId, onGetMenuHeight);\n      },\n      style: Object.assign(Object.assign({}, menuHeight && {\n        '--pf-c-menu__content--Height': menuHeight\n      }), maxMenuHeight && {\n        '--pf-c-menu__content--MaxHeight': maxMenuHeight\n      })\n    }), children);\n  });\n});\nMenuContent.displayName = 'MenuContent';","map":{"version":3,"sources":["/awx_devel/awx/ui/node_modules/@patternfly/react-core/src/components/Menu/MenuContent.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport styles from '@patternfly/react-styles/css/components/Menu/menu';\nimport { css } from '@patternfly/react-styles';\nimport { MenuContext } from './MenuContext';\n\nexport interface MenuContentProps extends React.HTMLProps<HTMLElement> {\n  /** Items within group */\n  children?: React.ReactNode;\n  /** Forwarded ref */\n  innerRef?: React.Ref<any>;\n  /** Height of the menu content */\n  menuHeight?: string;\n  /** Maximum height of menu content */\n  maxMenuHeight?: string;\n  /** Callback to return the height of the menu content */\n  getHeight?: (height: string) => void;\n}\n\nexport const MenuContent = React.forwardRef((props: MenuContentProps, ref: React.Ref<HTMLDivElement>) => {\n  const { getHeight, children, menuHeight, maxMenuHeight, ...rest } = props;\n  const menuContentRef = React.createRef<HTMLDivElement>();\n  const refCallback = (el: HTMLElement, menuId: string, onGetMenuHeight: (menuId: string, height: number) => void) => {\n    if (el) {\n      let clientHeight = el.clientHeight;\n\n      // if this menu is a submenu, we need to account for the root menu list's padding and root menu content's border.\n      let rootMenuList = null;\n      let parentEl = el.closest(`.${styles.menuList}`);\n      while (parentEl !== null && parentEl.nodeType === 1) {\n        if (parentEl.classList.contains(styles.menuList)) {\n          rootMenuList = parentEl;\n        }\n        parentEl = parentEl.parentElement;\n      }\n\n      if (rootMenuList) {\n        const rootMenuListStyles = getComputedStyle(rootMenuList);\n        const rootMenuListPaddingOffset =\n          parseFloat(rootMenuListStyles.getPropertyValue('padding-top').replace(/px/g, '')) +\n          parseFloat(rootMenuListStyles.getPropertyValue('padding-bottom').replace(/px/g, '')) +\n          parseFloat(\n            getComputedStyle(rootMenuList.parentElement)\n              .getPropertyValue('border-bottom-width')\n              .replace(/px/g, '')\n          );\n        clientHeight = clientHeight + rootMenuListPaddingOffset;\n      }\n\n      onGetMenuHeight && onGetMenuHeight(menuId, clientHeight);\n      getHeight && getHeight(clientHeight.toString());\n    }\n    return ref || menuContentRef;\n  };\n  return (\n    <MenuContext.Consumer>\n      {({ menuId, onGetMenuHeight }) => (\n        <div\n          {...rest}\n          className={css(styles.menuContent, props.className)}\n          ref={el => refCallback(el, menuId, onGetMenuHeight)}\n          style={\n            {\n              ...(menuHeight && { '--pf-c-menu__content--Height': menuHeight }),\n              ...(maxMenuHeight && { '--pf-c-menu__content--MaxHeight': maxMenuHeight })\n            } as React.CSSProperties\n          }\n        >\n          {children}\n        </div>\n      )}\n    </MenuContext.Consumer>\n  );\n});\nMenuContent.displayName = 'MenuContent';\n"]},"metadata":{},"sourceType":"module"}