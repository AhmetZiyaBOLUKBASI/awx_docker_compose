{"ast":null,"code":"import _toConsumableArray from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport getOppositePlacement from '../utils/getOppositePlacement';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getOppositeVariationPlacement from '../utils/getOppositeVariationPlacement';\nimport detectOverflow from '../utils/detectOverflow';\nimport computeAutoPlacement from '../utils/computeAutoPlacement';\nimport { bottom, top, start, right, left, auto } from '../enums';\nimport getVariation from '../utils/getVariation';\n/**\n * @param placement\n */\n\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\n/**\n *\n */\n\n\nfunction flip(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = getBasePlacement(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(_toConsumableArray(fallbackPlacements)).reduce(function (acc, placement) {\n    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n\n    var _basePlacement = getBasePlacement(placement);\n\n    var isStartVariation = getVariation(placement) === start;\n    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? 'width' : 'height';\n    var overflow = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n\n    var altVariationSide = getOppositePlacement(mainVariationSide);\n    var checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases – research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n\n      if (_ret === \"break\") break;\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n}\n\nexport default {\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n};","map":{"version":3,"sources":["/awx_devel/awx/ui/node_modules/@patternfly/react-core/src/helpers/Popper/thirdparty/popper-core/modifiers/flip.ts"],"names":[],"mappings":"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","sourcesContent":["// @ts-nocheck\nimport { Placement, Boundary, RootBoundary } from '../enums';\nimport { ModifierArguments, Modifier, Padding } from '../types';\nimport getOppositePlacement from '../utils/getOppositePlacement';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getOppositeVariationPlacement from '../utils/getOppositeVariationPlacement';\nimport detectOverflow from '../utils/detectOverflow';\nimport computeAutoPlacement from '../utils/computeAutoPlacement';\nimport { bottom, top, start, right, left, auto } from '../enums';\nimport getVariation from '../utils/getVariation';\n\n// eslint-disable-next-line import/no-unused-modules\nexport interface Options {\n  mainAxis: boolean;\n  altAxis: boolean;\n  fallbackPlacements: Placement[];\n  padding: Padding;\n  boundary: Boundary;\n  rootBoundary: RootBoundary;\n  altBoundary: boolean;\n  flipVariations: boolean;\n  allowedAutoPlacements: Placement[];\n}\n\n/**\n * @param placement\n */\nfunction getExpandedFallbackPlacements(placement: Placement): Placement[] {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n\n  const oppositePlacement = getOppositePlacement(placement);\n\n  return [\n    getOppositeVariationPlacement(placement),\n    oppositePlacement,\n    getOppositeVariationPlacement(oppositePlacement)\n  ];\n}\n\n/**\n *\n */\nfunction flip({ state, options, name }: ModifierArguments<Options>) {\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  const {\n    mainAxis: checkMainAxis = true,\n    altAxis: checkAltAxis = true,\n    fallbackPlacements: specifiedFallbackPlacements,\n    padding,\n    boundary,\n    rootBoundary,\n    altBoundary,\n    flipVariations = true,\n    allowedAutoPlacements\n  } = options;\n\n  const preferredPlacement = state.options.placement;\n  const basePlacement = getBasePlacement(preferredPlacement);\n  const isBasePlacement = basePlacement === preferredPlacement;\n\n  const fallbackPlacements =\n    specifiedFallbackPlacements ||\n    (isBasePlacement || !flipVariations\n      ? [getOppositePlacement(preferredPlacement)]\n      : getExpandedFallbackPlacements(preferredPlacement));\n\n  const placements = [preferredPlacement, ...fallbackPlacements].reduce(\n    (acc, placement) =>\n      acc.concat(\n        getBasePlacement(placement) === auto\n          ? computeAutoPlacement(state, {\n              placement,\n              boundary,\n              rootBoundary,\n              padding,\n              flipVariations,\n              allowedAutoPlacements\n            })\n          : placement\n      ),\n    []\n  );\n\n  const referenceRect = state.rects.reference;\n  const popperRect = state.rects.popper;\n\n  const checksMap = new Map();\n  let makeFallbackChecks = true;\n  let firstFittingPlacement = placements[0];\n\n  for (let i = 0; i < placements.length; i++) {\n    const placement = placements[i];\n    const basePlacement = getBasePlacement(placement);\n    const isStartVariation = getVariation(placement) === start;\n    const isVertical = [top, bottom].indexOf(basePlacement) >= 0;\n    const len = isVertical ? 'width' : 'height';\n\n    const overflow = detectOverflow(state, {\n      placement,\n      boundary,\n      rootBoundary,\n      altBoundary,\n      padding\n    });\n\n    let mainVariationSide: any = isVertical ? (isStartVariation ? right : left) : isStartVariation ? bottom : top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n\n    const altVariationSide: any = getOppositePlacement(mainVariationSide);\n\n    const checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(check => check)) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases – research later\n    const numberOfChecks = flipVariations ? 3 : 1;\n\n    for (let i = numberOfChecks; i > 0; i--) {\n      const fittingPlacement = placements.find(placement => {\n        const checks = checksMap.get(placement);\n        if (checks) {\n          return checks.slice(0, i).every(check => check);\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        break;\n      }\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport type FlipModifier = Modifier<'flip', Options>;\nexport default {\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: { _skip: false }\n} as FlipModifier;\n"]},"metadata":{},"sourceType":"module"}