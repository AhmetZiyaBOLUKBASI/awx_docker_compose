{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { RRule } from './rrule';\nimport { RRuleSet } from './rruleset';\nimport dateutil from './dateutil';\nimport { includes, split } from './helpers';\nimport { parseString, parseDtstart } from './parsestring';\n/**\n * RRuleStr\n * To parse a set of rrule strings\n */\n\nvar DEFAULT_OPTIONS = {\n  dtstart: null,\n  cache: false,\n  unfold: false,\n  forceset: false,\n  compatible: false,\n  tzid: null\n};\nexport function parseInput(s, options) {\n  var rrulevals = [];\n  var rdatevals = [];\n  var exrulevals = [];\n  var exdatevals = [];\n  var parsedDtstart = parseDtstart(s);\n  var dtstart = parsedDtstart.dtstart;\n  var tzid = parsedDtstart.tzid;\n  var lines = splitIntoLines(s, options.unfold);\n  lines.forEach(function (line) {\n    var _a;\n\n    if (!line) return;\n\n    var _b = breakDownLine(line),\n        name = _b.name,\n        parms = _b.parms,\n        value = _b.value;\n\n    switch (name.toUpperCase()) {\n      case 'RRULE':\n        if (parms.length) {\n          throw new Error(\"unsupported RRULE parm: \".concat(parms.join(',')));\n        }\n\n        rrulevals.push(parseString(line));\n        break;\n\n      case 'RDATE':\n        var _c = (_a = /RDATE(?:;TZID=([^:=]+))?/i.exec(line)) !== null && _a !== void 0 ? _a : [],\n            rdateTzid = _c[1];\n\n        if (rdateTzid && !tzid) {\n          tzid = rdateTzid;\n        }\n\n        rdatevals = rdatevals.concat(parseRDate(value, parms));\n        break;\n\n      case 'EXRULE':\n        if (parms.length) {\n          throw new Error(\"unsupported EXRULE parm: \".concat(parms.join(',')));\n        }\n\n        exrulevals.push(parseString(value));\n        break;\n\n      case 'EXDATE':\n        exdatevals = exdatevals.concat(parseRDate(value, parms));\n        break;\n\n      case 'DTSTART':\n        break;\n\n      default:\n        throw new Error('unsupported property: ' + name);\n    }\n  });\n  return {\n    dtstart: dtstart,\n    tzid: tzid,\n    rrulevals: rrulevals,\n    rdatevals: rdatevals,\n    exrulevals: exrulevals,\n    exdatevals: exdatevals\n  };\n}\n\nfunction buildRule(s, options) {\n  var _a = parseInput(s, options),\n      rrulevals = _a.rrulevals,\n      rdatevals = _a.rdatevals,\n      exrulevals = _a.exrulevals,\n      exdatevals = _a.exdatevals,\n      dtstart = _a.dtstart,\n      tzid = _a.tzid;\n\n  var noCache = options.cache === false;\n\n  if (options.compatible) {\n    options.forceset = true;\n    options.unfold = true;\n  }\n\n  if (options.forceset || rrulevals.length > 1 || rdatevals.length || exrulevals.length || exdatevals.length) {\n    var rset_1 = new RRuleSet(noCache);\n    rset_1.dtstart(dtstart);\n    rset_1.tzid(tzid || undefined);\n    rrulevals.forEach(function (val) {\n      rset_1.rrule(new RRule(groomRruleOptions(val, dtstart, tzid), noCache));\n    });\n    rdatevals.forEach(function (date) {\n      rset_1.rdate(date);\n    });\n    exrulevals.forEach(function (val) {\n      rset_1.exrule(new RRule(groomRruleOptions(val, dtstart, tzid), noCache));\n    });\n    exdatevals.forEach(function (date) {\n      rset_1.exdate(date);\n    });\n    if (options.compatible && options.dtstart) rset_1.rdate(dtstart);\n    return rset_1;\n  }\n\n  var val = rrulevals[0] || {};\n  return new RRule(groomRruleOptions(val, val.dtstart || options.dtstart || dtstart, val.tzid || options.tzid || tzid), noCache);\n}\n\nexport function rrulestr(s, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return buildRule(s, initializeOptions(options));\n}\n\nfunction groomRruleOptions(val, dtstart, tzid) {\n  return __assign(__assign({}, val), {\n    dtstart: dtstart,\n    tzid: tzid\n  });\n}\n\nfunction initializeOptions(options) {\n  var invalid = [];\n  var keys = Object.keys(options);\n  var defaultKeys = Object.keys(DEFAULT_OPTIONS);\n  keys.forEach(function (key) {\n    if (!includes(defaultKeys, key)) invalid.push(key);\n  });\n\n  if (invalid.length) {\n    throw new Error('Invalid options: ' + invalid.join(', '));\n  }\n\n  return __assign(__assign({}, DEFAULT_OPTIONS), options);\n}\n\nfunction extractName(line) {\n  if (line.indexOf(':') === -1) {\n    return {\n      name: 'RRULE',\n      value: line\n    };\n  }\n\n  var _a = split(line, ':', 1),\n      name = _a[0],\n      value = _a[1];\n\n  return {\n    name: name,\n    value: value\n  };\n}\n\nfunction breakDownLine(line) {\n  var _a = extractName(line),\n      name = _a.name,\n      value = _a.value;\n\n  var parms = name.split(';');\n  if (!parms) throw new Error('empty property name');\n  return {\n    name: parms[0].toUpperCase(),\n    parms: parms.slice(1),\n    value: value\n  };\n}\n\nfunction splitIntoLines(s, unfold) {\n  if (unfold === void 0) {\n    unfold = false;\n  }\n\n  s = s && s.trim();\n  if (!s) throw new Error('Invalid empty string'); // More info about 'unfold' option\n  // Go head to http://www.ietf.org/rfc/rfc2445.txt\n\n  if (!unfold) {\n    return s.split(/\\s/);\n  }\n\n  var lines = s.split('\\n');\n  var i = 0;\n\n  while (i < lines.length) {\n    // TODO\n    var line = lines[i] = lines[i].replace(/\\s+$/g, '');\n\n    if (!line) {\n      lines.splice(i, 1);\n    } else if (i > 0 && line[0] === ' ') {\n      lines[i - 1] += line.slice(1);\n      lines.splice(i, 1);\n    } else {\n      i += 1;\n    }\n  }\n\n  return lines;\n}\n\nfunction validateDateParm(parms) {\n  parms.forEach(function (parm) {\n    if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(parm)) {\n      throw new Error('unsupported RDATE/EXDATE parm: ' + parm);\n    }\n  });\n}\n\nfunction parseRDate(rdateval, parms) {\n  validateDateParm(parms);\n  return rdateval.split(',').map(function (datestr) {\n    return dateutil.untilStringToDate(datestr);\n  });\n}","map":{"version":3,"sources":["../../src/rrulestr.ts"],"names":[],"mappings":"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","sourcesContent":["import { __assign } from \"tslib\";\nimport { RRule } from './rrule';\nimport { RRuleSet } from './rruleset';\nimport dateutil from './dateutil';\nimport { includes, split } from './helpers';\nimport { parseString, parseDtstart } from './parsestring';\n/**\n * RRuleStr\n * To parse a set of rrule strings\n */\nvar DEFAULT_OPTIONS = {\n    dtstart: null,\n    cache: false,\n    unfold: false,\n    forceset: false,\n    compatible: false,\n    tzid: null,\n};\nexport function parseInput(s, options) {\n    var rrulevals = [];\n    var rdatevals = [];\n    var exrulevals = [];\n    var exdatevals = [];\n    var parsedDtstart = parseDtstart(s);\n    var dtstart = parsedDtstart.dtstart;\n    var tzid = parsedDtstart.tzid;\n    var lines = splitIntoLines(s, options.unfold);\n    lines.forEach(function (line) {\n        var _a;\n        if (!line)\n            return;\n        var _b = breakDownLine(line), name = _b.name, parms = _b.parms, value = _b.value;\n        switch (name.toUpperCase()) {\n            case 'RRULE':\n                if (parms.length) {\n                    throw new Error(\"unsupported RRULE parm: \".concat(parms.join(',')));\n                }\n                rrulevals.push(parseString(line));\n                break;\n            case 'RDATE':\n                var _c = (_a = /RDATE(?:;TZID=([^:=]+))?/i.exec(line)) !== null && _a !== void 0 ? _a : [], rdateTzid = _c[1];\n                if (rdateTzid && !tzid) {\n                    tzid = rdateTzid;\n                }\n                rdatevals = rdatevals.concat(parseRDate(value, parms));\n                break;\n            case 'EXRULE':\n                if (parms.length) {\n                    throw new Error(\"unsupported EXRULE parm: \".concat(parms.join(',')));\n                }\n                exrulevals.push(parseString(value));\n                break;\n            case 'EXDATE':\n                exdatevals = exdatevals.concat(parseRDate(value, parms));\n                break;\n            case 'DTSTART':\n                break;\n            default:\n                throw new Error('unsupported property: ' + name);\n        }\n    });\n    return {\n        dtstart: dtstart,\n        tzid: tzid,\n        rrulevals: rrulevals,\n        rdatevals: rdatevals,\n        exrulevals: exrulevals,\n        exdatevals: exdatevals,\n    };\n}\nfunction buildRule(s, options) {\n    var _a = parseInput(s, options), rrulevals = _a.rrulevals, rdatevals = _a.rdatevals, exrulevals = _a.exrulevals, exdatevals = _a.exdatevals, dtstart = _a.dtstart, tzid = _a.tzid;\n    var noCache = options.cache === false;\n    if (options.compatible) {\n        options.forceset = true;\n        options.unfold = true;\n    }\n    if (options.forceset ||\n        rrulevals.length > 1 ||\n        rdatevals.length ||\n        exrulevals.length ||\n        exdatevals.length) {\n        var rset_1 = new RRuleSet(noCache);\n        rset_1.dtstart(dtstart);\n        rset_1.tzid(tzid || undefined);\n        rrulevals.forEach(function (val) {\n            rset_1.rrule(new RRule(groomRruleOptions(val, dtstart, tzid), noCache));\n        });\n        rdatevals.forEach(function (date) {\n            rset_1.rdate(date);\n        });\n        exrulevals.forEach(function (val) {\n            rset_1.exrule(new RRule(groomRruleOptions(val, dtstart, tzid), noCache));\n        });\n        exdatevals.forEach(function (date) {\n            rset_1.exdate(date);\n        });\n        if (options.compatible && options.dtstart)\n            rset_1.rdate(dtstart);\n        return rset_1;\n    }\n    var val = rrulevals[0] || {};\n    return new RRule(groomRruleOptions(val, val.dtstart || options.dtstart || dtstart, val.tzid || options.tzid || tzid), noCache);\n}\nexport function rrulestr(s, options) {\n    if (options === void 0) { options = {}; }\n    return buildRule(s, initializeOptions(options));\n}\nfunction groomRruleOptions(val, dtstart, tzid) {\n    return __assign(__assign({}, val), { dtstart: dtstart, tzid: tzid });\n}\nfunction initializeOptions(options) {\n    var invalid = [];\n    var keys = Object.keys(options);\n    var defaultKeys = Object.keys(DEFAULT_OPTIONS);\n    keys.forEach(function (key) {\n        if (!includes(defaultKeys, key))\n            invalid.push(key);\n    });\n    if (invalid.length) {\n        throw new Error('Invalid options: ' + invalid.join(', '));\n    }\n    return __assign(__assign({}, DEFAULT_OPTIONS), options);\n}\nfunction extractName(line) {\n    if (line.indexOf(':') === -1) {\n        return {\n            name: 'RRULE',\n            value: line,\n        };\n    }\n    var _a = split(line, ':', 1), name = _a[0], value = _a[1];\n    return {\n        name: name,\n        value: value,\n    };\n}\nfunction breakDownLine(line) {\n    var _a = extractName(line), name = _a.name, value = _a.value;\n    var parms = name.split(';');\n    if (!parms)\n        throw new Error('empty property name');\n    return {\n        name: parms[0].toUpperCase(),\n        parms: parms.slice(1),\n        value: value,\n    };\n}\nfunction splitIntoLines(s, unfold) {\n    if (unfold === void 0) { unfold = false; }\n    s = s && s.trim();\n    if (!s)\n        throw new Error('Invalid empty string');\n    // More info about 'unfold' option\n    // Go head to http://www.ietf.org/rfc/rfc2445.txt\n    if (!unfold) {\n        return s.split(/\\s/);\n    }\n    var lines = s.split('\\n');\n    var i = 0;\n    while (i < lines.length) {\n        // TODO\n        var line = (lines[i] = lines[i].replace(/\\s+$/g, ''));\n        if (!line) {\n            lines.splice(i, 1);\n        }\n        else if (i > 0 && line[0] === ' ') {\n            lines[i - 1] += line.slice(1);\n            lines.splice(i, 1);\n        }\n        else {\n            i += 1;\n        }\n    }\n    return lines;\n}\nfunction validateDateParm(parms) {\n    parms.forEach(function (parm) {\n        if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(parm)) {\n            throw new Error('unsupported RDATE/EXDATE parm: ' + parm);\n        }\n    });\n}\nfunction parseRDate(rdateval, parms) {\n    validateDateParm(parms);\n    return rdateval\n        .split(',')\n        .map(function (datestr) { return dateutil.untilStringToDate(datestr); });\n}\n"]},"metadata":{},"sourceType":"module"}