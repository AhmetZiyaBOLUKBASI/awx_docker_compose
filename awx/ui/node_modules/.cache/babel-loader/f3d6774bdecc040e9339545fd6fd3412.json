{"ast":null,"code":"import _classCallCheck from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport * as React from 'react';\nimport { canUseDOM } from './util';\n/**\n * This function is a helper for handling basic arrow keyboard interactions. If a component already has its own key handler and event start up/tear down, this function may be easier to integrate in over the full component.\n *\n * @param {event} event Event triggered by the keyboard\n * @param {element[]} navigableElements Valid traversable elements of the container\n * @param {function} isActiveElement Callback to determine if a given element from the navigable elements array is the active element of the page\n * @param {function} getFocusableElement Callback returning the focusable element of a given element from the navigable elements array\n * @param {string[]} validSiblingTags Valid sibling tags that horizontal arrow handling will focus\n * @param {boolean} noVerticalArrowHandling Flag indicating that the included vertical arrow key handling should be ignored\n * @param {boolean} noHorizontalArrowHandling Flag indicating that the included horizontal arrow key handling should be ignored\n * @param {boolean} updateTabIndex Flag indicating that the tabIndex of the currently focused element and next focused element should be updated, in the case of using a roving tabIndex\n * @param {boolean} onlyTraverseSiblings Flag indicating that next focusable element of a horizontal movement will be this element's sibling\n */\n\nexport var handleArrows = function handleArrows(event, navigableElements) {\n  var isActiveElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (element) {\n    return document.activeElement.contains(element);\n  };\n  var getFocusableElement = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (element) {\n    return element;\n  };\n  var validSiblingTags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ['A', 'BUTTON', 'INPUT'];\n  var noVerticalArrowHandling = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var noHorizontalArrowHandling = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  var updateTabIndex = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;\n  var onlyTraverseSiblings = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : true;\n  var activeElement = document.activeElement;\n  var key = event.key;\n  var moveTarget = null; // Handle vertical arrow keys. If noVerticalArrowHandling is passed, skip this block\n\n  if (!noVerticalArrowHandling) {\n    if (['ArrowUp', 'ArrowDown'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n      // Traverse navigableElements to find the element which is currently active\n\n      var currentIndex = -1; // while (currentIndex === -1) {\n\n      navigableElements.forEach(function (element, index) {\n        if (isActiveElement(element)) {\n          // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n          var increment = 0; // keep increasing the increment until you've tried the whole navigableElement\n\n          while (!moveTarget && increment < navigableElements.length && increment * -1 < navigableElements.length) {\n            key === 'ArrowUp' ? increment-- : increment++;\n            currentIndex = index + increment;\n\n            if (currentIndex >= navigableElements.length) {\n              currentIndex = 0;\n            }\n\n            if (currentIndex < 0) {\n              currentIndex = navigableElements.length - 1;\n            } // Set the next target element (undefined if none found)\n\n\n            moveTarget = getFocusableElement(navigableElements[currentIndex]);\n          }\n        }\n      }); // }\n    }\n  } // Handle horizontal arrow keys. If noHorizontalArrowHandling is passed, skip this block\n\n\n  if (!noHorizontalArrowHandling) {\n    if (['ArrowLeft', 'ArrowRight'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n\n      var _currentIndex = -1;\n\n      navigableElements.forEach(function (element, index) {\n        if (isActiveElement(element)) {\n          var activeRow = navigableElements[index].querySelectorAll(validSiblingTags.join(',')); // all focusable elements in my row\n\n          if (!activeRow.length || onlyTraverseSiblings) {\n            var nextSibling = activeElement; // While a sibling exists, check each sibling to determine if it should be focussed\n\n            while (nextSibling) {\n              // Set the next checked sibling, determined by the horizontal arrow key direction\n              nextSibling = key === 'ArrowLeft' ? nextSibling.previousElementSibling : nextSibling.nextElementSibling;\n\n              if (nextSibling) {\n                if (validSiblingTags.includes(nextSibling.tagName)) {\n                  // If the sibling's tag is included in validSiblingTags, set the next target element and break the loop\n                  moveTarget = nextSibling;\n                  break;\n                } // If the sibling's tag is not valid, skip to the next sibling if possible\n\n              }\n            }\n          } else {\n            activeRow.forEach(function (focusableElement, index) {\n              if (event.target === focusableElement) {\n                // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n                var increment = key === 'ArrowLeft' ? -1 : 1;\n                _currentIndex = index + increment;\n\n                if (_currentIndex >= activeRow.length) {\n                  _currentIndex = 0;\n                }\n\n                if (_currentIndex < 0) {\n                  _currentIndex = activeRow.length - 1;\n                } // Set the next target element\n\n\n                moveTarget = activeRow[_currentIndex];\n              }\n            });\n          }\n        }\n      });\n    }\n  }\n\n  if (moveTarget) {\n    // If updateTabIndex is true, set the previously focussed element's tabIndex to -1 and the next focussed element's tabIndex to 0\n    // This updates the tabIndex for a roving tabIndex\n    if (updateTabIndex) {\n      activeElement.tabIndex = -1;\n      moveTarget.tabIndex = 0;\n    } // If a move target has been set by either arrow handler, focus that target\n\n\n    moveTarget.focus();\n  }\n};\n/**\n * This function is a helper for setting the initial tabIndexes in a roving tabIndex\n *\n * @param {HTMLElement[]} options Array of elements which should have a tabIndex of -1, except for the first element which will have a tabIndex of 0\n */\n\nexport var setTabIndex = function setTabIndex(options) {\n  if (options && options.length > 0) {\n    // Iterate the options and set the tabIndex to -1 on every option\n    options.forEach(function (option) {\n      option.tabIndex = -1;\n    }); // Manually set the tabIndex of the first option to 0\n\n    options[0].tabIndex = 0;\n  }\n};\nexport var KeyboardHandler = /*#__PURE__*/function (_React$Component) {\n  _inherits(KeyboardHandler, _React$Component);\n\n  var _super = _createSuper(KeyboardHandler);\n\n  function KeyboardHandler() {\n    var _this;\n\n    _classCallCheck(this, KeyboardHandler);\n\n    _this = _super.apply(this, arguments);\n\n    _this.keyHandler = function (event) {\n      var isEventFromContainer = _this.props.isEventFromContainer; // If the passed keyboard event is not from the container, ignore the event by returning\n\n      if (isEventFromContainer ? !isEventFromContainer(event) : !_this._isEventFromContainer(event)) {\n        return;\n      }\n\n      var _this$props = _this.props,\n          isActiveElement = _this$props.isActiveElement,\n          getFocusableElement = _this$props.getFocusableElement,\n          noVerticalArrowHandling = _this$props.noVerticalArrowHandling,\n          noHorizontalArrowHandling = _this$props.noHorizontalArrowHandling,\n          noEnterHandling = _this$props.noEnterHandling,\n          noSpaceHandling = _this$props.noSpaceHandling,\n          updateTabIndex = _this$props.updateTabIndex,\n          validSiblingTags = _this$props.validSiblingTags,\n          additionalKeyHandler = _this$props.additionalKeyHandler,\n          createNavigableElements = _this$props.createNavigableElements,\n          onlyTraverseSiblings = _this$props.onlyTraverseSiblings; // Pass the event off to be handled by any custom handler\n\n      additionalKeyHandler && additionalKeyHandler(event); // Initalize navigableElements from the createNavigableElements callback\n\n      var navigableElements = createNavigableElements();\n\n      if (!navigableElements) {\n        // eslint-disable-next-line no-console\n        console.warn('No navigable elements have been passed to the KeyboardHandler. Keyboard navigation provided by this component will be ignored.');\n        return;\n      }\n\n      var key = event.key; // Handle enter key. If noEnterHandling is passed, skip this block\n\n      if (!noEnterHandling) {\n        if (key === 'Enter') {\n          event.preventDefault();\n          event.stopImmediatePropagation(); // For menus in menus\n\n          document.activeElement.click();\n        }\n      } // Handle space key. If noSpaceHandling is passed, skip this block\n\n\n      if (!noSpaceHandling) {\n        if (key === ' ') {\n          event.preventDefault();\n          event.stopImmediatePropagation(); // For menus in menus\n\n          document.activeElement.click();\n        }\n      } // Inject helper handler for arrow navigation\n\n\n      handleArrows(event, navigableElements, isActiveElement, getFocusableElement, validSiblingTags, noVerticalArrowHandling, noHorizontalArrowHandling, updateTabIndex, onlyTraverseSiblings);\n    };\n\n    _this._isEventFromContainer = function (event) {\n      var containerRef = _this.props.containerRef;\n      return containerRef.current && containerRef.current.contains(event.target);\n    };\n\n    return _this;\n  }\n\n  _createClass(KeyboardHandler, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (canUseDOM) {\n        window.addEventListener('keydown', this.keyHandler);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (canUseDOM) {\n        window.removeEventListener('keydown', this.keyHandler);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return null;\n    }\n  }]);\n\n  return KeyboardHandler;\n}(React.Component);\nKeyboardHandler.displayName = 'KeyboardHandler';\nKeyboardHandler.defaultProps = {\n  containerRef: null,\n  createNavigableElements: function createNavigableElements() {\n    return null;\n  },\n  isActiveElement: function isActiveElement(navigableElement) {\n    return document.activeElement === navigableElement;\n  },\n  getFocusableElement: function getFocusableElement(navigableElement) {\n    return navigableElement;\n  },\n  validSiblingTags: ['BUTTON', 'A'],\n  onlyTraverseSiblings: true,\n  updateTabIndex: true,\n  noHorizontalArrowHandling: false,\n  noVerticalArrowHandling: false,\n  noEnterHandling: false,\n  noSpaceHandling: false\n};","map":{"version":3,"sources":["/awx_devel/awx/ui/node_modules/@patternfly/react-core/src/helpers/KeyboardHandler.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { canUseDOM } from './util';\n\nexport interface KeyboardHandlerProps {\n  /** Reference of the container to apply keyboard interaction */\n  containerRef: React.RefObject<any>;\n  /** Callback returning an array of navigable elements to be traversable via vertical arrow keys. This array should not include non-navigable elements such as disabled elements. */\n  createNavigableElements: () => Element[];\n  /** Callback to determine if a given event is from the container. By default the function conducts a basic check to see if the containerRef contains the event target */\n  isEventFromContainer?: (event: KeyboardEvent) => boolean;\n  /** Additional key handling outside of the included arrow keys, enter, and space handling */\n  additionalKeyHandler?: (event: KeyboardEvent) => void;\n  /** Callback to determine if a given element from the navigable elements array is the active element of the page */\n  isActiveElement?: (navigableElement: Element) => boolean;\n  /** Callback returning the focusable element of a given element from the navigable elements array */\n  getFocusableElement?: (navigableElement: Element) => Element;\n  /** Valid sibling tags that horizontal arrow handling will focus */\n  validSiblingTags?: string[];\n  /** Flag indicating that the tabIndex of the currently focused element and next focused element should be updated, in the case of using a roving tabIndex */\n  updateTabIndex?: boolean;\n  /** Flag indicating that next focusable element of a horizontal movement will be this element's sibling */\n  onlyTraverseSiblings?: boolean;\n  /** Flag indicating that the included vertical arrow key handling should be ignored */\n  noVerticalArrowHandling?: boolean;\n  /** Flag indicating that the included horizontal arrow key handling should be ignored */\n  noHorizontalArrowHandling?: boolean;\n  /** Flag indicating that the included enter key handling should be ignored */\n  noEnterHandling?: boolean;\n  /** Flag indicating that the included space key handling should be ignored */\n  noSpaceHandling?: boolean;\n}\n\n/**\n * This function is a helper for handling basic arrow keyboard interactions. If a component already has its own key handler and event start up/tear down, this function may be easier to integrate in over the full component.\n *\n * @param {event} event Event triggered by the keyboard\n * @param {element[]} navigableElements Valid traversable elements of the container\n * @param {function} isActiveElement Callback to determine if a given element from the navigable elements array is the active element of the page\n * @param {function} getFocusableElement Callback returning the focusable element of a given element from the navigable elements array\n * @param {string[]} validSiblingTags Valid sibling tags that horizontal arrow handling will focus\n * @param {boolean} noVerticalArrowHandling Flag indicating that the included vertical arrow key handling should be ignored\n * @param {boolean} noHorizontalArrowHandling Flag indicating that the included horizontal arrow key handling should be ignored\n * @param {boolean} updateTabIndex Flag indicating that the tabIndex of the currently focused element and next focused element should be updated, in the case of using a roving tabIndex\n * @param {boolean} onlyTraverseSiblings Flag indicating that next focusable element of a horizontal movement will be this element's sibling\n */\nexport const handleArrows = (\n  event: KeyboardEvent,\n  navigableElements: Element[],\n  isActiveElement: (element: Element) => boolean = element => document.activeElement.contains(element),\n  getFocusableElement: (element: Element) => Element = element => element,\n  validSiblingTags: string[] = ['A', 'BUTTON', 'INPUT'],\n  noVerticalArrowHandling: boolean = false,\n  noHorizontalArrowHandling: boolean = false,\n  updateTabIndex: boolean = true,\n  onlyTraverseSiblings: boolean = true\n) => {\n  const activeElement = document.activeElement;\n  const key = event.key;\n  let moveTarget: Element = null;\n\n  // Handle vertical arrow keys. If noVerticalArrowHandling is passed, skip this block\n  if (!noVerticalArrowHandling) {\n    if (['ArrowUp', 'ArrowDown'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n\n      // Traverse navigableElements to find the element which is currently active\n      let currentIndex = -1;\n      // while (currentIndex === -1) {\n      navigableElements.forEach((element, index) => {\n        if (isActiveElement(element)) {\n          // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n          let increment = 0;\n\n          // keep increasing the increment until you've tried the whole navigableElement\n          while (!moveTarget && increment < navigableElements.length && increment * -1 < navigableElements.length) {\n            key === 'ArrowUp' ? increment-- : increment++;\n            currentIndex = index + increment;\n\n            if (currentIndex >= navigableElements.length) {\n              currentIndex = 0;\n            }\n            if (currentIndex < 0) {\n              currentIndex = navigableElements.length - 1;\n            }\n\n            // Set the next target element (undefined if none found)\n            moveTarget = getFocusableElement(navigableElements[currentIndex]);\n          }\n        }\n      });\n      // }\n    }\n  }\n\n  // Handle horizontal arrow keys. If noHorizontalArrowHandling is passed, skip this block\n  if (!noHorizontalArrowHandling) {\n    if (['ArrowLeft', 'ArrowRight'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n\n      let currentIndex = -1;\n      navigableElements.forEach((element, index) => {\n        if (isActiveElement(element)) {\n          const activeRow = navigableElements[index].querySelectorAll(validSiblingTags.join(',')); // all focusable elements in my row\n\n          if (!activeRow.length || onlyTraverseSiblings) {\n            let nextSibling = activeElement;\n            // While a sibling exists, check each sibling to determine if it should be focussed\n            while (nextSibling) {\n              // Set the next checked sibling, determined by the horizontal arrow key direction\n              nextSibling = key === 'ArrowLeft' ? nextSibling.previousElementSibling : nextSibling.nextElementSibling;\n              if (nextSibling) {\n                if (validSiblingTags.includes(nextSibling.tagName)) {\n                  // If the sibling's tag is included in validSiblingTags, set the next target element and break the loop\n                  moveTarget = nextSibling;\n                  break;\n                }\n                // If the sibling's tag is not valid, skip to the next sibling if possible\n              }\n            }\n          } else {\n            activeRow.forEach((focusableElement, index) => {\n              if (event.target === focusableElement) {\n                // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n                const increment = key === 'ArrowLeft' ? -1 : 1;\n                currentIndex = index + increment;\n                if (currentIndex >= activeRow.length) {\n                  currentIndex = 0;\n                }\n                if (currentIndex < 0) {\n                  currentIndex = activeRow.length - 1;\n                }\n\n                // Set the next target element\n                moveTarget = activeRow[currentIndex];\n              }\n            });\n          }\n        }\n      });\n    }\n  }\n\n  if (moveTarget) {\n    // If updateTabIndex is true, set the previously focussed element's tabIndex to -1 and the next focussed element's tabIndex to 0\n    // This updates the tabIndex for a roving tabIndex\n    if (updateTabIndex) {\n      (activeElement as HTMLElement).tabIndex = -1;\n      (moveTarget as HTMLElement).tabIndex = 0;\n    }\n    // If a move target has been set by either arrow handler, focus that target\n    (moveTarget as HTMLElement).focus();\n  }\n};\n\n/**\n * This function is a helper for setting the initial tabIndexes in a roving tabIndex\n *\n * @param {HTMLElement[]} options Array of elements which should have a tabIndex of -1, except for the first element which will have a tabIndex of 0\n */\nexport const setTabIndex = (options: HTMLElement[]) => {\n  if (options && options.length > 0) {\n    // Iterate the options and set the tabIndex to -1 on every option\n    options.forEach((option: HTMLElement) => {\n      option.tabIndex = -1;\n    });\n    // Manually set the tabIndex of the first option to 0\n    options[0].tabIndex = 0;\n  }\n};\n\nexport class KeyboardHandler extends React.Component<KeyboardHandlerProps> {\n  static displayName = 'KeyboardHandler';\n  static defaultProps: KeyboardHandlerProps = {\n    containerRef: null,\n    createNavigableElements: () => null as Element[],\n    isActiveElement: (navigableElement: Element) => document.activeElement === navigableElement,\n    getFocusableElement: (navigableElement: Element) => navigableElement,\n    validSiblingTags: ['BUTTON', 'A'],\n    onlyTraverseSiblings: true,\n    updateTabIndex: true,\n    noHorizontalArrowHandling: false,\n    noVerticalArrowHandling: false,\n    noEnterHandling: false,\n    noSpaceHandling: false\n  };\n\n  componentDidMount() {\n    if (canUseDOM) {\n      window.addEventListener('keydown', this.keyHandler);\n    }\n  }\n\n  componentWillUnmount() {\n    if (canUseDOM) {\n      window.removeEventListener('keydown', this.keyHandler);\n    }\n  }\n\n  keyHandler = (event: KeyboardEvent) => {\n    const { isEventFromContainer } = this.props;\n    // If the passed keyboard event is not from the container, ignore the event by returning\n    if (isEventFromContainer ? !isEventFromContainer(event) : !this._isEventFromContainer(event)) {\n      return;\n    }\n\n    const {\n      isActiveElement,\n      getFocusableElement,\n      noVerticalArrowHandling,\n      noHorizontalArrowHandling,\n      noEnterHandling,\n      noSpaceHandling,\n      updateTabIndex,\n      validSiblingTags,\n      additionalKeyHandler,\n      createNavigableElements,\n      onlyTraverseSiblings\n    } = this.props;\n\n    // Pass the event off to be handled by any custom handler\n    additionalKeyHandler && additionalKeyHandler(event);\n\n    // Initalize navigableElements from the createNavigableElements callback\n    const navigableElements = createNavigableElements();\n    if (!navigableElements) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'No navigable elements have been passed to the KeyboardHandler. Keyboard navigation provided by this component will be ignored.'\n      );\n      return;\n    }\n    const key = event.key;\n\n    // Handle enter key. If noEnterHandling is passed, skip this block\n    if (!noEnterHandling) {\n      if (key === 'Enter') {\n        event.preventDefault();\n        event.stopImmediatePropagation(); // For menus in menus\n        (document.activeElement as HTMLElement).click();\n      }\n    }\n\n    // Handle space key. If noSpaceHandling is passed, skip this block\n    if (!noSpaceHandling) {\n      if (key === ' ') {\n        event.preventDefault();\n        event.stopImmediatePropagation(); // For menus in menus\n        (document.activeElement as HTMLElement).click();\n      }\n    }\n\n    // Inject helper handler for arrow navigation\n    handleArrows(\n      event,\n      navigableElements,\n      isActiveElement,\n      getFocusableElement,\n      validSiblingTags,\n      noVerticalArrowHandling,\n      noHorizontalArrowHandling,\n      updateTabIndex,\n      onlyTraverseSiblings\n    );\n  };\n\n  _isEventFromContainer = (event: KeyboardEvent) => {\n    const { containerRef } = this.props;\n    return containerRef.current && containerRef.current.contains(event.target as HTMLElement);\n  };\n\n  render() {\n    return null as React.ReactNode;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}