{"ast":null,"code":"import _slicedToArray from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { __rest } from \"tslib\";\nimport * as React from 'react';\nimport { css } from '@patternfly/react-styles';\nimport styles from '@patternfly/react-styles/css/components/DragDrop/drag-drop';\nimport { DroppableContext } from './DroppableContext';\nimport { DragDropContext } from './DragDrop'; // Browsers really like being different from each other.\n\nfunction getDefaultBackground() {\n  var div = document.createElement('div');\n  document.head.appendChild(div);\n  var bg = window.getComputedStyle(div).backgroundColor;\n  document.head.removeChild(div);\n  return bg;\n}\n\nfunction getInheritedBackgroundColor(el) {\n  var defaultStyle = getDefaultBackground();\n  var backgroundColor = window.getComputedStyle(el).backgroundColor;\n\n  if (backgroundColor !== defaultStyle) {\n    return backgroundColor;\n  } else if (!el.parentElement) {\n    return defaultStyle;\n  }\n\n  return getInheritedBackgroundColor(el.parentElement);\n}\n\nfunction removeBlankDiv(node) {\n  if (node.getAttribute('blankDiv') === 'true') {\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (var i = 0; i < node.children.length; i++) {\n      var child = node.children[i];\n\n      if (child.getAttribute('blankDiv') === 'true') {\n        node.removeChild(child);\n        node.setAttribute('blankDiv', 'false');\n        break;\n      }\n    }\n  }\n} // Reset per-element state\n\n\nfunction resetDroppableItem(droppableItem) {\n  removeBlankDiv(droppableItem.node);\n  droppableItem.node.classList.remove(styles.modifiers.dragging);\n  droppableItem.node.classList.remove(styles.modifiers.dragOutside);\n  droppableItem.draggableNodes.forEach(function (n, i) {\n    n.style.transform = '';\n    n.style.transition = '';\n    droppableItem.draggableNodesRects[i] = n.getBoundingClientRect();\n  });\n}\n\nfunction overlaps(ev, rect) {\n  return ev.clientX > rect.x && ev.clientX < rect.x + rect.width && ev.clientY > rect.y && ev.clientY < rect.y + rect.height;\n}\n\nexport var Draggable = function Draggable(_a) {\n  var className = _a.className,\n      children = _a.children,\n      _a$style = _a.style,\n      styleProp = _a$style === void 0 ? {} : _a$style,\n      _a$hasNoWrapper = _a.hasNoWrapper,\n      hasNoWrapper = _a$hasNoWrapper === void 0 ? false : _a$hasNoWrapper,\n      props = __rest(_a, [\"className\", \"children\", \"style\", \"hasNoWrapper\"]);\n  /* eslint-disable prefer-const */\n\n\n  var _React$useState = React.useState(styleProp),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      style = _React$useState2[0],\n      setStyle = _React$useState2[1];\n  /* eslint-enable prefer-const */\n\n\n  var _React$useState3 = React.useState(false),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      isDragging = _React$useState4[0],\n      setIsDragging = _React$useState4[1];\n\n  var _React$useState5 = React.useState(true),\n      _React$useState6 = _slicedToArray(_React$useState5, 2),\n      isValidDrag = _React$useState6[0],\n      setIsValidDrag = _React$useState6[1];\n\n  var _React$useContext = React.useContext(DroppableContext),\n      zone = _React$useContext.zone,\n      droppableId = _React$useContext.droppableId;\n\n  var _React$useContext2 = React.useContext(DragDropContext),\n      onDrag = _React$useContext2.onDrag,\n      onDragMove = _React$useContext2.onDragMove,\n      onDrop = _React$useContext2.onDrop; // Some state is better just to leave as vars passed around between various callbacks\n  // You can only drag around one item at a time anyways...\n\n\n  var startX = 0;\n  var startY = 0;\n  var index = null; // Index of this draggable\n\n  var hoveringDroppable;\n  var hoveringIndex = null;\n  var mouseMoveListener;\n  var mouseUpListener; // Makes it so dragging the _bottom_ of the item over the halfway of another moves it\n\n  var startYOffset = 0; // After item returning to where it started animation completes\n\n  var onTransitionEnd = function onTransitionEnd(_ev) {\n    if (isDragging) {\n      setIsDragging(false);\n      setStyle(styleProp);\n    }\n  };\n\n  function getSourceAndDest() {\n    var hoveringDroppableId = hoveringDroppable ? hoveringDroppable.getAttribute('data-pf-droppableid') : null;\n    var source = {\n      droppableId: droppableId,\n      index: index\n    };\n    var dest = hoveringDroppableId !== null && hoveringIndex !== null ? {\n      droppableId: hoveringDroppableId,\n      index: hoveringIndex\n    } : undefined;\n    return {\n      source: source,\n      dest: dest,\n      hoveringDroppableId: hoveringDroppableId\n    };\n  }\n\n  var onMouseUpWhileDragging = function onMouseUpWhileDragging(droppableItems) {\n    droppableItems.forEach(resetDroppableItem);\n    document.removeEventListener('mousemove', mouseMoveListener);\n    document.removeEventListener('mouseup', mouseUpListener);\n    document.removeEventListener('contextmenu', mouseUpListener);\n\n    var _getSourceAndDest = getSourceAndDest(),\n        source = _getSourceAndDest.source,\n        dest = _getSourceAndDest.dest,\n        hoveringDroppableId = _getSourceAndDest.hoveringDroppableId;\n\n    var consumerReordered = onDrop(source, dest);\n\n    if (consumerReordered && droppableId === hoveringDroppableId) {\n      setIsDragging(false);\n      setStyle(styleProp);\n    } else if (!consumerReordered) {\n      // Animate item returning to where it started\n      setStyle(Object.assign(Object.assign({}, style), {\n        transition: 'transform 0.5s cubic-bezier(0.2, 1, 0.1, 1) 0s',\n        transform: '',\n        background: styleProp.background,\n        boxShadow: styleProp.boxShadow\n      }));\n    }\n  }; // This is where the magic happens\n\n\n  var onMouseMoveWhileDragging = function onMouseMoveWhileDragging(ev, droppableItems, blankDivRect) {\n    // Compute each time what droppable node we are hovering over\n    hoveringDroppable = null;\n    droppableItems.forEach(function (droppableItem) {\n      var node = droppableItem.node,\n          rect = droppableItem.rect,\n          isDraggingHost = droppableItem.isDraggingHost,\n          draggableNodes = droppableItem.draggableNodes,\n          draggableNodesRects = droppableItem.draggableNodesRects;\n\n      if (overlaps(ev, rect)) {\n        // Add valid dropzone style\n        node.classList.remove(styles.modifiers.dragOutside);\n        hoveringDroppable = node; // Check if we need to add a blank div row\n\n        if (node.getAttribute('blankDiv') !== 'true' && !isDraggingHost) {\n          var blankDiv = document.createElement('div');\n          blankDiv.setAttribute('blankDiv', 'true'); // Makes removing easier\n\n          var blankDivPos = -1;\n\n          for (var i = 0; i < draggableNodes.length; i++) {\n            var childRect = draggableNodesRects[i];\n            var isLast = i === draggableNodes.length - 1;\n            var startOverlaps = childRect.y >= startY - startYOffset;\n\n            if ((startOverlaps || isLast) && blankDivPos === -1) {\n              if (isLast && !startOverlaps) {\n                draggableNodes[i].after(blankDiv);\n              } else {\n                draggableNodes[i].before(blankDiv);\n              }\n\n              blankDiv.style.height = \"\".concat(blankDivRect.height, \"px\");\n              blankDiv.style.width = \"\".concat(blankDivRect.width, \"px\");\n              node.setAttribute('blankDiv', 'true'); // Makes removing easier\n\n              blankDivPos = i;\n            }\n\n            if (blankDivPos !== -1) {\n              childRect.y += blankDivRect.height;\n            }\n          } // Insert so drag + drop behavior matches single-list case\n\n\n          draggableNodes.splice(blankDivPos, 0, blankDiv);\n          draggableNodesRects.splice(blankDivPos, 0, blankDivRect); // Extend hitbox of droppable zone\n\n          rect.height += blankDivRect.height;\n        }\n      } else {\n        resetDroppableItem(droppableItem);\n        node.classList.add(styles.modifiers.dragging);\n        node.classList.add(styles.modifiers.dragOutside);\n      }\n    }); // Move hovering draggable and style it based on cursor position\n\n    setStyle(Object.assign(Object.assign({}, style), {\n      transform: \"translate(\".concat(ev.pageX - startX, \"px, \").concat(ev.pageY - startY, \"px)\")\n    }));\n    setIsValidDrag(Boolean(hoveringDroppable)); // Iterate through sibling draggable nodes to reposition them and store correct hoveringIndex for onDrop\n\n    hoveringIndex = null;\n\n    if (hoveringDroppable) {\n      var _droppableItems$find = droppableItems.find(function (item) {\n        return item.node === hoveringDroppable;\n      }),\n          draggableNodes = _droppableItems$find.draggableNodes,\n          draggableNodesRects = _droppableItems$find.draggableNodesRects;\n\n      var lastTranslate = 0;\n      draggableNodes.forEach(function (n, i) {\n        n.style.transition = 'transform 0.5s cubic-bezier(0.2, 1, 0.1, 1) 0s';\n        var rect = draggableNodesRects[i];\n        var halfway = rect.y + rect.height / 2;\n        var translateY = 0; // Use offset for more interactive translations\n\n        if (startY < halfway && ev.pageY + (blankDivRect.height - startYOffset) > halfway) {\n          translateY -= blankDivRect.height;\n        } else if (startY >= halfway && ev.pageY - startYOffset <= halfway) {\n          translateY += blankDivRect.height;\n        } // Clever way to find item currently hovering over\n\n\n        if (translateY <= lastTranslate && translateY < 0 || translateY > lastTranslate && translateY > 0) {\n          hoveringIndex = i;\n        }\n\n        n.style.transform = \"translate(0, \".concat(translateY, \"px\");\n        lastTranslate = translateY;\n      });\n    }\n\n    var _getSourceAndDest2 = getSourceAndDest(),\n        source = _getSourceAndDest2.source,\n        dest = _getSourceAndDest2.dest;\n\n    onDragMove(source, dest);\n  };\n\n  var onDragStart = function onDragStart(ev) {\n    // Default HTML drag and drop doesn't allow us to change what the thing\n    // being dragged looks like. Because of this we'll use prevent the default\n    // and use `mouseMove` and `mouseUp` instead\n    ev.preventDefault();\n\n    if (isDragging) {\n      // still in animation\n      return;\n    } // Cache droppable and draggable nodes and their bounding rects\n\n\n    var dragging = ev.target;\n    var rect = dragging.getBoundingClientRect();\n    var droppableNodes = Array.from(document.querySelectorAll(\"[data-pf-droppable=\\\"\".concat(zone, \"\\\"]\")));\n    var droppableItems = droppableNodes.reduce(function (acc, cur) {\n      cur.classList.add(styles.modifiers.dragging);\n      var draggableNodes = Array.from(cur.querySelectorAll(\"[data-pf-draggable-zone=\\\"\".concat(zone, \"\\\"]\")));\n      var isDraggingHost = cur.contains(dragging);\n\n      if (isDraggingHost) {\n        index = draggableNodes.indexOf(dragging);\n      }\n\n      var droppableItem = {\n        node: cur,\n        rect: cur.getBoundingClientRect(),\n        isDraggingHost: isDraggingHost,\n        // We don't want styles to apply to the left behind div in onMouseMoveWhileDragging\n        draggableNodes: draggableNodes.map(function (node) {\n          return node === dragging ? node.cloneNode(false) : node;\n        }),\n        draggableNodesRects: draggableNodes.map(function (node) {\n          return node.getBoundingClientRect();\n        })\n      };\n      acc.push(droppableItem);\n      return acc;\n    }, []);\n\n    if (!onDrag({\n      droppableId: droppableId,\n      index: index\n    })) {\n      // Consumer disallowed drag\n      return;\n    } // Set initial style so future style mods take effect\n\n\n    style = Object.assign(Object.assign({}, style), {\n      top: rect.y,\n      left: rect.x,\n      width: rect.width,\n      height: rect.height,\n      '--pf-c-draggable--m-dragging--BackgroundColor': getInheritedBackgroundColor(dragging),\n      position: 'fixed',\n      zIndex: 5000\n    });\n    setStyle(style); // Store event details\n\n    startX = ev.pageX;\n    startY = ev.pageY;\n    startYOffset = startY - rect.y;\n    setIsDragging(true);\n\n    mouseMoveListener = function mouseMoveListener(ev) {\n      return onMouseMoveWhileDragging(ev, droppableItems, rect);\n    };\n\n    mouseUpListener = function mouseUpListener() {\n      return onMouseUpWhileDragging(droppableItems);\n    };\n\n    document.addEventListener('mousemove', mouseMoveListener);\n    document.addEventListener('mouseup', mouseUpListener); // Comment out this line to debug while dragging by right clicking\n    // document.addEventListener('contextmenu', mouseUpListener);\n  };\n\n  var childProps = Object.assign({\n    'data-pf-draggable-zone': isDragging ? null : zone,\n    draggable: true,\n    className: css(styles.draggable, isDragging && styles.modifiers.dragging, !isValidDrag && styles.modifiers.dragOutside, className),\n    onDragStart: onDragStart,\n    onTransitionEnd: onTransitionEnd,\n    style: style\n  }, props);\n  return React.createElement(React.Fragment, null, isDragging && React.createElement(\"div\", Object.assign({\n    draggable: true\n  }, props, {\n    style: Object.assign(Object.assign({}, styleProp), {\n      visibility: 'hidden'\n    })\n  }), children), hasNoWrapper ? React.cloneElement(children, childProps) : React.createElement(\"div\", Object.assign({}, childProps), children));\n};\nDraggable.displayName = 'Draggable';","map":{"version":3,"sources":["/awx_devel/awx/ui/node_modules/@patternfly/react-core/src/components/DragDrop/Draggable.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { css } from '@patternfly/react-styles';\nimport styles from '@patternfly/react-styles/css/components/DragDrop/drag-drop';\nimport { DroppableContext } from './DroppableContext';\nimport { DragDropContext } from './DragDrop';\n\nexport interface DraggableProps extends React.HTMLProps<HTMLDivElement> {\n  /** Content rendered inside DragDrop */\n  children?: React.ReactNode;\n  /** Don't wrap the component in a div. Requires passing a single child. */\n  hasNoWrapper?: boolean;\n  /** Class to add to outer div */\n  className?: string;\n}\n\n// Browsers really like being different from each other.\nfunction getDefaultBackground() {\n  const div = document.createElement('div');\n  document.head.appendChild(div);\n  const bg = window.getComputedStyle(div).backgroundColor;\n  document.head.removeChild(div);\n  return bg;\n}\n\nfunction getInheritedBackgroundColor(el: HTMLElement): string {\n  const defaultStyle = getDefaultBackground();\n  const backgroundColor = window.getComputedStyle(el).backgroundColor;\n\n  if (backgroundColor !== defaultStyle) {\n    return backgroundColor;\n  } else if (!el.parentElement) {\n    return defaultStyle;\n  }\n\n  return getInheritedBackgroundColor(el.parentElement);\n}\n\nfunction removeBlankDiv(node: HTMLElement) {\n  if (node.getAttribute('blankDiv') === 'true') {\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < node.children.length; i++) {\n      const child = node.children[i];\n      if (child.getAttribute('blankDiv') === 'true') {\n        node.removeChild(child);\n        node.setAttribute('blankDiv', 'false');\n        break;\n      }\n    }\n  }\n}\n\ninterface DroppableItem {\n  node: HTMLElement;\n  rect: DOMRect;\n  isDraggingHost: boolean;\n  draggableNodes: HTMLElement[];\n  draggableNodesRects: DOMRect[];\n}\n\n// Reset per-element state\nfunction resetDroppableItem(droppableItem: DroppableItem) {\n  removeBlankDiv(droppableItem.node);\n  droppableItem.node.classList.remove(styles.modifiers.dragging);\n  droppableItem.node.classList.remove(styles.modifiers.dragOutside);\n  droppableItem.draggableNodes.forEach((n, i) => {\n    n.style.transform = '';\n    n.style.transition = '';\n    droppableItem.draggableNodesRects[i] = n.getBoundingClientRect();\n  });\n}\n\nfunction overlaps(ev: MouseEvent, rect: DOMRect) {\n  return (\n    ev.clientX > rect.x && ev.clientX < rect.x + rect.width && ev.clientY > rect.y && ev.clientY < rect.y + rect.height\n  );\n}\n\nexport const Draggable: React.FunctionComponent<DraggableProps> = ({\n  className,\n  children,\n  style: styleProp = {},\n  hasNoWrapper = false,\n  ...props\n}: DraggableProps) => {\n  /* eslint-disable prefer-const */\n  let [style, setStyle] = React.useState(styleProp);\n  /* eslint-enable prefer-const */\n  const [isDragging, setIsDragging] = React.useState(false);\n  const [isValidDrag, setIsValidDrag] = React.useState(true);\n  const { zone, droppableId } = React.useContext(DroppableContext);\n  const { onDrag, onDragMove, onDrop } = React.useContext(DragDropContext);\n  // Some state is better just to leave as vars passed around between various callbacks\n  // You can only drag around one item at a time anyways...\n  let startX = 0;\n  let startY = 0;\n  let index: number = null; // Index of this draggable\n  let hoveringDroppable: HTMLElement;\n  let hoveringIndex: number = null;\n  let mouseMoveListener: EventListener;\n  let mouseUpListener: EventListener;\n  // Makes it so dragging the _bottom_ of the item over the halfway of another moves it\n  let startYOffset = 0;\n\n  // After item returning to where it started animation completes\n  const onTransitionEnd = (_ev: React.TransitionEvent<HTMLElement>) => {\n    if (isDragging) {\n      setIsDragging(false);\n      setStyle(styleProp);\n    }\n  };\n\n  function getSourceAndDest() {\n    const hoveringDroppableId = hoveringDroppable ? hoveringDroppable.getAttribute('data-pf-droppableid') : null;\n    const source = {\n      droppableId,\n      index\n    };\n    const dest =\n      hoveringDroppableId !== null && hoveringIndex !== null\n        ? {\n            droppableId: hoveringDroppableId,\n            index: hoveringIndex\n          }\n        : undefined;\n    return { source, dest, hoveringDroppableId };\n  }\n\n  const onMouseUpWhileDragging = (droppableItems: DroppableItem[]) => {\n    droppableItems.forEach(resetDroppableItem);\n    document.removeEventListener('mousemove', mouseMoveListener);\n    document.removeEventListener('mouseup', mouseUpListener);\n    document.removeEventListener('contextmenu', mouseUpListener);\n    const { source, dest, hoveringDroppableId } = getSourceAndDest();\n    const consumerReordered = onDrop(source, dest);\n    if (consumerReordered && droppableId === hoveringDroppableId) {\n      setIsDragging(false);\n      setStyle(styleProp);\n    } else if (!consumerReordered) {\n      // Animate item returning to where it started\n      setStyle({\n        ...style,\n        transition: 'transform 0.5s cubic-bezier(0.2, 1, 0.1, 1) 0s',\n        transform: '',\n        background: styleProp.background,\n        boxShadow: styleProp.boxShadow\n      });\n    }\n  };\n\n  // This is where the magic happens\n  const onMouseMoveWhileDragging = (ev: MouseEvent, droppableItems: DroppableItem[], blankDivRect: DOMRect) => {\n    // Compute each time what droppable node we are hovering over\n    hoveringDroppable = null;\n    droppableItems.forEach(droppableItem => {\n      const { node, rect, isDraggingHost, draggableNodes, draggableNodesRects } = droppableItem;\n      if (overlaps(ev, rect)) {\n        // Add valid dropzone style\n        node.classList.remove(styles.modifiers.dragOutside);\n        hoveringDroppable = node;\n        // Check if we need to add a blank div row\n        if (node.getAttribute('blankDiv') !== 'true' && !isDraggingHost) {\n          const blankDiv = document.createElement('div');\n          blankDiv.setAttribute('blankDiv', 'true'); // Makes removing easier\n          let blankDivPos = -1;\n          for (let i = 0; i < draggableNodes.length; i++) {\n            const childRect = draggableNodesRects[i];\n            const isLast = i === draggableNodes.length - 1;\n            const startOverlaps = childRect.y >= startY - startYOffset;\n            if ((startOverlaps || isLast) && blankDivPos === -1) {\n              if (isLast && !startOverlaps) {\n                draggableNodes[i].after(blankDiv);\n              } else {\n                draggableNodes[i].before(blankDiv);\n              }\n              blankDiv.style.height = `${blankDivRect.height}px`;\n              blankDiv.style.width = `${blankDivRect.width}px`;\n              node.setAttribute('blankDiv', 'true'); // Makes removing easier\n              blankDivPos = i;\n            }\n            if (blankDivPos !== -1) {\n              childRect.y += blankDivRect.height;\n            }\n          }\n          // Insert so drag + drop behavior matches single-list case\n          draggableNodes.splice(blankDivPos, 0, blankDiv);\n          draggableNodesRects.splice(blankDivPos, 0, blankDivRect);\n          // Extend hitbox of droppable zone\n          rect.height += blankDivRect.height;\n        }\n      } else {\n        resetDroppableItem(droppableItem);\n        node.classList.add(styles.modifiers.dragging);\n        node.classList.add(styles.modifiers.dragOutside);\n      }\n    });\n\n    // Move hovering draggable and style it based on cursor position\n    setStyle({\n      ...style,\n      transform: `translate(${ev.pageX - startX}px, ${ev.pageY - startY}px)`\n    });\n    setIsValidDrag(Boolean(hoveringDroppable));\n\n    // Iterate through sibling draggable nodes to reposition them and store correct hoveringIndex for onDrop\n    hoveringIndex = null;\n    if (hoveringDroppable) {\n      const { draggableNodes, draggableNodesRects } = droppableItems.find(item => item.node === hoveringDroppable);\n      let lastTranslate = 0;\n      draggableNodes.forEach((n, i) => {\n        n.style.transition = 'transform 0.5s cubic-bezier(0.2, 1, 0.1, 1) 0s';\n        const rect = draggableNodesRects[i];\n        const halfway = rect.y + rect.height / 2;\n        let translateY = 0;\n        // Use offset for more interactive translations\n        if (startY < halfway && ev.pageY + (blankDivRect.height - startYOffset) > halfway) {\n          translateY -= blankDivRect.height;\n        } else if (startY >= halfway && ev.pageY - startYOffset <= halfway) {\n          translateY += blankDivRect.height;\n        }\n        // Clever way to find item currently hovering over\n        if ((translateY <= lastTranslate && translateY < 0) || (translateY > lastTranslate && translateY > 0)) {\n          hoveringIndex = i;\n        }\n        n.style.transform = `translate(0, ${translateY}px`;\n        lastTranslate = translateY;\n      });\n    }\n\n    const { source, dest } = getSourceAndDest();\n    onDragMove(source, dest);\n  };\n\n  const onDragStart = (ev: React.DragEvent<HTMLElement>) => {\n    // Default HTML drag and drop doesn't allow us to change what the thing\n    // being dragged looks like. Because of this we'll use prevent the default\n    // and use `mouseMove` and `mouseUp` instead\n    ev.preventDefault();\n    if (isDragging) {\n      // still in animation\n      return;\n    }\n\n    // Cache droppable and draggable nodes and their bounding rects\n    const dragging = ev.target as HTMLElement;\n    const rect = dragging.getBoundingClientRect();\n    const droppableNodes = Array.from(document.querySelectorAll(`[data-pf-droppable=\"${zone}\"]`)) as HTMLElement[];\n    const droppableItems = droppableNodes.reduce((acc, cur) => {\n      cur.classList.add(styles.modifiers.dragging);\n      const draggableNodes = Array.from(cur.querySelectorAll(`[data-pf-draggable-zone=\"${zone}\"]`)) as HTMLElement[];\n      const isDraggingHost = cur.contains(dragging);\n      if (isDraggingHost) {\n        index = draggableNodes.indexOf(dragging);\n      }\n      const droppableItem = {\n        node: cur,\n        rect: cur.getBoundingClientRect(),\n        isDraggingHost,\n        // We don't want styles to apply to the left behind div in onMouseMoveWhileDragging\n        draggableNodes: draggableNodes.map(node => (node === dragging ? node.cloneNode(false) : node)),\n        draggableNodesRects: draggableNodes.map(node => node.getBoundingClientRect())\n      };\n      acc.push(droppableItem);\n      return acc;\n    }, []);\n\n    if (!onDrag({ droppableId, index })) {\n      // Consumer disallowed drag\n      return;\n    }\n\n    // Set initial style so future style mods take effect\n    style = {\n      ...style,\n      top: rect.y,\n      left: rect.x,\n      width: rect.width,\n      height: rect.height,\n      '--pf-c-draggable--m-dragging--BackgroundColor': getInheritedBackgroundColor(dragging),\n      position: 'fixed',\n      zIndex: 5000\n    } as any;\n    setStyle(style);\n    // Store event details\n    startX = ev.pageX;\n    startY = ev.pageY;\n    startYOffset = startY - rect.y;\n    setIsDragging(true);\n    mouseMoveListener = ev => onMouseMoveWhileDragging(ev as MouseEvent, droppableItems, rect);\n    mouseUpListener = () => onMouseUpWhileDragging(droppableItems);\n    document.addEventListener('mousemove', mouseMoveListener);\n    document.addEventListener('mouseup', mouseUpListener);\n    // Comment out this line to debug while dragging by right clicking\n    // document.addEventListener('contextmenu', mouseUpListener);\n  };\n\n  const childProps = {\n    'data-pf-draggable-zone': isDragging ? null : zone,\n    draggable: true,\n    className: css(\n      styles.draggable,\n      isDragging && styles.modifiers.dragging,\n      !isValidDrag && styles.modifiers.dragOutside,\n      className\n    ),\n    onDragStart,\n    onTransitionEnd,\n    style,\n    ...props\n  };\n\n  return (\n    <React.Fragment>\n      {/* Leave behind blank spot per-design */}\n      {isDragging && (\n        <div draggable {...props} style={{ ...styleProp, visibility: 'hidden' }}>\n          {children}\n        </div>\n      )}\n      {hasNoWrapper ? (\n        React.cloneElement(children as React.ReactElement, childProps)\n      ) : (\n        <div {...childProps}>{children}</div>\n      )}\n    </React.Fragment>\n  );\n};\nDraggable.displayName = 'Draggable';\n"]},"metadata":{},"sourceType":"module"}