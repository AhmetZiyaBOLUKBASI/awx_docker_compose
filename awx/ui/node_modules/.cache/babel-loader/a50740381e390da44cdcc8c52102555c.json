{"ast":null,"code":"import _classCallCheck from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/awx_devel/awx/ui/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { __rest } from \"tslib\";\nimport * as React from 'react';\nimport { css } from '@patternfly/react-styles';\nimport datePickerStyles from '@patternfly/react-styles/css/components/DatePicker/date-picker';\nimport formStyles from '@patternfly/react-styles/css/components/FormControl/form-control';\nimport menuStyles from '@patternfly/react-styles/css/components/Menu/menu';\nimport { getUniqueId } from '../../helpers';\nimport { Popper } from '../../helpers/Popper/Popper';\nimport { Menu, MenuContent, MenuList, MenuItem } from '../Menu';\nimport { InputGroup } from '../InputGroup';\nimport { TextInput } from '../TextInput';\nimport { KeyTypes } from '../../helpers/constants';\nimport { parseTime, validateTime, makeTimeOptions, amSuffix, pmSuffix, getHours, getMinutes, isWithinMinMax, getSeconds } from './TimePickerUtils';\nexport var TimePicker = /*#__PURE__*/function (_React$Component) {\n  _inherits(TimePicker, _React$Component);\n\n  var _super = _createSuper(TimePicker);\n\n  function TimePicker(props) {\n    var _this;\n\n    _classCallCheck(this, TimePicker);\n\n    _this = _super.call(this, props);\n    _this.baseComponentRef = React.createRef();\n    _this.toggleRef = React.createRef();\n    _this.inputRef = React.createRef();\n    _this.menuRef = React.createRef();\n\n    _this.onDocClick = function (event) {\n      var _a, _b, _c, _d;\n\n      var clickedOnToggle = (_b = (_a = _this.toggleRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.contains(event.target);\n      var clickedWithinMenu = (_d = (_c = _this.menuRef) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.contains(event.target);\n\n      if (_this.state.isTimeOptionsOpen && !(clickedOnToggle || clickedWithinMenu)) {\n        _this.onToggle(false);\n      }\n    };\n\n    _this.handleGlobalKeys = function (event) {\n      var _a, _b, _c, _d;\n\n      var _this$state = _this.state,\n          isTimeOptionsOpen = _this$state.isTimeOptionsOpen,\n          focusedIndex = _this$state.focusedIndex,\n          scrollIndex = _this$state.scrollIndex; // keyboard pressed while focus on toggle\n\n      if ((_b = (_a = _this.inputRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.contains(event.target)) {\n        if (!isTimeOptionsOpen && event.key !== KeyTypes.Tab && event.key !== KeyTypes.Escape) {\n          _this.onToggle(true);\n        } else if (isTimeOptionsOpen) {\n          if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n            _this.onToggle(false);\n          } else if (event.key === KeyTypes.Enter) {\n            if (focusedIndex !== null) {\n              _this.focusSelection(focusedIndex);\n\n              event.stopPropagation();\n            } else {\n              _this.onToggle(false);\n            }\n          } else if (event.key === KeyTypes.ArrowDown || event.key === KeyTypes.ArrowUp) {\n            _this.focusSelection(scrollIndex);\n\n            _this.updateFocusedIndex(0);\n\n            event.preventDefault();\n          }\n        } // keyboard pressed while focus on menu item\n\n      } else if ((_d = (_c = _this.menuRef) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.contains(event.target)) {\n        if (event.key === KeyTypes.ArrowDown) {\n          _this.updateFocusedIndex(1);\n\n          event.preventDefault();\n        } else if (event.key === KeyTypes.ArrowUp) {\n          _this.updateFocusedIndex(-1);\n\n          event.preventDefault();\n        } else if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n          _this.inputRef.current.focus();\n\n          _this.onToggle(false);\n        }\n      }\n    };\n\n    _this.updateFocusedIndex = function (increment) {\n      _this.setState(function (prevState) {\n        var maxIndex = _this.getOptions().length - 1;\n        var nextIndex = prevState.focusedIndex !== null ? prevState.focusedIndex + increment : prevState.scrollIndex + increment;\n\n        if (nextIndex < 0) {\n          nextIndex = maxIndex;\n        } else if (nextIndex > maxIndex) {\n          nextIndex = 0;\n        }\n\n        _this.scrollToIndex(nextIndex);\n\n        return {\n          focusedIndex: nextIndex\n        };\n      });\n    }; // fixes issue where menutAppendTo=\"inline\" results in the menu item that should be scrolled to being out of view; this will select the menu item that comes before the intended one, causing that before-item to be placed out of view instead\n\n\n    _this.getIndexToScroll = function (index) {\n      if (_this.props.menuAppendTo === 'inline') {\n        return index > 0 ? index - 1 : 0;\n      }\n\n      return index;\n    };\n\n    _this.scrollToIndex = function (index) {\n      _this.getOptions()[index].closest(\".\".concat(menuStyles.menuContent)).scrollTop = _this.getOptions()[_this.getIndexToScroll(index)].offsetTop;\n    };\n\n    _this.focusSelection = function (index) {\n      var _a;\n\n      var indexToFocus = index !== -1 ? index : 0;\n\n      if ((_a = _this.menuRef) === null || _a === void 0 ? void 0 : _a.current) {\n        _this.getOptions()[indexToFocus].querySelector(\".\".concat(menuStyles.menuItem)).focus();\n      }\n    };\n\n    _this.scrollToSelection = function (time) {\n      var _this$props = _this.props,\n          delimiter = _this$props.delimiter,\n          is24Hour = _this$props.is24Hour;\n      var splitTime = time.split(_this.props.delimiter);\n      var focusedIndex = null; // build out the rest of the time assuming hh:00 if it's a partial time\n\n      if (splitTime.length < 2) {\n        time = \"\".concat(time).concat(delimiter, \"00\");\n        splitTime = time.split(delimiter); // due to only the input including seconds when includeSeconds=true, we need to build a temporary time here without those seconds so that an exact or close match can be scrolled to within the menu (which does not include seconds in any of the options)\n      } else if (splitTime.length > 2) {\n        time = parseTime(time, _this.state.timeRegex, delimiter, !is24Hour, false);\n        splitTime = time.split(delimiter);\n      } // for 12hr variant, autoscroll to pm if it's currently the afternoon, otherwise autoscroll to am\n\n\n      if (!is24Hour && splitTime.length > 1 && splitTime[1].length < 2) {\n        var minutes = splitTime[1].length === 0 ? '00' : splitTime[1] + '0';\n        time = \"\".concat(splitTime[0]).concat(delimiter).concat(minutes).concat(new Date().getHours() > 11 ? pmSuffix : amSuffix);\n      } else if (!is24Hour && splitTime.length > 1 && splitTime[1].length === 2 && !time.toUpperCase().includes(amSuffix.toUpperCase().trim()) && !time.toUpperCase().includes(pmSuffix.toUpperCase().trim())) {\n        time = \"\".concat(time).concat(new Date().getHours() > 11 ? pmSuffix : amSuffix);\n      }\n\n      var scrollIndex = _this.getOptions().findIndex(function (option) {\n        return option.innerText === time;\n      }); // if we found an exact match, scroll to match and return index of match for focus\n\n\n      if (scrollIndex !== -1) {\n        _this.scrollToIndex(scrollIndex);\n\n        focusedIndex = scrollIndex;\n      } else if (splitTime.length === 2) {\n        // no exact match, scroll to closest hour but don't return index for focus\n        var amPm = '';\n\n        if (!is24Hour) {\n          if (splitTime[1].toUpperCase().includes('P')) {\n            amPm = pmSuffix;\n          } else if (splitTime[1].toUpperCase().includes('A')) {\n            amPm = amSuffix;\n          }\n        }\n\n        time = \"\".concat(splitTime[0]).concat(delimiter, \"00\").concat(amPm);\n        scrollIndex = _this.getOptions().findIndex(function (option) {\n          return option.innerText === time;\n        });\n\n        if (scrollIndex !== -1) {\n          _this.scrollToIndex(scrollIndex);\n        }\n      }\n\n      _this.setState({\n        focusedIndex: focusedIndex,\n        scrollIndex: scrollIndex\n      });\n    };\n\n    _this.getRegExp = function () {\n      var includeSeconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var _this$props2 = _this.props,\n          is24Hour = _this$props2.is24Hour,\n          delimiter = _this$props2.delimiter;\n      var baseRegex = \"\\\\s*(\\\\d\\\\d?)\".concat(delimiter, \"([0-5]\\\\d)\");\n\n      if (includeSeconds) {\n        baseRegex += \"\".concat(delimiter, \"?([0-5]\\\\d)?\");\n      }\n\n      return new RegExp(\"^\".concat(baseRegex).concat(is24Hour ? '' : '\\\\s*([AaPp][Mm])?', \"\\\\s*$\"));\n    };\n\n    _this.getOptions = function () {\n      var _a;\n\n      return ((_a = _this.menuRef) === null || _a === void 0 ? void 0 : _a.current) ? Array.from(_this.menuRef.current.querySelectorAll(\".\".concat(menuStyles.menuListItem))) : [];\n    };\n\n    _this.isValidFormat = function (time) {\n      if (_this.props.validateTime) {\n        return _this.props.validateTime(time);\n      }\n\n      var _this$props3 = _this.props,\n          delimiter = _this$props3.delimiter,\n          is24Hour = _this$props3.is24Hour,\n          includeSeconds = _this$props3.includeSeconds;\n      return validateTime(time, _this.getRegExp(includeSeconds), delimiter, !is24Hour);\n    };\n\n    _this.isValidTime = function (time) {\n      var _this$props4 = _this.props,\n          delimiter = _this$props4.delimiter,\n          includeSeconds = _this$props4.includeSeconds;\n      var _this$state2 = _this.state,\n          minTimeState = _this$state2.minTimeState,\n          maxTimeState = _this$state2.maxTimeState;\n      return isWithinMinMax(minTimeState, maxTimeState, time, delimiter, includeSeconds);\n    };\n\n    _this.isValid = function (time) {\n      return _this.isValidFormat(time) && _this.isValidTime(time);\n    };\n\n    _this.onToggle = function (isOpen) {\n      // on close, parse and validate input\n      _this.setState(function (prevState) {\n        var timeRegex = prevState.timeRegex,\n            isInvalid = prevState.isInvalid;\n        var _this$props5 = _this.props,\n            delimiter = _this$props5.delimiter,\n            is24Hour = _this$props5.is24Hour,\n            includeSeconds = _this$props5.includeSeconds;\n        var time = parseTime(prevState.timeState, timeRegex, delimiter, !is24Hour, includeSeconds);\n        return {\n          isTimeOptionsOpen: isOpen,\n          timeState: time,\n          isInvalid: isOpen ? isInvalid : !_this.isValid(time)\n        };\n      });\n\n      _this.props.setIsOpen(isOpen);\n\n      if (!isOpen) {\n        _this.inputRef.current.focus();\n      }\n    };\n\n    _this.onSelect = function (e) {\n      var _this$state3 = _this.state,\n          timeRegex = _this$state3.timeRegex,\n          timeState = _this$state3.timeState;\n      var _this$props6 = _this.props,\n          delimiter = _this$props6.delimiter,\n          is24Hour = _this$props6.is24Hour,\n          includeSeconds = _this$props6.includeSeconds,\n          setIsOpen = _this$props6.setIsOpen;\n      var time = parseTime(e.target.textContent, timeRegex, delimiter, !is24Hour, includeSeconds);\n\n      if (time !== timeState) {\n        _this.onInputChange(time);\n      }\n\n      _this.inputRef.current.focus();\n\n      _this.setState({\n        isTimeOptionsOpen: false,\n        isInvalid: false\n      });\n\n      setIsOpen(false);\n    };\n\n    _this.onInputClick = function (e) {\n      if (!_this.state.isTimeOptionsOpen) {\n        _this.onToggle(true);\n      }\n\n      e.stopPropagation();\n    };\n\n    _this.onInputChange = function (newTime) {\n      var onChange = _this.props.onChange;\n      var timeRegex = _this.state.timeRegex;\n\n      if (onChange) {\n        onChange(newTime, getHours(newTime, timeRegex), getMinutes(newTime, timeRegex), getSeconds(newTime, timeRegex), _this.isValid(newTime));\n      }\n\n      _this.scrollToSelection(newTime);\n\n      _this.setState({\n        timeState: newTime\n      });\n    };\n\n    _this.onBlur = function (event) {\n      var timeRegex = _this.state.timeRegex;\n      var _this$props7 = _this.props,\n          delimiter = _this$props7.delimiter,\n          is24Hour = _this$props7.is24Hour,\n          includeSeconds = _this$props7.includeSeconds;\n      var time = parseTime(event.currentTarget.value, timeRegex, delimiter, !is24Hour, includeSeconds);\n\n      _this.setState({\n        isInvalid: !_this.isValid(time)\n      });\n    };\n\n    var _this$props8 = _this.props,\n        is24Hour = _this$props8.is24Hour,\n        delimiter = _this$props8.delimiter,\n        time = _this$props8.time,\n        includeSeconds = _this$props8.includeSeconds,\n        isOpen = _this$props8.isOpen;\n    var _this$props9 = _this.props,\n        minTime = _this$props9.minTime,\n        maxTime = _this$props9.maxTime;\n\n    if (minTime === '') {\n      var minSeconds = includeSeconds ? \"\".concat(delimiter, \"00\") : '';\n      minTime = is24Hour ? \"00\".concat(delimiter, \"00\").concat(minSeconds) : \"12\".concat(delimiter, \"00\").concat(minSeconds, \" AM\");\n    }\n\n    if (maxTime === '') {\n      var maxSeconds = includeSeconds ? \"\".concat(delimiter, \"59\") : '';\n      maxTime = is24Hour ? \"23\".concat(delimiter, \"59\").concat(maxSeconds) : \"11\".concat(delimiter, \"59\").concat(maxSeconds, \" PM\");\n    }\n\n    var timeRegex = _this.getRegExp();\n\n    _this.state = {\n      isInvalid: false,\n      isTimeOptionsOpen: isOpen,\n      timeState: parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds),\n      focusedIndex: null,\n      scrollIndex: 0,\n      timeRegex: timeRegex,\n      minTimeState: parseTime(minTime, timeRegex, delimiter, !is24Hour, includeSeconds),\n      maxTimeState: parseTime(maxTime, timeRegex, delimiter, !is24Hour, includeSeconds)\n    };\n    return _this;\n  }\n\n  _createClass(TimePicker, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      document.addEventListener('mousedown', this.onDocClick);\n      document.addEventListener('touchstart', this.onDocClick);\n      document.addEventListener('keydown', this.handleGlobalKeys);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      document.removeEventListener('mousedown', this.onDocClick);\n      document.removeEventListener('touchstart', this.onDocClick);\n      document.removeEventListener('keydown', this.handleGlobalKeys);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this$state4 = this.state,\n          timeState = _this$state4.timeState,\n          isTimeOptionsOpen = _this$state4.isTimeOptionsOpen,\n          isInvalid = _this$state4.isInvalid,\n          timeRegex = _this$state4.timeRegex;\n      var _this$props10 = this.props,\n          time = _this$props10.time,\n          is24Hour = _this$props10.is24Hour,\n          delimiter = _this$props10.delimiter,\n          includeSeconds = _this$props10.includeSeconds,\n          isOpen = _this$props10.isOpen;\n\n      if (prevProps.isOpen !== isOpen) {\n        this.onToggle(isOpen);\n      }\n\n      if (isTimeOptionsOpen && !prevState.isTimeOptionsOpen && timeState && !isInvalid) {\n        this.scrollToSelection(timeState);\n      }\n\n      if (delimiter !== prevProps.delimiter) {\n        this.setState({\n          timeRegex: this.getRegExp()\n        });\n      }\n\n      if (time !== '' && time !== prevProps.time) {\n        this.setState({\n          timeState: parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds)\n        });\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _a = this.props,\n          ariaLabel = _a['aria-label'],\n          isDisabled = _a.isDisabled,\n          className = _a.className,\n          placeholder = _a.placeholder,\n          id = _a.id,\n          menuAppendTo = _a.menuAppendTo,\n          is24Hour = _a.is24Hour,\n          invalidFormatErrorMessage = _a.invalidFormatErrorMessage,\n          invalidMinMaxErrorMessage = _a.invalidMinMaxErrorMessage,\n          stepMinutes = _a.stepMinutes,\n          width = _a.width,\n          delimiter = _a.delimiter,\n          inputProps = _a.inputProps,\n          onChange = _a.onChange,\n          setIsOpen = _a.setIsOpen,\n          isOpen = _a.isOpen,\n          time = _a.time,\n          validateTime = _a.validateTime,\n          minTime = _a.minTime,\n          maxTime = _a.maxTime,\n          includeSeconds = _a.includeSeconds,\n          props = __rest(_a, ['aria-label', \"isDisabled\", \"className\", \"placeholder\", \"id\", \"menuAppendTo\", \"is24Hour\", \"invalidFormatErrorMessage\", \"invalidMinMaxErrorMessage\", \"stepMinutes\", \"width\", \"delimiter\", \"inputProps\", \"onChange\", \"setIsOpen\", \"isOpen\", \"time\", \"validateTime\", \"minTime\", \"maxTime\", \"includeSeconds\"]);\n\n      var _this$state5 = this.state,\n          timeState = _this$state5.timeState,\n          isTimeOptionsOpen = _this$state5.isTimeOptionsOpen,\n          isInvalid = _this$state5.isInvalid,\n          minTimeState = _this$state5.minTimeState,\n          maxTimeState = _this$state5.maxTimeState;\n      var style = {\n        '--pf-c-date-picker__input--c-form-control--Width': width\n      };\n      var options = makeTimeOptions(stepMinutes, !is24Hour, delimiter, minTimeState, maxTimeState, includeSeconds);\n      var isValidFormat = this.isValidFormat(timeState);\n      var randomId = id || getUniqueId('time-picker');\n\n      var getParentElement = function getParentElement() {\n        if (_this2.baseComponentRef && _this2.baseComponentRef.current) {\n          return _this2.baseComponentRef.current.parentElement;\n        }\n\n        return null;\n      };\n\n      var menuContainer = React.createElement(Menu, {\n        ref: this.menuRef,\n        isScrollable: true\n      }, React.createElement(MenuContent, {\n        maxMenuHeight: \"200px\"\n      }, React.createElement(MenuList, {\n        \"aria-label\": ariaLabel\n      }, options.map(function (option, index) {\n        return React.createElement(MenuItem, {\n          onClick: _this2.onSelect,\n          key: option,\n          id: \"\".concat(randomId, \"-option-\").concat(index)\n        }, option);\n      }))));\n      var textInput = React.createElement(TextInput, Object.assign({\n        \"aria-haspopup\": \"menu\",\n        className: css(formStyles.formControl),\n        id: \"\".concat(randomId, \"-input\"),\n        \"aria-label\": ariaLabel,\n        validated: isInvalid ? 'error' : 'default',\n        placeholder: placeholder,\n        value: timeState || '',\n        type: \"text\",\n        iconVariant: \"clock\",\n        onClick: this.onInputClick,\n        onChange: this.onInputChange,\n        onBlur: this.onBlur,\n        autoComplete: \"off\",\n        isDisabled: isDisabled,\n        ref: this.inputRef\n      }, inputProps));\n      return React.createElement(\"div\", {\n        ref: this.baseComponentRef,\n        className: css(datePickerStyles.datePicker, className)\n      }, React.createElement(\"div\", Object.assign({\n        className: css(datePickerStyles.datePickerInput),\n        style: style\n      }, props), React.createElement(InputGroup, null, React.createElement(\"div\", {\n        id: randomId\n      }, React.createElement(\"div\", {\n        ref: this.toggleRef,\n        style: {\n          paddingLeft: '0'\n        }\n      }, menuAppendTo !== 'inline' ? React.createElement(Popper, {\n        appendTo: menuAppendTo === 'parent' ? getParentElement() : menuAppendTo,\n        trigger: textInput,\n        popper: menuContainer,\n        isVisible: isTimeOptionsOpen\n      }) : textInput), isTimeOptionsOpen && menuAppendTo === 'inline' && menuContainer)), isInvalid && React.createElement(\"div\", {\n        className: css(datePickerStyles.datePickerHelperText, datePickerStyles.modifiers.error)\n      }, !isValidFormat ? invalidFormatErrorMessage : invalidMinMaxErrorMessage)));\n    }\n  }]);\n\n  return TimePicker;\n}(React.Component);\nTimePicker.displayName = 'TimePicker';\nTimePicker.defaultProps = {\n  className: '',\n  isDisabled: false,\n  time: '',\n  is24Hour: false,\n  invalidFormatErrorMessage: 'Invalid time format',\n  invalidMinMaxErrorMessage: 'Invalid time entered',\n  placeholder: 'hh:mm',\n  delimiter: ':',\n  'aria-label': 'Time picker',\n  width: '150px',\n  menuAppendTo: 'inline',\n  stepMinutes: 30,\n  inputProps: {},\n  minTime: '',\n  maxTime: '',\n  setIsOpen: function setIsOpen() {}\n};","map":{"version":3,"sources":["/awx_devel/awx/ui/node_modules/@patternfly/react-core/src/components/TimePicker/TimePicker.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { css } from '@patternfly/react-styles';\nimport datePickerStyles from '@patternfly/react-styles/css/components/DatePicker/date-picker';\nimport formStyles from '@patternfly/react-styles/css/components/FormControl/form-control';\nimport menuStyles from '@patternfly/react-styles/css/components/Menu/menu';\nimport { getUniqueId } from '../../helpers';\nimport { Popper } from '../../helpers/Popper/Popper';\nimport { Menu, MenuContent, MenuList, MenuItem } from '../Menu';\nimport { InputGroup } from '../InputGroup';\nimport { TextInput, TextInputProps } from '../TextInput';\nimport { KeyTypes } from '../../helpers/constants';\nimport {\n  parseTime,\n  validateTime,\n  makeTimeOptions,\n  amSuffix,\n  pmSuffix,\n  getHours,\n  getMinutes,\n  isWithinMinMax,\n  getSeconds\n} from './TimePickerUtils';\n\nexport interface TimePickerProps\n  extends Omit<React.HTMLProps<HTMLDivElement>, 'onChange' | 'onFocus' | 'onBlur' | 'disabled' | 'ref'> {\n  /** Additional classes added to the time picker. */\n  className?: string;\n  /** Accessible label for the time picker */\n  'aria-label'?: string;\n  /** Flag indicating the time picker is disabled */\n  isDisabled?: boolean;\n  /** String to display in the empty time picker field as a hint for the expected time format */\n  placeholder?: string;\n  /** Character to display between the hour and minute */\n  delimiter?: string;\n  /** A time string. The format could be  an ISO 8601 formatted date string or in 'HH{delimiter}MM' format */\n  time?: string | Date;\n  /** Error message to display when the time is provided in an invalid format. */\n  invalidFormatErrorMessage?: string;\n  /** Error message to display when the time provided is not within the minTime/maxTime constriants */\n  invalidMinMaxErrorMessage?: string;\n  /** True if the time is 24 hour time. False if the time is 12 hour time */\n  is24Hour?: boolean;\n  /** Optional event handler called each time the value in the time picker input changes. */\n  onChange?: (time: string, hour?: number, minute?: number, seconds?: number, isValid?: boolean) => void;\n  /** Optional validator can be provided to override the internal time validator. */\n  validateTime?: (time: string) => boolean;\n  /** Id of the time picker */\n  id?: string;\n  /** Width of the time picker. */\n  width?: string;\n  /** The container to append the menu to. Defaults to 'inline'.\n   * If your menu is being cut off you can append it to an element higher up the DOM tree.\n   * Some examples:\n   * menuAppendTo=\"parent\"\n   * menuAppendTo={() => document.body}\n   * menuAppendTo={document.getElementById('target')}\n   */\n  menuAppendTo?: HTMLElement | (() => HTMLElement) | 'inline' | 'parent';\n  /** Size of step between time options in minutes.*/\n  stepMinutes?: number;\n  /** Additional props for input field */\n  inputProps?: TextInputProps;\n  /** A time string indicating the minimum value allowed. The format could be an ISO 8601 formatted date string or in 'HH{delimiter}MM' format */\n  minTime?: string | Date;\n  /** A time string indicating the maximum value allowed. The format could be an ISO 8601 formatted date string or in 'HH{delimiter}MM' format */\n  maxTime?: string | Date;\n  /** Includes number of seconds with the chosen time and allows users to manually edit the seconds value. */\n  includeSeconds?: boolean;\n  /** Flag to control the opened state of the time picker menu */\n  isOpen?: boolean;\n  /** Handler invoked each time the open state of time picker updates */\n  setIsOpen?: (isOpen?: boolean) => void;\n}\n\ninterface TimePickerState {\n  isInvalid: boolean;\n  isTimeOptionsOpen: boolean;\n  timeState: string;\n  focusedIndex: number;\n  scrollIndex: number;\n  timeRegex: RegExp;\n  minTimeState: string;\n  maxTimeState: string;\n}\n\nexport class TimePicker extends React.Component<TimePickerProps, TimePickerState> {\n  static displayName = 'TimePicker';\n  private baseComponentRef = React.createRef<any>();\n  private toggleRef = React.createRef<HTMLDivElement>();\n  private inputRef = React.createRef<HTMLInputElement>();\n  private menuRef = React.createRef<HTMLDivElement>();\n\n  static defaultProps = {\n    className: '',\n    isDisabled: false,\n    time: '',\n    is24Hour: false,\n    invalidFormatErrorMessage: 'Invalid time format',\n    invalidMinMaxErrorMessage: 'Invalid time entered',\n    placeholder: 'hh:mm',\n    delimiter: ':',\n    'aria-label': 'Time picker',\n    width: '150px',\n    menuAppendTo: 'inline',\n    stepMinutes: 30,\n    inputProps: {},\n    minTime: '',\n    maxTime: '',\n    setIsOpen: () => {}\n  };\n\n  constructor(props: TimePickerProps) {\n    super(props);\n    const { is24Hour, delimiter, time, includeSeconds, isOpen } = this.props;\n    let { minTime, maxTime } = this.props;\n    if (minTime === '') {\n      const minSeconds = includeSeconds ? `${delimiter}00` : '';\n      minTime = is24Hour ? `00${delimiter}00${minSeconds}` : `12${delimiter}00${minSeconds} AM`;\n    }\n    if (maxTime === '') {\n      const maxSeconds = includeSeconds ? `${delimiter}59` : '';\n      maxTime = is24Hour ? `23${delimiter}59${maxSeconds}` : `11${delimiter}59${maxSeconds} PM`;\n    }\n    const timeRegex = this.getRegExp();\n    this.state = {\n      isInvalid: false,\n      isTimeOptionsOpen: isOpen,\n      timeState: parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds),\n      focusedIndex: null,\n      scrollIndex: 0,\n      timeRegex,\n      minTimeState: parseTime(minTime, timeRegex, delimiter, !is24Hour, includeSeconds),\n      maxTimeState: parseTime(maxTime, timeRegex, delimiter, !is24Hour, includeSeconds)\n    };\n  }\n\n  componentDidMount() {\n    document.addEventListener('mousedown', this.onDocClick);\n    document.addEventListener('touchstart', this.onDocClick);\n    document.addEventListener('keydown', this.handleGlobalKeys);\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('mousedown', this.onDocClick);\n    document.removeEventListener('touchstart', this.onDocClick);\n    document.removeEventListener('keydown', this.handleGlobalKeys);\n  }\n\n  onDocClick = (event: MouseEvent | TouchEvent) => {\n    const clickedOnToggle = this.toggleRef?.current?.contains(event.target as Node);\n    const clickedWithinMenu = this.menuRef?.current?.contains(event.target as Node);\n    if (this.state.isTimeOptionsOpen && !(clickedOnToggle || clickedWithinMenu)) {\n      this.onToggle(false);\n    }\n  };\n\n  handleGlobalKeys = (event: KeyboardEvent) => {\n    const { isTimeOptionsOpen, focusedIndex, scrollIndex } = this.state;\n    // keyboard pressed while focus on toggle\n    if (this.inputRef?.current?.contains(event.target as Node)) {\n      if (!isTimeOptionsOpen && event.key !== KeyTypes.Tab && event.key !== KeyTypes.Escape) {\n        this.onToggle(true);\n      } else if (isTimeOptionsOpen) {\n        if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n          this.onToggle(false);\n        } else if (event.key === KeyTypes.Enter) {\n          if (focusedIndex !== null) {\n            this.focusSelection(focusedIndex);\n            event.stopPropagation();\n          } else {\n            this.onToggle(false);\n          }\n        } else if (event.key === KeyTypes.ArrowDown || event.key === KeyTypes.ArrowUp) {\n          this.focusSelection(scrollIndex);\n          this.updateFocusedIndex(0);\n          event.preventDefault();\n        }\n      }\n      // keyboard pressed while focus on menu item\n    } else if (this.menuRef?.current?.contains(event.target as Node)) {\n      if (event.key === KeyTypes.ArrowDown) {\n        this.updateFocusedIndex(1);\n        event.preventDefault();\n      } else if (event.key === KeyTypes.ArrowUp) {\n        this.updateFocusedIndex(-1);\n        event.preventDefault();\n      } else if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n        this.inputRef.current.focus();\n        this.onToggle(false);\n      }\n    }\n  };\n\n  componentDidUpdate(prevProps: TimePickerProps, prevState: TimePickerState) {\n    const { timeState, isTimeOptionsOpen, isInvalid, timeRegex } = this.state;\n    const { time, is24Hour, delimiter, includeSeconds, isOpen } = this.props;\n    if (prevProps.isOpen !== isOpen) {\n      this.onToggle(isOpen);\n    }\n\n    if (isTimeOptionsOpen && !prevState.isTimeOptionsOpen && timeState && !isInvalid) {\n      this.scrollToSelection(timeState);\n    }\n    if (delimiter !== prevProps.delimiter) {\n      this.setState({\n        timeRegex: this.getRegExp()\n      });\n    }\n    if (time !== '' && time !== prevProps.time) {\n      this.setState({\n        timeState: parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds)\n      });\n    }\n  }\n\n  updateFocusedIndex = (increment: number) => {\n    this.setState(prevState => {\n      const maxIndex = this.getOptions().length - 1;\n      let nextIndex =\n        prevState.focusedIndex !== null ? prevState.focusedIndex + increment : prevState.scrollIndex + increment;\n      if (nextIndex < 0) {\n        nextIndex = maxIndex;\n      } else if (nextIndex > maxIndex) {\n        nextIndex = 0;\n      }\n      this.scrollToIndex(nextIndex);\n      return {\n        focusedIndex: nextIndex\n      };\n    });\n  };\n\n  // fixes issue where menutAppendTo=\"inline\" results in the menu item that should be scrolled to being out of view; this will select the menu item that comes before the intended one, causing that before-item to be placed out of view instead\n  getIndexToScroll = (index: number) => {\n    if (this.props.menuAppendTo === 'inline') {\n      return index > 0 ? index - 1 : 0;\n    }\n    return index;\n  };\n\n  scrollToIndex = (index: number) => {\n    this.getOptions()[index].closest(`.${menuStyles.menuContent}`).scrollTop = this.getOptions()[\n      this.getIndexToScroll(index)\n    ].offsetTop;\n  };\n\n  focusSelection = (index: number) => {\n    const indexToFocus = index !== -1 ? index : 0;\n\n    if (this.menuRef?.current) {\n      (this.getOptions()[indexToFocus].querySelector(`.${menuStyles.menuItem}`) as HTMLElement).focus();\n    }\n  };\n\n  scrollToSelection = (time: string) => {\n    const { delimiter, is24Hour } = this.props;\n    let splitTime = time.split(this.props.delimiter);\n    let focusedIndex = null;\n\n    // build out the rest of the time assuming hh:00 if it's a partial time\n    if (splitTime.length < 2) {\n      time = `${time}${delimiter}00`;\n      splitTime = time.split(delimiter);\n      // due to only the input including seconds when includeSeconds=true, we need to build a temporary time here without those seconds so that an exact or close match can be scrolled to within the menu (which does not include seconds in any of the options)\n    } else if (splitTime.length > 2) {\n      time = parseTime(time, this.state.timeRegex, delimiter, !is24Hour, false);\n      splitTime = time.split(delimiter);\n    }\n\n    // for 12hr variant, autoscroll to pm if it's currently the afternoon, otherwise autoscroll to am\n    if (!is24Hour && splitTime.length > 1 && splitTime[1].length < 2) {\n      const minutes = splitTime[1].length === 0 ? '00' : splitTime[1] + '0';\n      time = `${splitTime[0]}${delimiter}${minutes}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n    } else if (\n      !is24Hour &&\n      splitTime.length > 1 &&\n      splitTime[1].length === 2 &&\n      !time.toUpperCase().includes(amSuffix.toUpperCase().trim()) &&\n      !time.toUpperCase().includes(pmSuffix.toUpperCase().trim())\n    ) {\n      time = `${time}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n    }\n    let scrollIndex = this.getOptions().findIndex(option => option.innerText === time);\n\n    // if we found an exact match, scroll to match and return index of match for focus\n    if (scrollIndex !== -1) {\n      this.scrollToIndex(scrollIndex);\n      focusedIndex = scrollIndex;\n    } else if (splitTime.length === 2) {\n      // no exact match, scroll to closest hour but don't return index for focus\n      let amPm = '';\n      if (!is24Hour) {\n        if (splitTime[1].toUpperCase().includes('P')) {\n          amPm = pmSuffix;\n        } else if (splitTime[1].toUpperCase().includes('A')) {\n          amPm = amSuffix;\n        }\n      }\n      time = `${splitTime[0]}${delimiter}00${amPm}`;\n      scrollIndex = this.getOptions().findIndex(option => option.innerText === time);\n      if (scrollIndex !== -1) {\n        this.scrollToIndex(scrollIndex);\n      }\n    }\n    this.setState({\n      focusedIndex,\n      scrollIndex\n    });\n  };\n\n  getRegExp = (includeSeconds: boolean = true) => {\n    const { is24Hour, delimiter } = this.props;\n    let baseRegex = `\\\\s*(\\\\d\\\\d?)${delimiter}([0-5]\\\\d)`;\n\n    if (includeSeconds) {\n      baseRegex += `${delimiter}?([0-5]\\\\d)?`;\n    }\n\n    return new RegExp(`^${baseRegex}${is24Hour ? '' : '\\\\s*([AaPp][Mm])?'}\\\\s*$`);\n  };\n\n  getOptions = () =>\n    (this.menuRef?.current\n      ? Array.from(this.menuRef.current.querySelectorAll(`.${menuStyles.menuListItem}`))\n      : []) as HTMLElement[];\n\n  isValidFormat = (time: string) => {\n    if (this.props.validateTime) {\n      return this.props.validateTime(time);\n    }\n\n    const { delimiter, is24Hour, includeSeconds } = this.props;\n    return validateTime(time, this.getRegExp(includeSeconds), delimiter, !is24Hour);\n  };\n\n  isValidTime = (time: string) => {\n    const { delimiter, includeSeconds } = this.props;\n    const { minTimeState, maxTimeState } = this.state;\n\n    return isWithinMinMax(minTimeState, maxTimeState, time, delimiter, includeSeconds);\n  };\n\n  isValid = (time: string) => this.isValidFormat(time) && this.isValidTime(time);\n\n  onToggle = (isOpen: boolean) => {\n    // on close, parse and validate input\n    this.setState(prevState => {\n      const { timeRegex, isInvalid } = prevState;\n      const { delimiter, is24Hour, includeSeconds } = this.props;\n      const time = parseTime(prevState.timeState, timeRegex, delimiter, !is24Hour, includeSeconds);\n      return {\n        isTimeOptionsOpen: isOpen,\n        timeState: time,\n        isInvalid: isOpen ? isInvalid : !this.isValid(time)\n      };\n    });\n    this.props.setIsOpen(isOpen);\n    if (!isOpen) {\n      this.inputRef.current.focus();\n    }\n  };\n\n  onSelect = (e: any) => {\n    const { timeRegex, timeState } = this.state;\n    const { delimiter, is24Hour, includeSeconds, setIsOpen } = this.props;\n    const time = parseTime(e.target.textContent, timeRegex, delimiter, !is24Hour, includeSeconds);\n    if (time !== timeState) {\n      this.onInputChange(time);\n    }\n\n    this.inputRef.current.focus();\n    this.setState({\n      isTimeOptionsOpen: false,\n      isInvalid: false\n    });\n    setIsOpen(false);\n  };\n\n  onInputClick = (e: any) => {\n    if (!this.state.isTimeOptionsOpen) {\n      this.onToggle(true);\n    }\n    e.stopPropagation();\n  };\n\n  onInputChange = (newTime: string) => {\n    const { onChange } = this.props;\n    const { timeRegex } = this.state;\n\n    if (onChange) {\n      onChange(\n        newTime,\n        getHours(newTime, timeRegex),\n        getMinutes(newTime, timeRegex),\n        getSeconds(newTime, timeRegex),\n        this.isValid(newTime)\n      );\n    }\n    this.scrollToSelection(newTime);\n    this.setState({\n      timeState: newTime\n    });\n  };\n\n  onBlur = (event: React.FocusEvent<HTMLInputElement>) => {\n    const { timeRegex } = this.state;\n    const { delimiter, is24Hour, includeSeconds } = this.props;\n    const time = parseTime(event.currentTarget.value, timeRegex, delimiter, !is24Hour, includeSeconds);\n\n    this.setState({\n      isInvalid: !this.isValid(time)\n    });\n  };\n\n  render() {\n    const {\n      'aria-label': ariaLabel,\n      isDisabled,\n      className,\n      placeholder,\n      id,\n      menuAppendTo,\n      is24Hour,\n      invalidFormatErrorMessage,\n      invalidMinMaxErrorMessage,\n      stepMinutes,\n      width,\n      delimiter,\n      inputProps,\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      onChange,\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      setIsOpen,\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      isOpen,\n      time,\n      validateTime,\n      minTime,\n      maxTime,\n      includeSeconds,\n      /* eslint-enable @typescript-eslint/no-unused-vars */\n      ...props\n    } = this.props;\n    const { timeState, isTimeOptionsOpen, isInvalid, minTimeState, maxTimeState } = this.state;\n    const style = { '--pf-c-date-picker__input--c-form-control--Width': width } as React.CSSProperties;\n    const options = makeTimeOptions(stepMinutes, !is24Hour, delimiter, minTimeState, maxTimeState, includeSeconds);\n    const isValidFormat = this.isValidFormat(timeState);\n    const randomId = id || getUniqueId('time-picker');\n\n    const getParentElement = () => {\n      if (this.baseComponentRef && this.baseComponentRef.current) {\n        return this.baseComponentRef.current.parentElement;\n      }\n      return null;\n    };\n\n    const menuContainer = (\n      <Menu ref={this.menuRef} isScrollable>\n        <MenuContent maxMenuHeight=\"200px\">\n          <MenuList aria-label={ariaLabel}>\n            {options.map((option, index) => (\n              <MenuItem onClick={this.onSelect} key={option} id={`${randomId}-option-${index}`}>\n                {option}\n              </MenuItem>\n            ))}\n          </MenuList>\n        </MenuContent>\n      </Menu>\n    );\n\n    const textInput = (\n      <TextInput\n        aria-haspopup=\"menu\"\n        className={css(formStyles.formControl)}\n        id={`${randomId}-input`}\n        aria-label={ariaLabel}\n        validated={isInvalid ? 'error' : 'default'}\n        placeholder={placeholder}\n        value={timeState || ''}\n        type=\"text\"\n        iconVariant=\"clock\"\n        onClick={this.onInputClick}\n        onChange={this.onInputChange}\n        onBlur={this.onBlur}\n        autoComplete=\"off\"\n        isDisabled={isDisabled}\n        ref={this.inputRef}\n        {...inputProps}\n      />\n    );\n\n    return (\n      <div ref={this.baseComponentRef} className={css(datePickerStyles.datePicker, className)}>\n        <div className={css(datePickerStyles.datePickerInput)} style={style} {...props}>\n          <InputGroup>\n            <div id={randomId}>\n              <div ref={this.toggleRef} style={{ paddingLeft: '0' }}>\n                {menuAppendTo !== 'inline' ? (\n                  <Popper\n                    appendTo={menuAppendTo === 'parent' ? getParentElement() : menuAppendTo}\n                    trigger={textInput}\n                    popper={menuContainer}\n                    isVisible={isTimeOptionsOpen}\n                  />\n                ) : (\n                  textInput\n                )}\n              </div>\n              {isTimeOptionsOpen && menuAppendTo === 'inline' && menuContainer}\n            </div>\n          </InputGroup>\n          {isInvalid && (\n            <div className={css(datePickerStyles.datePickerHelperText, datePickerStyles.modifiers.error)}>\n              {!isValidFormat ? invalidFormatErrorMessage : invalidMinMaxErrorMessage}\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}